{"version":3,"file":"ractive.runtime.min.js","sources":["../src/Ractive/static/adaptors/array/index.js","../src/Ractive/static/adaptors/magic.js","../src/utils/createBranch.js","../src/Ractive/static/adaptors/magicArray.js","../src/viewmodel/prototype/adapt.js","../src/viewmodel/prototype/applyChanges/notifyPatternObservers.js","../src/viewmodel/prototype/capture.js","../src/viewmodel/prototype/clearCache.js","../src/viewmodel/Computation/UnresolvedDependency.js","../src/viewmodel/Computation/Computation.js","../src/viewmodel/prototype/get.js","../src/viewmodel/prototype/init.js","../src/viewmodel/prototype/map.js","../src/viewmodel/prototype/mark.js","../src/viewmodel/prototype/merge/mapOldToNewIndex.js","../src/viewmodel/prototype/merge.js","../src/viewmodel/prototype/register.js","../src/viewmodel/prototype/release.js","../src/viewmodel/prototype/reset.js","../src/viewmodel/prototype/smartUpdate.js","../src/viewmodel/prototype/teardown.js","../src/viewmodel/Viewmodel.js","../src/Ractive/prototype/shared/hooks/HookQueue.js","../src/Ractive/helpers/getComputationSignatures.js","../src/Ractive/initialise.js","../src/virtualdom/items/Component/initialise/ComplexParameter.js","../src/virtualdom/items/Component/initialise/createInstance.js","../src/virtualdom/items/Component/initialise/updateLiveQueries.js","../src/virtualdom/items/Component/prototype/rebind.js","../src/virtualdom/items/Component/prototype/render.js","../src/virtualdom/items/Component/prototype/toString.js","../src/virtualdom/items/Component/prototype/unbind.js","../src/virtualdom/items/Component/prototype/unrender.js","../src/virtualdom/items/Component/_Component.js","../src/virtualdom/items/Comment.js","../src/virtualdom/items/Yielder.js","../src/virtualdom/items/Doctype.js","../src/virtualdom/Fragment/prototype/render.js","../src/virtualdom/Fragment/prototype/toString.js","../src/virtualdom/Fragment/prototype/unbind.js","../src/virtualdom/Fragment/prototype/unrender.js","../src/virtualdom/Fragment.js","../src/Ractive.js","../src/Ractive/prototype/reset.js","../src/Ractive/prototype/resetPartial.js","../src/Ractive/prototype/reverse.js","../src/Ractive/prototype/shift.js","../src/Ractive/prototype/sort.js","../src/Ractive/prototype/splice.js","../src/Ractive/prototype/teardown.js","../src/Ractive/prototype/toHTML.js","../src/Ractive/prototype/unrender.js","../src/Ractive/prototype/unshift.js","../src/Ractive/prototype/update.js","../src/Ractive/prototype.js","../src/utils/wrapMethod.js","../src/extend/_extend.js","../src/Ractive/static/getNodeInfo.js","../src/virtualdom/items/shared/Resolvers/ReferenceResolver.js","../src/virtualdom/items/shared/Resolvers/SpecialResolver.js","../src/virtualdom/items/shared/Resolvers/IndexResolver.js","../src/virtualdom/items/shared/Resolvers/findIndexRefs.js","../src/virtualdom/items/shared/Resolvers/ExpressionResolver.js","../src/shared/getFunctionFromString.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js","../src/virtualdom/items/shared/Mustache/resolve.js","../src/virtualdom/items/shared/Mustache/rebind.js","../src/virtualdom/items/shared/Mustache/_Mustache.js","../src/virtualdom/items/Interpolator.js","../src/virtualdom/items/Section/prototype/bubble.js","../src/virtualdom/items/Section/prototype/detach.js","../src/virtualdom/items/Section/prototype/find.js","../src/virtualdom/items/Section/prototype/findAll.js","../src/virtualdom/items/Section/prototype/findComponent.js","../src/virtualdom/items/Section/prototype/findNextNode.js","../src/virtualdom/items/Section/prototype/firstNode.js","../src/virtualdom/items/Section/prototype/rebind.js","../src/virtualdom/items/Section/prototype/render.js","../src/virtualdom/items/Section/prototype/toString.js","../src/virtualdom/items/Section/prototype/unrender.js","../src/virtualdom/items/Section/prototype/update.js","../src/virtualdom/items/Section/_Section.js","../src/virtualdom/items/Triple/helpers/insertHtml.js","../src/virtualdom/items/Triple/prototype/detach.js","../src/virtualdom/items/Triple/prototype/firstNode.js","../src/virtualdom/items/Triple/_Triple.js","../src/virtualdom/items/Element/shared/enforceCase.js","../src/virtualdom/items/Element/prototype/bubble.js","../src/virtualdom/items/Element/prototype/detach.js","../src/virtualdom/items/Element/prototype/find.js","../src/virtualdom/items/Element/prototype/findAll.js","../src/virtualdom/items/Element/prototype/findAllComponents.js","../src/virtualdom/items/Element/prototype/findComponent.js","../src/virtualdom/items/Element/prototype/findNextNode.js","../src/virtualdom/items/Element/prototype/firstNode.js","../src/virtualdom/items/Element/prototype/getAttribute.js","../src/virtualdom/items/Element/prototype/init/processBindingAttributes.js","../src/virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js","../src/virtualdom/items/Element/Attribute/prototype/rebind.js","../src/virtualdom/items/Element/Attribute/prototype/render.js","../src/virtualdom/items/Element/Attribute/prototype/toString.js","../src/virtualdom/items/Element/Attribute/prototype/unbind.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js","../src/virtualdom/items/Element/Attribute/_Attribute.js","../src/virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js","../src/virtualdom/items/Element/prototype/init/createAttributes.js","../src/virtualdom/items/Element/prototype/init/createConditionalAttributes.js","../src/virtualdom/items/Element/Binding/Binding.js","../src/virtualdom/items/Element/Binding/GenericBinding.js","../src/virtualdom/items/Element/Binding/ContentEditableBinding.js","../src/virtualdom/items/Element/Binding/shared/getSiblings.js","../src/virtualdom/items/Element/Binding/RadioBinding.js","../src/virtualdom/items/Element/Binding/RadioNameBinding.js","../src/virtualdom/items/Element/Binding/CheckboxNameBinding.js","../src/virtualdom/items/Element/Binding/CheckboxBinding.js","../src/virtualdom/items/Element/Binding/SelectBinding.js","../src/virtualdom/items/Element/Binding/MultipleSelectBinding.js","../src/virtualdom/items/Element/Binding/FileListBinding.js","../src/virtualdom/items/Element/Binding/NumericBinding.js","../src/virtualdom/items/Element/EventHandler/prototype/bubble.js","../src/virtualdom/items/Element/EventHandler/prototype/getAction.js","../src/virtualdom/items/Element/EventHandler/prototype/init.js","../src/virtualdom/items/Element/EventHandler/prototype/listen.js","../src/virtualdom/items/Element/EventHandler/prototype/rebind.js","../src/virtualdom/items/Element/EventHandler/prototype/render.js","../src/virtualdom/items/Element/EventHandler/prototype/resolve.js","../src/virtualdom/items/Element/EventHandler/_EventHandler.js","../src/virtualdom/items/Element/prototype/init/createEventHandlers.js","../src/virtualdom/items/Element/Decorator/_Decorator.js","../src/virtualdom/items/Element/Transition/helpers/prefix.js","../src/utils/camelCase.js","../src/virtualdom/items/Element/Transition/prototype/getStyle.js","../src/virtualdom/items/Element/Transition/prototype/setStyle.js","../src/shared/Ticker.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js","../src/virtualdom/items/Element/Transition/helpers/unprefix.js","../src/virtualdom/items/Element/Transition/helpers/hyphenate.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js","../src/virtualdom/items/Element/Transition/prototype/processParams.js","../src/virtualdom/items/Element/Transition/prototype/start.js","../src/virtualdom/items/Element/Transition/_Transition.js","../src/virtualdom/items/Element/prototype/render.js","../src/virtualdom/items/Element/prototype/toString.js","../src/virtualdom/items/Element/_Element.js","../src/virtualdom/items/Partial/deIndent.js","../src/virtualdom/items/Partial/applyIndent.js","../src/virtualdom/items/Partial/_Partial.js","../src/Ractive/static/adaptors/array/patch.js","../src/virtualdom/items/Component/prototype/detach.js","../src/virtualdom/items/Component/prototype/find.js","../src/virtualdom/items/Component/prototype/findAll.js","../src/virtualdom/items/Component/prototype/findAllComponents.js","../src/virtualdom/items/Component/prototype/findComponent.js","../src/virtualdom/items/Component/prototype/findNextNode.js","../src/virtualdom/items/Component/prototype/firstNode.js","../src/Ractive/static/adaptors/array/processWrapper.js","../src/Ractive/prototype/resetTemplate.js","../src/Ractive/prototype/set.js","../src/Ractive/prototype/subtract.js","../src/Ractive/prototype/toggle.js","../src/Ractive/prototype/updateModel.js","../src/extend/unwrapExtended.js","../src/config/template.js","../src/config/environment.js","../src/Ractive/config/defaults.js","../src/Ractive/static/easing.js","../src/utils/dom.js","../src/legacy.js","../src/utils/object.js","../src/utils/log.js","../src/utils/is.js","../src/utils/noop.js","../src/config/errors.js","../src/shared/interpolate.js","../src/Ractive/static/interpolators.js","../src/utils/getPotentialWildcardMatches.js","../src/shared/keypaths.js","../src/utils/requestAnimationFrame.js","../src/Ractive/prototype/shared/add.js","../src/utils/getTime.js","../src/Ractive/prototype/shared/hooks/Hook.js","../src/utils/Promise.js","../src/shared/getInnerContext.js","../src/global/TransitionManager.js","../src/global/runloop.js","../src/shared/animations.js","../src/Ractive/prototype/animate/Animation.js","../src/Ractive/prototype/animate.js","../src/Ractive/prototype/detach.js","../src/Ractive/prototype/find.js","../src/Ractive/prototype/shared/makeQuery/cancel.js","../src/Ractive/prototype/shared/makeQuery/sortByItemPosition.js","../src/Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js","../src/Ractive/prototype/shared/makeQuery/sort.js","../src/Ractive/prototype/shared/makeQuery/dirty.js","../src/Ractive/prototype/shared/makeQuery/remove.js","../src/Ractive/prototype/findComponent.js","../src/Ractive/prototype/findParent.js","../src/Ractive/prototype/shared/eventStack.js","../src/Ractive/prototype/get.js","../src/Ractive/prototype/insert.js","../src/Ractive/prototype/observe/Observer.js","../src/Ractive/prototype/observe/PatternObserver.js","../src/global/css.js","../src/Ractive/prototype/observe/getObserverFacade.js","../src/Ractive/prototype/observeOnce.js","../src/Ractive/prototype/shared/trim.js","../src/Ractive/prototype/shared/notEmptyString.js","../src/Ractive/prototype/once.js","../src/Ractive/prototype/shared/makeArrayMethod.js","../src/Ractive/prototype/pop.js","../src/Ractive/prototype/push.js","../src/Ractive/config/registries.js","../src/Ractive/prototype/render.js","../src/Ractive/config/custom/adapt.js","../src/Ractive/config/custom/css/transform.js","../src/Ractive/config/custom/css/css.js","../src/Ractive/config/custom/data.js","../src/Ractive/config/custom/template/parser.js","../src/Ractive/config/custom/template/template.js","../src/Ractive/config/config.js","../src/parse/Parser.js","../src/virtualdom/Fragment/prototype/bubble.js","../src/virtualdom/Fragment/prototype/detach.js","../src/virtualdom/Fragment/prototype/find.js","../src/virtualdom/Fragment/prototype/findAll.js","../src/virtualdom/Fragment/prototype/findAllComponents.js","../src/virtualdom/Fragment/prototype/findComponent.js","../src/virtualdom/Fragment/prototype/findNextNode.js","../src/virtualdom/Fragment/prototype/firstNode.js","../src/parse/converters/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js","../src/config/types.js","../src/utils/parseJSON.js","../src/parse/converters/expressions/primary/literal/readStringLiteral.js","../src/parse/converters/expressions/primary/literal/readNumberLiteral.js","../src/parse/converters/expressions/shared/patterns.js","../src/parse/converters/expressions/shared/readKey.js","../src/utils/html.js","../src/virtualdom/Fragment/prototype/shared/processItems.js","../src/virtualdom/Fragment/prototype/getNode.js","../src/virtualdom/items/shared/detach.js","../src/virtualdom/items/Text.js","../src/virtualdom/items/shared/Mustache/getValue.js","../src/virtualdom/items/Triple/prototype/update.js","../src/virtualdom/items/Element/Attribute/prototype/bubble.js","../src/virtualdom/items/Element/Attribute/helpers/getInterpolator.js","../src/virtualdom/items/Element/Attribute/prototype/init.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateClassName.js","../src/virtualdom/items/Element/Attribute/prototype/update.js","../src/virtualdom/items/Element/Binding/shared/handleDomEvent.js","../src/virtualdom/items/Element/prototype/init/createTwowayBinding.js","../src/virtualdom/items/Element/EventHandler/prototype/fire.js","../src/virtualdom/items/Element/EventHandler/shared/genericHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/unbind.js","../src/virtualdom/items/Element/EventHandler/prototype/unrender.js","../src/virtualdom/items/Element/special/select.js","../src/virtualdom/items/Element/special/option.js","../src/virtualdom/items/Element/prototype/init.js","../src/virtualdom/items/Element/prototype/rebind.js","../src/virtualdom/items/Element/special/img.js","../src/virtualdom/items/Element/special/form.js","../src/virtualdom/items/Element/Transition/prototype/init.js","../src/virtualdom/items/Element/prototype/unbind.js","../src/virtualdom/items/Element/prototype/unrender.js","../src/virtualdom/items/Partial/getPartialTemplate.js","../src/virtualdom/items/Component/getComponent.js","../src/viewmodel/helpers/getUpstreamChanges.js","../src/viewmodel/prototype/applyChanges.js","../src/viewmodel/prototype/compute.js","../src/viewmodel/prototype/set.js","../src/viewmodel/prototype/unregister.js","../src/virtualdom/items/Component/initialise/propagateEvents.js","../src/virtualdom/items/Component/prototype/init.js","../src/virtualdom/Fragment/prototype/init.js","../src/virtualdom/Fragment/prototype/rebind.js","../src/shared/registry.js","../src/Ractive/prototype/add.js","../src/utils/array.js","../src/shared/resolveRef.js","../src/shared/methodCallers.js","../src/Ractive/prototype/shared/makeQuery/test.js","../src/Ractive/prototype/shared/makeQuery/_makeQuery.js","../src/Ractive/prototype/findAll.js","../src/Ractive/prototype/findAllComponents.js","../src/Ractive/prototype/findContainer.js","../src/Ractive/prototype/shared/fireEvent.js","../src/Ractive/prototype/fire.js","../src/Ractive/prototype/merge.js","../src/Ractive/prototype/observe/getPattern.js","../src/Ractive/prototype/observe.js","../src/Ractive/prototype/off.js","../src/Ractive/prototype/on.js","../src/shared/getNewIndices.js","../src/Ractive/config/wrapPrototypeMethod.js","../src/Ractive/config/deprecate.js","../src/virtualdom/Fragment/prototype/getArgsList.js","../src/virtualdom/Fragment/prototype/getValue.js","../src/virtualdom/items/shared/unbind.js","../src/virtualdom/items/shared/Resolvers/createReferenceResolver.js","../src/virtualdom/items/shared/Mustache/initialise.js","../src/virtualdom/items/Section/prototype/findAllComponents.js","../src/virtualdom/items/Section/prototype/shuffle.js","../src/virtualdom/items/Section/prototype/setValue.js","../src/virtualdom/items/Section/prototype/unbind.js","../src/virtualdom/items/Triple/prototype/find.js","../src/virtualdom/items/Triple/prototype/findAll.js","../src/virtualdom/items/Triple/helpers/updateSelect.js","../src/virtualdom/items/Triple/prototype/render.js","../src/virtualdom/items/Triple/prototype/setValue.js","../src/virtualdom/items/Triple/prototype/toString.js","../src/virtualdom/items/Triple/prototype/unrender.js"],"sourcesContent":["import { defineProperty } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport { getKeypath } from 'shared/keypaths';\nimport patch from './patch';\n\nvar arrayAdaptor,\n\n\t// helpers\n\tArrayWrapper,\n\terrorMessage;\n\narrayAdaptor = {\n\tfilter: function ( object ) {\n\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t// or the array didn't trigger the get() itself\n\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t},\n\twrap: function ( ractive, array, keypath ) {\n\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t}\n};\n\nArrayWrapper = function ( ractive, array, keypath ) {\n\tthis.root = ractive;\n\tthis.value = array;\n\tthis.keypath = getKeypath( keypath );\n\n\t// if this array hasn't already been ractified, ractify it\n\tif ( !array._ractive ) {\n\n\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\tdefineProperty( array, '_ractive', {\n\t\t\tvalue: {\n\t\t\t\twrappers: [],\n\t\t\t\tinstances: [],\n\t\t\t\tsetting: false\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tpatch( array );\n\t}\n\n\t// store the ractive instance, so we can handle transitions later\n\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\tarray._ractive.instances.push( ractive );\n\t}\n\n\tarray._ractive.instances[ ractive._guid ] += 1;\n\tarray._ractive.wrappers.push( this );\n};\n\nArrayWrapper.prototype = {\n\tget: function () {\n\t\treturn this.value;\n\t},\n\tteardown: function () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n};\n\nerrorMessage = 'Something went wrong in a rather interesting way';\nexport default arrayAdaptor;\n","import runloop from 'global/runloop';\nimport createBranch from 'utils/createBranch';\nimport { getKeypath } from 'shared/keypaths';\nimport { isArray } from 'utils/is';\n\nvar magicAdaptor, MagicWrapper;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tmagicAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\tvar parentWrapper, parentValue;\n\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tkeypath = getKeypath( keypath );\n\n\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t// we shouldn't wrap this property\n\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ keypath.parent.str ] ) && !parentWrapper.magic ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparentValue = ractive.viewmodel.get( keypath.parent );\n\n\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( keypath.lastKey ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) );\n\t\t},\n\t\twrap: function ( ractive, property, keypath ) {\n\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t}\n\t};\n\n\tMagicWrapper = function ( ractive, value, keypath ) {\n\t\tvar objKeypath, template, siblings;\n\n\t\tkeypath = getKeypath( keypath );\n\n\t\tthis.magic = true;\n\n\t\tthis.ractive = ractive;\n\t\tthis.keypath = keypath;\n\t\tthis.value = value;\n\n\t\tthis.prop = keypath.lastKey;\n\n\t\tobjKeypath = keypath.parent;\n\t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get( objKeypath );\n\n\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\n\t\t// Has this property already been wrapped?\n\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\tsiblings.push( this );\n\t\t\t}\n\n\t\t\treturn; // already wrapped\n\t\t}\n\n\t\t// No, it hasn't been wrapped\n\t\tcreateAccessors( this, value, template );\n\t};\n\n\tMagicWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\treset: function ( value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updating = true;\n\t\t\tthis.obj[ this.prop ] = value; // trigger set() accessor\n\t\t\trunloop.addRactive( this.ractive );\n\t\t\tthis.ractive.viewmodel.mark( this.keypath, { keepExistingWrapper: true } );\n\t\t\tthis.updating = false;\n\t\t\treturn true;\n\t\t},\n\t\tset: function ( key, value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\n\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tvar template, set, value, wrappers, index;\n\n\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t// so that it doesn't get torn down\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\tset = template && template.set;\n\n\t\t\tif ( !set ) {\n\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twrappers = set._ractiveWrappers;\n\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t}\n\n\t\t\t// Last one out, turn off the lights\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tvalue = this.obj[ this.prop ];\n\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t}\n\t\t}\n\t};\n} catch ( err ) {\n\tmagicAdaptor = false; // no magic in this browser\n}\n\nexport default magicAdaptor;\n\nfunction createAccessors ( originalWrapper, value, template ) {\n\n\tvar object, property, oldGet, oldSet, get, set;\n\n\tobject = originalWrapper.obj;\n\tproperty = originalWrapper.prop;\n\n\t// Is this template configurable?\n\tif ( template && !template.configurable ) {\n\t\t// Special case - array length\n\t\tif ( property === 'length' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t}\n\n\n\t// Time to wrap this property\n\tif ( template ) {\n\t\toldGet = template.get;\n\t\toldSet = template.set;\n\t}\n\n\tget = oldGet || function () {\n\t\treturn value;\n\t};\n\n\tset = function ( v ) {\n\t\tif ( oldSet ) {\n\t\t\toldSet( v );\n\t\t}\n\n\t\tvalue = oldGet ? oldGet() : v;\n\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t};\n\n\tfunction updateWrapper ( wrapper ) {\n\t\tvar keypath, ractive;\n\n\t\twrapper.value = value;\n\n\t\tif ( wrapper.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tractive = wrapper.ractive;\n\t\tkeypath = wrapper.keypath;\n\n\t\twrapper.updating = true;\n\t\trunloop.start( ractive );\n\n\t\tractive.viewmodel.mark( keypath );\n\n\t\trunloop.end();\n\t\twrapper.updating = false;\n\t}\n\n\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\tset._ractiveWrappers = [ originalWrapper ];\n\tObject.defineProperty( object, property, { get: get, set: set, enumerable: true, configurable: true });\n}\n","var numeric = /^\\s*[0-9]+\\s*$/;\n\nexport default function ( key ) {\n\treturn numeric.test( key ) ? [] : {};\n}\n","import magicAdaptor from './magic';\nimport arrayAdaptor from './array/index';\n\nvar magicArrayAdaptor, MagicArrayWrapper;\n\nif ( magicAdaptor ) {\n\tmagicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tMagicArrayWrapper = function ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t};\n\n\tMagicArrayWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t},\n\t\treset: function ( value ) {\n\t\t\treturn this.magicWrapper.reset( value );\n\t\t}\n\t};\n}\n\nexport default magicArrayAdaptor;\n","var prefixers = {};\n\nexport default function Viewmodel$adapt ( keypath, value ) {\n\tvar len, i, adaptor, wrapped;\n\n\tif ( !this.adaptors ) return;\n\n\t// Do we have an adaptor for this value?\n\tlen = this.adaptors.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tadaptor = this.adaptors[i];\n\n\t\tif ( adaptor.filter( value, keypath, this.ractive ) ) {\n\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( this.ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\twrapped.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nfunction prefixKeypath ( obj, prefix ) {\n\tvar prefixed = {}, key;\n\n\tif ( !prefix ) {\n\t\treturn obj;\n\t}\n\n\tprefix += '.';\n\n\tfor ( key in obj ) {\n\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn prefixed;\n}\n\nfunction getPrefixer ( rootKeypath ) {\n\tvar rootDot;\n\n\tif ( !prefixers[ rootKeypath ] ) {\n\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\tvar obj;\n\n\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t}\n\t\t};\n\t}\n\n\treturn prefixers[ rootKeypath ];\n}\n","export default notifyPatternObservers;\n\nfunction notifyPatternObservers ( viewmodel, keypath, onlyDirect ) {\n\tvar potentialWildcardMatches;\n\n\tupdateMatchingPatternObservers( viewmodel, keypath );\n\n\tif ( onlyDirect ) {\n\t\treturn;\n\t}\n\n\tpotentialWildcardMatches = keypath.wildcardMatches();\n\tpotentialWildcardMatches.forEach( upstreamPattern => {\n\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t});\n}\n\n\nfunction cascade ( viewmodel, upstreamPattern, keypath ) {\n\tvar group, map, actualChildKeypath;\n\n\t// TODO should be one or the other\n\tupstreamPattern = ( upstreamPattern.str || upstreamPattern );\n\n\tgroup = viewmodel.depsMap.patternObservers;\n\tmap = group && group[ upstreamPattern ];\n\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\tmap.forEach( childKeypath => {\n\t\tactualChildKeypath = keypath.join( childKeypath.lastKey ); // 'foo.bar.baz'\n\n\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t});\n}\n\nfunction updateMatchingPatternObservers ( viewmodel, keypath ) {\n\tviewmodel.patternObservers.forEach( observer => {\n\t\tif ( observer.regex.test( keypath.str ) ) {\n\t\t\tobserver.update( keypath );\n\t\t}\n\t});\n}\n","export default function Viewmodel$capture () {\n\tthis.captureGroups.push([]);\n}\n","export default function Viewmodel$clearCache ( keypath, keepExistingWrapper ) {\n\tvar cacheMap, wrapper;\n\n\tif ( !keepExistingWrapper ) {\n\t\t// Is there a wrapped property at this keypath?\n\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t// Did we unwrap it?\n\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t// Is this right?\n\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache[ keypath ] = undefined;\n\n\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\twhile ( cacheMap.length ) {\n\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t}\n\t}\n}\n","var UnresolvedDependency = function ( computation, ref ) {\n\tthis.computation = computation;\n\tthis.viewmodel = computation.viewmodel;\n\tthis.ref = ref;\n\n\t// TODO this seems like a red flag!\n\tthis.root = this.viewmodel.ractive;\n\tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n};\n\nUnresolvedDependency.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.computation.softDeps.push( keypath );\n\t\tthis.computation.unresolvedDeps[ keypath.str ] = null;\n\t\tthis.viewmodel.register( keypath, this.computation, 'computed' );\n\t}\n};\n\nexport default UnresolvedDependency;","import runloop from 'global/runloop';\nimport { logIfDebug, warnIfDebug, warnOnce } from 'utils/log';\nimport { isEqual } from 'utils/is';\nimport UnresolvedDependency from './UnresolvedDependency';\n\nvar Computation = function ( key, signature ) {\n\tthis.key = key;\n\n\tthis.getter = signature.getter;\n\tthis.setter = signature.setter;\n\n\tthis.hardDeps = signature.deps || [];\n\tthis.softDeps = [];\n\tthis.unresolvedDeps = {};\n\n\tthis.depValues = {};\n\n\tthis._dirty = this._firstRun = true;\n};\n\nComputation.prototype = {\n\tconstructor: Computation,\n\n\tinit ( viewmodel ) {\n\t\tvar initial;\n\n\t\tthis.viewmodel = viewmodel;\n\t\tthis.bypass = true;\n\n\t\tinitial = viewmodel.get( this.key );\n\t\tviewmodel.clearCache( this.key.str );\n\n\t\tthis.bypass = false;\n\n\t\tif ( this.setter && initial !== undefined ) {\n\t\t\tthis.set( initial );\n\t\t}\n\n\t\tif ( this.hardDeps ) {\n\t\t\tthis.hardDeps.forEach( d => viewmodel.register( d, this, 'computed' ) );\n\t\t}\n\t},\n\n\tinvalidate () {\n\t\tthis._dirty = true;\n\t},\n\n\tget () {\n\t\tvar newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\n\t\tif ( this.getting ) {\n\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\tlet msg = `The ${this.key.str} computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by \\`array.sort(...)\\` - if that\\'s the case, clone the array first with \\`array.slice().sort(...)\\``;\n\t\t\twarnOnce( msg );\n\t\t\treturn this.value;\n\t\t}\n\n\t\tthis.getting = true;\n\n\t\tif ( this._dirty ) {\n\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t// other computed values\n\t\t\tif ( this._firstRun || ( !this.hardDeps.length && !this.softDeps.length ) ) {\n\t\t\t\tdependencyValuesChanged = true;\n\t\t\t} else {\n\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\tvar keypath, value, i;\n\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ti = deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = deps[i];\n\t\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\n\t\t\t\t\t\tif ( !isEqual( value, this.depValues[ keypath.str ] ) ) {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = value;\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\tthis.viewmodel.capture();\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.value = this.getter();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( 'Failed to compute \"%s\"', this.key.str );\n\t\t\t\t\tlogIfDebug( err.stack || err );\n\n\t\t\t\t\tthis.value = void 0;\n\t\t\t\t}\n\n\t\t\t\tnewDeps = this.viewmodel.release();\n\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\t\tdeps.forEach( keypath => {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = this.viewmodel.get( keypath );\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tthis.getting = this._firstRun = false;\n\t\treturn this.value;\n\t},\n\n\tset ( value ) {\n\t\tif ( this.setting ) {\n\t\t\tthis.value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.setter ) {\n\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t}\n\n\t\tthis.setter( value );\n\t},\n\n\tupdateDependencies ( newDeps ) {\n\t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n\t\toldDeps = this.softDeps;\n\n\t\t// remove dependencies that are no longer used\n\t\ti = oldDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = oldDeps[i];\n\n\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\tdependenciesChanged = true;\n\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t}\n\t\t}\n\n\t\t// create references for any new dependencies\n\t\ti = newDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = newDeps[i];\n\n\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\tdependenciesChanged = true;\n\n\t\t\t\t// if this keypath is currently unresolved, we need to mark\n\t\t\t\t// it as such. TODO this is a bit muddy...\n\t\t\t\tif ( isUnresolved( this.viewmodel, keypath ) && ( !this.unresolvedDeps[ keypath.str ] ) ) {\n\t\t\t\t\tunresolved = new UnresolvedDependency( this, keypath.str );\n\t\t\t\t\tnewDeps.splice( i, 1 );\n\n\t\t\t\t\tthis.unresolvedDeps[ keypath.str ] = unresolved;\n\t\t\t\t\trunloop.addUnresolved( unresolved );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dependenciesChanged ) {\n\t\t\tthis.softDeps = newDeps.slice();\n\t\t}\n\n\t\treturn dependenciesChanged;\n\t}\n};\n\nfunction isUnresolved( viewmodel, keypath ) {\n\tvar key = keypath.firstKey;\n\n\treturn !( key in viewmodel.data ) &&\n\t       !( key in viewmodel.computations ) &&\n\t       !( key in viewmodel.mappings );\n}\n\nexport default Computation;\n","import { lastItem } from 'utils/array';\nimport { hasOwn } from 'utils/object';\nimport FAILED_LOOKUP from './get/FAILED_LOOKUP';\n\nvar empty = {};\n\nexport default function Viewmodel$get ( keypath, options ) {\n\tvar cache = this.cache,\n\t\tvalue,\n\t\tcomputation,\n\t\twrapped,\n\t\tcaptureGroup,\n\t\tkeypathStr = keypath.str,\n\t\tkey;\n\n\toptions = options || empty;\n\n\t// capture the keypath, if we're inside a computation\n\tif ( options.capture && ( captureGroup = lastItem( this.captureGroups ) ) ) {\n\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\tcaptureGroup.push( keypath );\n\t\t}\n\t}\n\n\tif ( hasOwn.call( this.mappings, keypath.firstKey ) ) {\n\t\treturn this.mappings[ keypath.firstKey ].get( keypath, options );\n\t}\n\n\tif ( keypath.isSpecial ) {\n\t\treturn keypath.value;\n\t}\n\n\tif ( cache[ keypathStr ] === undefined ) {\n\n\t\t// Is this a computed property?\n\t\tif ( ( computation = this.computations[ keypathStr ] ) && !computation.bypass ) {\n\t\t\tvalue = computation.get();\n\t\t\tthis.adapt( keypathStr, value );\n\t\t}\n\n\t\t// Is this a wrapped property?\n\t\telse if ( wrapped = this.wrapped[ keypathStr ] ) {\n\t\t\tvalue = wrapped.value;\n\t\t}\n\n\t\t// Is it the root?\n\t\telse if ( keypath.isRoot ) {\n\t\t\tthis.adapt( '', this.data );\n\t\t\tvalue = this.data;\n\t\t}\n\n\t\t// No? Then we need to retrieve the value one key at a time\n\t\telse {\n\t\t\tvalue = retrieve( this, keypath );\n\t\t}\n\n\t\tcache[ keypathStr ] = value;\n\t} else {\n\t\tvalue = cache[ keypathStr ];\n\t}\n\n\tif ( !options.noUnwrap && ( wrapped = this.wrapped[ keypathStr ] ) ) {\n\t\tvalue = wrapped.get();\n\t}\n\n\tif ( keypath.isRoot && options.fullRootGet ) {\n\t\tfor ( key in this.mappings ) {\n\t\t\tvalue[ key ] = this.mappings[ key ].getValue();\n\t\t}\n\t}\n\n\treturn value === FAILED_LOOKUP ? void 0 : value;\n}\n\nfunction retrieve ( viewmodel, keypath ) {\n\n\tvar parentValue, cacheMap, value, wrapped;\n\n\tparentValue = viewmodel.get( keypath.parent );\n\n\tif ( wrapped = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\tparentValue = wrapped.get();\n\t}\n\n\tif ( parentValue === null || parentValue === undefined ) {\n\t\treturn;\n\t}\n\n\t// update cache map\n\tif ( !( cacheMap = viewmodel.cacheMap[ keypath.parent.str ] ) ) {\n\t\tviewmodel.cacheMap[ keypath.parent.str ] = [ keypath.str ];\n\t} else {\n\t\tif ( cacheMap.indexOf( keypath.str ) === -1 ) {\n\t\t\tcacheMap.push( keypath.str );\n\t\t}\n\t}\n\n\t// If this property doesn't exist, we return a sentinel value\n\t// so that we know to query parent scope (if such there be)\n\tif ( typeof parentValue === 'object' && !( keypath.lastKey in parentValue ) ) {\n\t\treturn viewmodel.cache[ keypath.str ] = FAILED_LOOKUP;\n\t}\n\n\tvalue = parentValue[ keypath.lastKey ];\n\n\t// Do we have an adaptor for this value?\n\tviewmodel.adapt( keypath.str, value, false );\n\n\t// Update cache\n\tviewmodel.cache[ keypath.str ] = value;\n\treturn value;\n}\n","export default function Viewmodel$init () {\n\tvar key;\n\n\tfor ( key in this.computations ) {\n\t\tthis.computations[ key ].init( this );\n\t}\n}","export default function Viewmodel$map ( key, options ) {\n\tvar mapping = this.mappings[ key.str ] = new Mapping( key, options );\n\tmapping.initViewmodel( this );\n\treturn mapping;\n}\n\nvar Mapping = function ( localKey, options ) {\n\tthis.localKey = localKey;\n\tthis.keypath = options.keypath;\n\tthis.origin = options.origin;\n\n\tthis.deps = [];\n\tthis.unresolved = [];\n\n\tthis.resolved = false;\n};\n\nMapping.prototype = {\n\tforceResolution () {\n\t\t// TODO warn, as per #1692?\n\t\tthis.keypath = this.localKey;\n\t\tthis.setup();\n\t},\n\n\tget ( keypath, options ) {\n\t\tif ( !this.resolved ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.map( keypath ), options );\n\t},\n\n\tgetValue () {\n\t\tif ( !this.keypath ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.keypath );\n\t},\n\n\tinitViewmodel ( viewmodel ) {\n\t\tthis.local = viewmodel;\n\t\tthis.setup();\n\t},\n\n\tmap ( keypath ) {\n    \t\tif( typeof this.keypath === undefined ) {\n    \t\t\treturn this.localKey;\n    \t\t}\n    \t\treturn keypath.replace( this.localKey, this.keypath );\n\t},\n\n\tregister ( keypath, dependant, group ) {\n\t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n\t\tif ( this.resolved ) {\n\t\t\tthis.origin.register( this.map( keypath ), dependant, group );\n\t\t}\n\t},\n\n\tresolve ( keypath ) {\n\t\tif ( this.keypath !== undefined ) {\n\t\t\tthis.unbind( true );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.setup();\n\t},\n\n\tset ( keypath, value ) {\n\t\tif ( !this.resolved ) {\n\t\t\tthis.forceResolution();\n\t\t}\n\n\t\tthis.origin.set( this.map( keypath ), value );\n\t},\n\n\tsetup () {\n\t\tif ( this.keypath === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\t// accumulated dependants can now be registered\n\t\tif ( this.deps.length ) {\n\t\t\tthis.deps.forEach( d => {\n\t\t\t\tvar keypath = this.map( d.keypath );\n\t\t\t\tthis.origin.register( keypath, d.dep, d.group );\n\n\t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n\t\t\t\tif ( d.dep.setValue ) {\n\t\t\t\t\td.dep.setValue( this.origin.get( keypath ) );\n\t\t\t\t} else if ( d.dep.invalidate ) {\n\t\t\t\t\td.dep.invalidate();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.origin.mark( this.keypath );\n\t\t}\n\t},\n\n\tsetValue ( value ) {\n\t\tif ( !this.keypath ) {\n\t\t\tthrow new Error( 'Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t}\n\n\t\tthis.origin.set( this.keypath, value );\n\t},\n\n\tunbind ( keepLocal ) {\n\t\tif ( !keepLocal ) {\n\t\t\tdelete this.local.mappings[ this.localKey ];\n\t\t}\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deps.forEach( d => {\n\t\t\tthis.origin.unregister( this.map( d.keypath ), d.dep, d.group );\n\t\t});\n\n\t\tif ( this.tracker ) {\n\t\t\tthis.origin.unregister( this.keypath, this.tracker );\n\t\t}\n\t},\n\n\tunregister ( keypath, dependant, group ) {\n\t\tvar deps, i;\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeps = this.deps;\n\t\ti = deps.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( deps[i].dep === dependant ) {\n\t\t\t\tdeps.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.origin.unregister( this.map( keypath ), dependant, group );\n\t}\n};\n","export default function Viewmodel$mark ( keypath, options ) {\n\tvar computation, keypathStr = keypath.str;\n\n\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t// should not be picked up by pattern observers\n\tif ( options ) {\n\t\tif ( options.implicit ) {\n\t\t\tthis.implicitChanges[ keypathStr ] = true;\n\t\t}\n\t\tif ( options.noCascade ) {\n\t\t\tthis.noCascade[ keypathStr ] = true;\n\t\t}\n\t}\n\n\tif ( computation = this.computations[ keypathStr ] ) {\n\t\tcomputation.invalidate();\n\t}\n\n\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\tthis.changes.push( keypath );\n\t}\n\n\t// pass on keepExistingWrapper, if we can\n\tlet keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n\tthis.clearCache( keypathStr, keepExistingWrapper );\n\n\tif ( this.ready ) {\n\t\tthis.onchange();\n\t}\n}\n","export default function ( oldArray, newArray ) {\n\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n\tusedIndices = {};\n\tfirstUnusedIndex = 0;\n\n\tnewIndices = oldArray.map( function ( item, i ) {\n\t\tvar index, start, len;\n\n\t\tstart = firstUnusedIndex;\n\t\tlen = newArray.length;\n\n\t\tdo {\n\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\tif ( index === -1 ) {\n\t\t\t\tchanged = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstart = index + 1;\n\t\t} while ( usedIndices[ index ] && start < len );\n\n\t\t// keep track of the first unused index, so we don't search\n\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\tif ( index === firstUnusedIndex ) {\n\t\t\tfirstUnusedIndex += 1;\n\t\t}\n\n\t\tif ( index !== i ) {\n\t\t\tchanged = true;\n\t\t}\n\n\t\tusedIndices[ index ] = true;\n\t\treturn index;\n\t});\n\n\treturn newIndices;\n}\n","import { warnIfDebug } from 'utils/log';\nimport mapOldToNewIndex from './merge/mapOldToNewIndex';\n\nvar comparators = {};\n\nexport default function Viewmodel$merge ( keypath, currentArray, array, options ) {\n\tvar oldArray,\n\t\tnewArray,\n\t\tcomparator,\n\t\tnewIndices;\n\n\tthis.mark( keypath );\n\n\tif ( options && options.compare ) {\n\n\t\tcomparator = getComparatorFunction( options.compare );\n\n\t\ttry {\n\t\t\toldArray = currentArray.map( comparator );\n\t\t\tnewArray = array.map( comparator );\n\t\t} catch ( err ) {\n\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t// to do more DOM manipulation than we thought...\n\t\t\twarnIfDebug( 'merge(): \"%s\" comparison failed. Falling back to identity checking', keypath );\n\n\t\t\toldArray = currentArray;\n\t\t\tnewArray = array;\n\t\t}\n\n\t} else {\n\t\toldArray = currentArray;\n\t\tnewArray = array;\n\t}\n\n\t// find new indices for members of oldArray\n\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\n\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n}\n\nfunction stringify ( item ) {\n\treturn JSON.stringify( item );\n}\n\nfunction getComparatorFunction ( comparator ) {\n\t// If `compare` is `true`, we use JSON.stringify to compare\n\t// objects that are the same shape, but non-identical - i.e.\n\t// { foo: 'bar' } !== { foo: 'bar' }\n\tif ( comparator === true ) {\n\t\treturn stringify;\n\t}\n\n\tif ( typeof comparator === 'string' ) {\n\t\tif ( !comparators[ comparator ] ) {\n\t\t\tcomparators[ comparator ] = function ( item ) {\n\t\t\t\treturn item[ comparator ];\n\t\t\t};\n\t\t}\n\n\t\treturn comparators[ comparator ];\n\t}\n\n\tif ( typeof comparator === 'function' ) {\n\t\treturn comparator;\n\t}\n\n\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n}\n","export default function Viewmodel$register ( keypath, dependant, group = 'default' ) {\n\tvar mapping, depsByKeypath, deps;\n\n\tif ( dependant.isStatic ) {\n\t\treturn; // TODO we should never get here if a dependant is static...\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\tmapping.register( keypath, dependant, group );\n\t}\n\n\telse {\n\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\tdeps = depsByKeypath[ keypath.str ] || ( depsByKeypath[ keypath.str ] = [] );\n\n\t\tdeps.push( dependant );\n\n\t\tif ( !this.depsMap[ group ] ) {\n\t\t\tthis.depsMap[ group ] = {};\n\t\t}\n\n\t\tif ( !keypath.isRoot ) {\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t}\n\t}\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent, keypathStr;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ] || ( map[ keypath.parent.str ] = [] );\n\n\t\tkeypathStr = keypath.str;\n\n\t\t// TODO find an alternative to this nasty approach\n\t\tif ( parent[ '_' + keypathStr ] === undefined ) {\n\t\t\tparent[ '_' + keypathStr ] = 0;\n\t\t\tparent.push( keypath );\n\t\t}\n\n\t\tparent[ '_' + keypathStr ] += 1;\n\t\tkeypath = keypath.parent;\n\t}\n}\n","export default function Viewmodel$release () {\n\treturn this.captureGroups.pop();\n}\n","export default function Viewmodel$reset ( data ) {\n\tthis.data = data;\n\tthis.clearCache( '' );\n}","var implicitOption = { implicit: true }, noCascadeOption = { noCascade: true };\n\nexport default function Viewmodel$smartUpdate ( keypath, array, newIndices ) {\n\tvar dependants, oldLength, i;\n\n\toldLength = newIndices.length;\n\n\t// Indices that are being removed should be marked as dirty\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.mark( keypath.join( oldIndex ), noCascadeOption );\n\t\t}\n\t});\n\n\t// Update the model\n\t// TODO allow existing array to be updated in place, rather than replaced?\n\tthis.set( keypath, array, { silent: true } );\n\n\tif ( dependants = this.deps[ 'default' ][ keypath.str ] ) {\n\t\tdependants.filter( canShuffle ).forEach( d => d.shuffle( newIndices, array ) );\n\t}\n\n\tif ( oldLength !== array.length ) {\n\t\tthis.mark( keypath.join( 'length' ), implicitOption );\n\n\t\tfor ( i = newIndices.touchedFrom; i < array.length; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ) );\n\t\t}\n\n\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t// TODO is this still necessary, now that computations are lazy?\n\t\tfor ( i = array.length; i < oldLength; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ), noCascadeOption );\n\t\t}\n\t}\n}\n\nfunction canShuffle ( dependant ) {\n\treturn typeof dependant.shuffle === 'function';\n}\n","export default function Viewmodel$teardown () {\n\tvar unresolvedImplicitDependency;\n\n\t// Clear entire cache - this has the desired side-effect\n\t// of unwrapping adapted values (e.g. arrays)\n\tObject.keys( this.cache ).forEach( keypath => this.clearCache( keypath ) );\n\n\t// Teardown any failed lookups - we don't need them to resolve any more\n\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\tunresolvedImplicitDependency.teardown();\n\t}\n}\n","import { fatal } from 'utils/log';\nimport { getKeypath } from 'shared/keypaths';\nimport { create } from 'utils/object';\nimport adapt from './prototype/adapt';\nimport applyChanges from './prototype/applyChanges';\nimport capture from './prototype/capture';\nimport clearCache from './prototype/clearCache';\nimport compute from './prototype/compute';\nimport get from './prototype/get';\nimport init from './prototype/init';\nimport map from './prototype/map';\nimport mark from './prototype/mark';\nimport merge from './prototype/merge';\nimport register from './prototype/register';\nimport release from './prototype/release';\nimport reset from './prototype/reset';\nimport set from './prototype/set';\nimport smartUpdate from './prototype/smartUpdate';\nimport teardown from './prototype/teardown';\nimport unregister from './prototype/unregister';\n\nvar Viewmodel = function ( options ) {\n\tvar { adapt, data, ractive, computed, mappings } = options,\n\t\tkey,\n\t\tmapping;\n\n\t// TODO is it possible to remove this reference?\n\tthis.ractive = ractive;\n\n\tthis.adaptors = adapt;\n\tthis.onchange = options.onchange;\n\n\tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n\tthis.cacheMap = create( null );\n\n\tthis.deps = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\tthis.depsMap = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\n\tthis.patternObservers = [];\n\n\tthis.specials = create( null );\n\n\tthis.wrapped = create( null );\n\tthis.computations = create( null );\n\n\tthis.captureGroups = [];\n\tthis.unresolvedImplicitDependencies = [];\n\n\tthis.changes = [];\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\tthis.data = data;\n\n\t// set up explicit mappings\n\tthis.mappings = create( null );\n\tfor ( key in mappings ) {\n\t\tthis.map( getKeypath( key ), mappings[ key ] );\n\t}\n\n\tif ( data ) {\n\t\t// if data exists locally, but is missing on the parent,\n\t\t// we transfer ownership to the parent\n\t\tfor ( key in data ) {\n\t\t\tif ( ( mapping = this.mappings[ key ] ) && mapping.getValue() === undefined ) {\n\t\t\t\tmapping.setValue( data[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( key in computed ) {\n\t\tif ( mappings && key in mappings ) {\n\t\t\tfatal( 'Cannot map to a computed property (\\'%s\\')', key );\n\t\t}\n\n\t\tthis.compute( getKeypath( key ), computed[ key ] );\n\t}\n\n\tthis.ready = true;\n};\n\nViewmodel.prototype = {\n\tadapt: adapt,\n\tapplyChanges: applyChanges,\n\tcapture: capture,\n\tclearCache: clearCache,\n\tcompute: compute,\n\tget: get,\n\tinit: init,\n\tmap: map,\n\tmark: mark,\n\tmerge: merge,\n\tregister: register,\n\trelease: release,\n\treset: reset,\n\tset: set,\n\tsmartUpdate: smartUpdate,\n\tteardown: teardown,\n\tunregister: unregister\n};\n\nexport default Viewmodel;\n","import Hook from './Hook';\n\nfunction HookQueue ( event ) {\n\tthis.hook = new Hook( event );\n\tthis.inProcess = {};\n\tthis.queue = {};\n}\n\nHookQueue.prototype = {\n\n\tconstructor: HookQueue,\n\n\tbegin: function ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t},\n\n\tend: function ( ractive ) {\n\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t}\n};\n\nfunction getChildQueue ( queue, ractive ) {\n\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n}\n\nfunction fire ( hookQueue, ractive ) {\n\n\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\thookQueue.hook.fire( ractive );\n\n\t// queue is \"live\" because components can end up being\n\t// added while hooks fire on parents that modify data values.\n\twhile ( childQueue.length ) {\n\t\tfire( hookQueue, childQueue.shift() );\n\t}\n\n\tdelete hookQueue.queue[ ractive._guid ];\n}\n\n\nexport default HookQueue;\n","import { fatal } from 'utils/log';\n\nvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\nexport default function getComputationSignatures ( ractive, computed ) {\n\tvar signatures = {}, key;\n\n\tfor ( key in computed ) {\n\t\tsignatures[ key ] = getComputationSignature( ractive, key, computed[ key ] );\n\t}\n\n\treturn signatures;\n}\n\nfunction getComputationSignature ( ractive, key, signature ) {\n\tvar getter, setter;\n\n\tif ( typeof signature === 'function' ) {\n\t\tgetter = bind( signature, ractive );\n\t}\n\n\tif ( typeof signature === 'string' ) {\n\t\tgetter = createFunctionFromString( ractive, signature );\n\t}\n\n\tif ( typeof signature === 'object' ) {\n\t\tif ( typeof signature.get === 'string' ) {\n\t\t\tgetter = createFunctionFromString( ractive, signature.get );\n\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\tgetter = bind( signature.get, ractive );\n\t\t} else {\n\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t}\n\n\t\tif ( typeof signature.set === 'function' ) {\n\t\t\tsetter = bind( signature.set, ractive );\n\t\t}\n\t}\n\n\treturn { getter: getter, setter: setter };\n}\n\nfunction createFunctionFromString ( ractive, str ) {\n\tvar functionBody, hasThis, fn;\n\n\tfunctionBody = 'return (' + str.replace( pattern, ( match, keypath ) => {\n\t\thasThis = true;\n\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t}) + ');';\n\n\tif ( hasThis ) {\n\t\tfunctionBody = 'var __ractive = this; ' + functionBody;\n\t}\n\n\tfn = new Function( functionBody );\n\treturn hasThis ? fn.bind( ractive ) : fn;\n}\n\nfunction bind ( fn, context ) {\n\treturn /this/.test( fn.toString() ) ? fn.bind( context ) : fn;\n}","import { fatal, logIfDebug, warnIfDebug, warnOnceIfDebug, welcome } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport { magic as magicSupported } from 'config/environment';\nimport { ensureArray } from 'utils/array';\nimport { findInViewHierarchy } from 'shared/registry';\nimport arrayAdaptor from 'Ractive/static/adaptors/array/index';\nimport magicAdaptor from 'Ractive/static/adaptors/magic';\nimport magicArrayAdaptor from 'Ractive/static/adaptors/magicArray';\nimport { getElement } from 'utils/dom';\nimport { create, defineProperty, extend } from 'utils/object';\nimport runloop from 'global/runloop';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport Fragment from 'virtualdom/Fragment';\nimport Viewmodel from 'viewmodel/Viewmodel';\nimport Hook from './prototype/shared/hooks/Hook';\nimport HookQueue from './prototype/shared/hooks/HookQueue';\nimport getComputationSignatures from './helpers/getComputationSignatures';\nimport Ractive from '../Ractive';\n\nlet constructHook = new Hook( 'construct' );\nlet configHook = new Hook( 'config' );\nlet initHook = new HookQueue( 'init' );\nlet uid = 0;\n\nlet registryNames = [\n\t'adaptors',\n\t'components',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nexport default initialiseRactiveInstance;\n\nfunction initialiseRactiveInstance ( ractive, userOptions = {}, options = {} ) {\n\tvar el, viewmodel;\n\n\tif ( Ractive.DEBUG ) {\n\t\twelcome();\n\t}\n\n\tinitialiseProperties( ractive, options );\n\n\t// TODO remove this, eventually\n\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\tconstructHook.fire( ractive, userOptions );\n\n\t// Add registries\n\tregistryNames.forEach( name => {\n\t\tractive[ name ] = extend( create( ractive.constructor[ name ] || null ), userOptions[ name ] );\n\t});\n\n\t// Create a viewmodel\n\tviewmodel = new Viewmodel({\n\t\tadapt: getAdaptors( ractive, ractive.adapt, userOptions ),\n\t\tdata: dataConfigurator.init( ractive.constructor, ractive, userOptions ),\n\t\tcomputed: getComputationSignatures( ractive, extend( create( ractive.constructor.prototype.computed ), userOptions.computed ) ),\n\t\tmappings: options.mappings,\n\t\tractive: ractive,\n\t\tonchange: () => runloop.addRactive( ractive )\n\t});\n\n\tractive.viewmodel = viewmodel;\n\n\t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n\tviewmodel.init();\n\n\t// init config from Parent and options\n\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\tconfigHook.fire( ractive );\n\tinitHook.begin( ractive );\n\n\t// // If this is a component with a function `data` property, call the function\n\t// // with `ractive` as context (unless the child was also a function)\n\t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n\t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n\t// }\n\n\n\t// Render virtual DOM\n\tif ( ractive.template ) {\n\t\tlet cssIds;\n\n\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n\t\t\tif ( ractive.cssId ) {\n\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t}\n\t\t}\n\n\t\tractive.fragment = new Fragment({\n\t\t\ttemplate: ractive.template,\n\t\t\troot: ractive,\n\t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n\t\t\tcssIds\n\t\t});\n\t}\n\n\tinitHook.end( ractive );\n\n\t// render automatically ( if `el` is specified )\n\tif ( el = getElement( ractive.el ) ) {\n\t\tlet promise = ractive.render( el, ractive.append );\n\n\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\tpromise.catch( err => {\n\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive });\n\t\t\t\terr.stack && logIfDebug( err.stack );\n\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction getAdaptors ( ractive, protoAdapt, userOptions ) {\n\tvar adapt, magic, modifyArrays;\n\n\tprotoAdapt = protoAdapt.map( lookup );\n\tadapt = ensureArray( userOptions.adapt ).map( lookup );\n\n\tadapt = combine( protoAdapt, adapt );\n\n\tmagic = 'magic' in userOptions ? userOptions.magic : ractive.magic;\n\tmodifyArrays = 'modifyArrays' in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n\tif ( magic ) {\n\t\tif ( !magicSupported ) {\n\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t}\n\n\t\tif ( modifyArrays ) {\n\t\t\tadapt.push( magicArrayAdaptor );\n\t\t}\n\n\t\tadapt.push( magicAdaptor );\n\t}\n\n\tif ( modifyArrays ) {\n\t\tadapt.push( arrayAdaptor );\n\t}\n\n\treturn adapt;\n\n\n\tfunction lookup ( adaptor ) {\n\t\tif ( typeof adaptor === 'string' ) {\n\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\tif ( !adaptor ) {\n\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t}\n\t\t}\n\n\t\treturn adaptor;\n\t}\n}\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}\n\nfunction initialiseProperties ( ractive, options ) {\n\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t// existed\n\tractive._guid = 'r-' + uid++;\n\n\t// events\n\tractive._subs = create( null );\n\n\t// storage for item configuration from instantiation to reset,\n\t// like dynamic functions or original values\n\tractive._config = {};\n\n\t// two-way bindings\n\tractive._twowayBindings = create( null );\n\n\t// animations (so we can stop any in progress at teardown)\n\tractive._animations = [];\n\n\t// nodes registry\n\tractive.nodes = {};\n\n\t// live queries\n\tractive._liveQueries = [];\n\tractive._liveComponentQueries = [];\n\n\t// bound data functions\n\tractive._boundFunctions = [];\n\n\t// observers\n\tractive._observers = [];\n\n\n\t// properties specific to inline components\n\tif ( options.component ) {\n\t\tractive.parent = options.parent;\n\t\tractive.container = options.container || null;\n\t\tractive.root = ractive.parent.root;\n\n\t\tractive.component = options.component;\n\t\toptions.component.instance = ractive;\n\n\t\t// for hackability, this could be an open option\n\t\t// for any ractive instance, but for now, just\n\t\t// for components and just for ractive...\n\t\tractive._inlinePartials = options.inlinePartials;\n\t} else {\n\t\tractive.root = ractive;\n\t\tractive.parent = ractive.container = null;\n\t}\n}\n\nfunction deprecateRactiveData () {\n\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n}\n","import runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nfunction ComplexParameter ( component, template, callback ) {\n\tthis.parentFragment = component.parentFragment;\n\tthis.callback = callback;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: template,\n\t\troot:     component.root,\n\t\towner:    this\n\t});\n\n\tthis.update();\n}\n\nexport default ComplexParameter;\n\nComplexParameter.prototype = {\n\tbubble: function () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\tthis.callback( this.fragment.getValue() );\n\t\tthis.dirty = false;\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t}\n};\n\n","import { INTERPOLATOR, YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport parseJSON from 'utils/parseJSON';\nimport initialise from 'Ractive/initialise';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\nimport ReferenceExpressionResolver from 'virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ComplexParameter from './ComplexParameter';\n\nexport default function ( component, Component, attributes, yieldTemplate, partials ) {\n\tvar instance, parentFragment, ractive, fragment, container, inlinePartials = {}, data = {}, mappings = {}, ready, resolvers = [];\n\n\tparentFragment = component.parentFragment;\n\tractive = component.root;\n\n\tpartials = partials || {};\n\textend( inlinePartials, partials );\n\n\t// Make contents available as a {{>content}} partial\n\tpartials.content = yieldTemplate || [];\n\n\t// set a default partial for yields with no name\n\tinlinePartials[''] = partials.content;\n\n\tif ( Component.defaults.el ) {\n\t\twarnIfDebug( 'The <%s/> component has a default `el` property; it has been disregarded', component.name );\n\t}\n\n\t// find container\n\tfragment = parentFragment;\n\twhile ( fragment ) {\n\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\tcontainer = fragment.owner.container;\n\t\t\tbreak;\n\t\t}\n\n\t\tfragment = fragment.parent;\n\t}\n\n\t// each attribute represents either a) data or b) a mapping\n\tif ( attributes ) {\n\t\tObject.keys( attributes ).forEach( key => {\n\t\t\tvar attribute = attributes[ key ], parsed, resolver;\n\n\t\t\tif ( typeof attribute === 'string' ) {\n\t\t\t\t// it's static data\n\t\t\t\tparsed = parseJSON( attribute );\n\t\t\t\tdata[ key ] = parsed ? parsed.value : attribute;\n\t\t\t}\n\n\t\t\telse if ( attribute === 0 ) {\n\t\t\t\t// it had no '=', so we'll call it true\n\t\t\t\tdata[ key ] = true;\n\t\t\t}\n\n\t\t\telse if ( isArray( attribute ) ) {\n\t\t\t\t// this represents dynamic data\n\t\t\t\tif ( isSingleInterpolator( attribute ) ) {\n\t\t\t\t\tmappings[ key ] = {\n\t\t\t\t\t\torigin: component.root.viewmodel,\n\t\t\t\t\t\tkeypath: undefined\n\t\t\t\t\t};\n\n\t\t\t\t\tresolver = createResolver( component, attribute[0], function ( keypath ) {\n\t\t\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.set( key, keypath.value ); // TODO use viewmodel?\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[ key ] = keypath.value;\n\n\t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n\t\t\t\t\t\t\t\tdelete mappings[ key ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.viewmodel.mappings[ key ].resolve( keypath );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// resolved immediately\n\t\t\t\t\t\t\t\tmappings[ key ].keypath = keypath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresolver = new ComplexParameter( component, attribute, function ( value ) {\n\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\tinstance.set( key, value ); // TODO use viewmodel?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tresolvers.push( resolver );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow new Error( 'erm wut' );\n\t\t\t}\n\t\t});\n\t}\n\n\tinstance = create( Component.prototype );\n\n\tinitialise( instance, {\n\t\tel: null,\n\t\tappend: true,\n\t\tdata,\n\t\tpartials,\n\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\tmodifyArrays: ractive.modifyArrays,\n\t\t// need to inherit runtime parent adaptors\n\t\tadapt: ractive.adapt\n\t}, {\n\t\tparent: ractive,\n\t\tcomponent,\n\t\tcontainer,\n\t\tmappings,\n\t\tinlinePartials,\n\t\tcssIds: parentFragment.cssIds\n\t});\n\n\tready = true;\n\tcomponent.resolvers = resolvers;\n\n\treturn instance;\n}\n\nfunction createResolver ( component, template, callback ) {\n\tvar resolver;\n\n\tif ( template.r ) {\n\t\tresolver = createReferenceResolver( component, template.r, callback );\n\t}\n\n\telse if ( template.x ) {\n\t\tresolver = new ExpressionResolver( component, component.parentFragment, template.x, callback );\n\t}\n\n\telse if ( template.rx ) {\n\t\tresolver = new ReferenceExpressionResolver( component, template.rx, callback );\n\t}\n\n\treturn resolver;\n}\n\nfunction isSingleInterpolator( template ){\n\treturn template.length === 1 && template[0].t === INTERPOLATOR;\n}\n","export default function ( component ) {\n\tvar ancestor, query;\n\n\t// If there's a live query for this component type, add it\n\tancestor = component.root;\n\twhile ( ancestor ) {\n\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery.push( component.instance );\n\t\t}\n\n\t\tancestor = ancestor.parent;\n\t}\n}\n","export default function Component$rebind ( oldKeypath, newKeypath ) {\n\tvar query;\n\n\tthis.resolvers.forEach( rebind );\n\n\tfor ( let k in this.yielders ) {\n\t\tif ( this.yielders[k][0] ) {\n\t\t\trebind( this.yielders[k][0] );\n\t\t}\n\t}\n\n\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\tquery._makeDirty();\n\t}\n\n\tfunction rebind ( x ) {\n\t\tx.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function Component$render () {\n\tvar instance = this.instance;\n\n\tinstance.render( this.parentFragment.getNode() );\n\n\tthis.rendered = true;\n\treturn instance.fragment.detach();\n}\n","export default function Component$toString () {\n\treturn this.instance.fragment.toString();\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport { unbind, cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\nexport default function Component$unbind () {\n\tvar instance = this.instance;\n\n\tthis.resolvers.forEach( unbind );\n\n\tremoveFromLiveComponentQueries( this );\n\n\tinstance._observers.forEach( cancel );\n\n\t// teardown the instance\n\tinstance.fragment.unbind();\n\tinstance.viewmodel.teardown();\n\n\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t}\n\n\tteardownHook.fire( instance );\n}\n\nfunction removeFromLiveComponentQueries ( component ) {\n\tvar instance, query;\n\n\tinstance = component.root;\n\n\tdo {\n\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery._remove( component );\n\t\t}\n\t} while ( instance = instance.parent );\n}","export default function Component$unrender ( shouldDestroy ) {\n\tthis.shouldDestroy = shouldDestroy;\n\tthis.instance.unrender();\n}\n","import detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Component = function ( options, Constructor ) {\n\tthis.init( options, Constructor );\n};\n\nComponent.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Component;\n","import { COMMENT } from 'config/types';\nimport detach from './shared/detach';\n\nvar Comment = function ( options ) {\n\tthis.type = COMMENT;\n\tthis.value = options.template.c;\n};\n\nComment.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createComment( this.value );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString () {\n\t\treturn '<!--' + this.value + '-->';\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t}\n\t}\n};\n\nexport default Comment;\n","import { YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\nimport { isArray } from 'utils/is';\n\nvar Yielder = function ( options ) {\n\tvar container, component;\n\n\tthis.type = YIELDER;\n\n\tthis.container = container = options.parentFragment.root;\n\tthis.component = component = container.component;\n\n\tthis.container = container;\n\tthis.containerFragment = options.parentFragment;\n\tthis.parentFragment = component.parentFragment;\n\n\tlet name = this.name = options.template.n || '';\n\n\tlet template = container._inlinePartials[ name ];\n\n\tif ( !template ) {\n\t\twarnIfDebug( `Could not find template for partial \"${name}\"`, { ractive: options.root });\n\t\ttemplate = [];\n\t}\n\n\tthis.fragment = new Fragment({\n\t\towner: this,\n\t\troot: container.parent,\n\t\ttemplate,\n\t\tpElement: this.containerFragment.pElement\n\t});\n\n\t// even though only one yielder is allowed, we need to have an array of them\n\t// as it's possible to cause a yielder to be created before the last one\n\t// was destroyed in the same turn of the runloop\n\tif ( !isArray( component.yielders[ name ] ) ) {\n\t\tcomponent.yielders[ name ] = [ this ];\n\t} else {\n\t\tcomponent.yielders[ name ].push( this );\n\t}\n\n\trunloop.scheduleTask( () => {\n\t\tif ( component.yielders[ name ].length > 1 ) {\n\t\t\tthrow new Error( 'A component template can only have one {{yield' + (name ? ' ' + name : '') + '}} declaration at a time' );\n\t\t}\n\t});\n};\n\nYielder.prototype = {\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfindNextNode () {\n\t\treturn this.containerFragment.findNextNode( this );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tgetValue ( options ) {\n\t\treturn this.fragment.getValue( options );\n\t},\n\n\trender () {\n\t\treturn this.fragment.render();\n\t},\n\n\tunbind () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tthis.fragment.unrender( shouldDestroy );\n\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\ttoString () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default Yielder;\n","import noop from 'utils/noop';\n\nvar Doctype = function ( options ) {\n\tthis.declaration = options.template.a;\n};\n\nDoctype.prototype = {\n\tinit: noop,\n\trender: noop,\n\tunrender: noop,\n\tteardown: noop,\n\ttoString () {\n\t\treturn '<!DOCTYPE' + this.declaration + '>';\n\t}\n};\n\nexport default Doctype;","export default function Fragment$render () {\n\tvar result;\n\n\tif ( this.items.length === 1 ) {\n\t\tresult = this.items[0].render();\n\t} else {\n\t\tresult = document.createDocumentFragment();\n\n\t\tthis.items.forEach( item => {\n\t\t\tresult.appendChild( item.render() );\n\t\t});\n\t}\n\n\tthis.rendered = true;\n\treturn result;\n}\n","export default function Fragment$toString ( escape ) {\n\tif ( !this.items ) {\n\t\treturn '';\n\t}\n\n\treturn this.items.map( escape ? toEscapedString : toString ).join( '' );\n}\n\nfunction toString ( item ) {\n\treturn item.toString();\n}\n\nfunction toEscapedString ( item ) {\n\treturn item.toString( true );\n}","export default function Fragment$unbind () {\n\tif ( !this.bound ) {\n\t\treturn;\n\t}\n\n\tthis.items.forEach( unbindItem );\n\tthis.bound = false;\n}\n\nfunction unbindItem ( item ) {\n\tif ( item.unbind ) {\n\t\titem.unbind();\n\t}\n}\n","export default function Fragment$unrender ( shouldDestroy ) {\n\tif ( !this.rendered ) {\n\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t}\n\n\tthis.items.forEach( i => i.unrender( shouldDestroy ) );\n\tthis.rendered = false;\n}\n","import bubble from './Fragment/prototype/bubble';\nimport detach from './Fragment/prototype/detach';\nimport find from './Fragment/prototype/find';\nimport findAll from './Fragment/prototype/findAll';\nimport findAllComponents from './Fragment/prototype/findAllComponents';\nimport findComponent from './Fragment/prototype/findComponent';\nimport findNextNode from './Fragment/prototype/findNextNode';\nimport firstNode from './Fragment/prototype/firstNode';\nimport getArgsList from './Fragment/prototype/getArgsList';\nimport getNode from './Fragment/prototype/getNode';\nimport getValue from './Fragment/prototype/getValue';\nimport init from './Fragment/prototype/init';\nimport rebind from './Fragment/prototype/rebind';\nimport render from './Fragment/prototype/render';\nimport toString from './Fragment/prototype/toString';\nimport unbind from './Fragment/prototype/unbind';\nimport unrender from './Fragment/prototype/unrender';\n\nvar Fragment = function ( options ) {\n\tthis.init( options );\n};\n\nFragment.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetArgsList: getArgsList,\n\tgetNode: getNode,\n\tgetValue: getValue,\n\tinit: init,\n\trebind: rebind,\n\tregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tif ( idxs.indexOf( idx ) === -1 ) {\n\t\t\tidxs.push( idx );\n\t\t}\n\t},\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tidxs.splice( idxs.indexOf( idx ), 1 );\n\t},\n\tunrender: unrender\n};\n\nexport default Fragment;\n","import defaults from 'Ractive/config/defaults';\nimport easing from 'Ractive/static/easing';\nimport interpolators from 'Ractive/static/interpolators';\nimport { magic, svg } from 'config/environment';\nimport { defineProperties, extend as extendObj } from 'utils/object';\nimport proto from 'Ractive/prototype';\nimport Promise from 'utils/Promise';\nimport extend from 'extend/_extend';\nimport parse from 'parse/_parse';\nimport getNodeInfo from 'Ractive/static/getNodeInfo';\nimport initialise from 'Ractive/initialise';\n\nvar Ractive, properties;\n\n// Main Ractive required object\nRactive = function ( options ) {\n\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\tinitialise( this, options );\n};\n\n\n// Ractive properties\nproperties = {\n\n\t// debug flag\n\tDEBUG:          { writable: true, value: true },\n\tDEBUG_PROMISES: { writable: true, value: true },\n\n\t// static methods:\n\textend:         { value: extend },\n\tgetNodeInfo:    { value: getNodeInfo },\n\tparse:          { value: parse },\n\n\t// Namespaced constructors\n\tPromise:        { value: Promise },\n\n\t// support\n\tsvg:            { value: svg },\n\tmagic:          { value: magic },\n\n\t// version\n\tVERSION:        { value: '<@version@>' },\n\n\t// Plugins\n\tadaptors:       { writable: true, value: {} },\n\tcomponents:     { writable: true, value: {} },\n\tdecorators:     { writable: true, value: {} },\n\teasing:         { writable: true, value: easing },\n\tevents:         { writable: true, value: {} },\n\tinterpolators:  { writable: true, value: interpolators },\n\tpartials:       { writable: true, value: {} },\n\ttransitions:    { writable: true, value: {} }\n};\n\n\n// Ractive properties\ndefineProperties( Ractive, properties );\n\nRactive.prototype = extendObj( proto, defaults );\n\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as defaults\nRactive.defaults = Ractive.prototype;\n\n// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n// older browsers, these are made available via a shim - here, we do a quick\n// pre-flight check to make sure that either a) we're not in a shit browser,\n// or b) we're using a Ractive-legacy.js build\nvar FUNCTION = 'function';\n\nif (\n\ttypeof Date.now !== FUNCTION                 ||\n\ttypeof String.prototype.trim !== FUNCTION    ||\n\ttypeof Object.keys !== FUNCTION              ||\n\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\ttypeof Array.prototype.map !== FUNCTION      ||\n\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t( typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION )\n) {\n\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n}\n\nexport default Ractive;\n","import config from 'Ractive/config/config';\nimport Fragment from 'virtualdom/Fragment';\nimport Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { rootKeypath } from 'shared/keypaths';\n\nvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ],\n\tresetHook = new Hook( 'reset' );\n\nexport default function Ractive$reset ( data ) {\n\tvar promise, wrapper, changes, i, rerender;\n\n\tdata = data || {};\n\n\tif ( typeof data !== 'object' ) {\n\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t}\n\n\t// If the root object is wrapped, try and use the wrapper's reset value\n\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t// reset was rejected, we need to replace the object\n\t\t\tthis.viewmodel.reset( data );\n\t\t}\n\t} else {\n\t\tthis.viewmodel.reset( data );\n\t}\n\n\t// reset config items and track if need to rerender\n\tchanges = config.reset( this );\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\trerender = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( rerender ) {\n\t\tlet component;\n\n\t\tthis.viewmodel.mark( rootKeypath );\n\n\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t \t// flag, otherwise it will assume by default that a parent node\n\t \t// will be detached, and therefore it doesn't need to bother\n\t \t// detaching its own nodes\n\t \tif ( component = this.component ) {\n\t \t\tcomponent.shouldDestroy = true;\n\t \t}\n\n\t\tthis.unrender();\n\n\t\tif ( component ) {\n\t\t\tcomponent.shouldDestroy = false;\n\t\t}\n\n\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t// TODO if we're here, presumably it did?\n\t\tif ( this.fragment.template !== this.template ) {\n\t\t\tthis.fragment.unbind();\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tpromise = this.render( this.el, this.anchor );\n\t} else {\n\t\tpromise = runloop.start( this, true );\n\t\tthis.viewmodel.mark( rootKeypath );\n\t\trunloop.end();\n\t}\n\n\tresetHook.fire( this, data );\n\n\treturn promise;\n}\n","import { isArray } from 'utils/is';\nimport runloop from 'global/runloop';\nimport { PARTIAL, COMPONENT, ELEMENT } from 'config/types';\n\nexport default function ( name, partial ) {\n\tvar promise, collection = [];\n\n\tfunction collect( source, dest, ractive ) {\n\t\t// if this is a component and it has its own partial, bail\n\t\tif ( ractive && ractive.partials[name] ) return;\n\n\t\tsource.forEach( item => {\n\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\tif ( item.type === PARTIAL && item.getPartialName() === name ) {\n\t\t\t\tdest.push( item );\n\t\t\t}\n\n\t\t\t// if it has a fragment, process its items\n\t\t\tif ( item.fragment ) {\n\t\t\t\tcollect( item.fragment.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it has fragments\n\t\t\tif ( isArray( item.fragments ) ) {\n\t\t\t\tcollect( item.fragments, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is itself a fragment, process its items\n\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\tcollect( item.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is a component, step in and process its items\n\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\tcollect( item.instance.fragment.items, dest, item.instance );\n\t\t\t}\n\n\t\t\t// if the item is an element, process its attributes too\n\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\tcollect( item.attributes, dest, ractive );\n\t\t\t\t}\n\n\t\t\t\tif ( isArray( item.conditionalAttributes ) ) {\n\t\t\t\t\tcollect( item.conditionalAttributes, dest, ractive );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tcollect( this.fragment.items, collection );\n\tthis.partials[name] = partial;\n\n\tpromise = runloop.start( this, true );\n\n\tcollection.forEach( item => {\n\t\titem.value = undefined;\n\t\titem.setValue( name );\n\t});\n\n\trunloop.end();\n\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'reverse' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'shift' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'sort' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'splice' );\n","import Hook from './shared/hooks/Hook';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport { cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nexport default function Ractive$teardown () {\n\tvar promise;\n\n\tthis.fragment.unbind();\n\tthis.viewmodel.teardown();\n\n\tthis._observers.forEach( cancel );\n\n\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\n\tthis.shouldDestroy = true;\n\tpromise = ( this.fragment.rendered ? this.unrender() : Promise.resolve() );\n\n\tteardownHook.fire( this );\n\n\tthis._boundFunctions.forEach( deleteFunctionCopy );\n\n\treturn promise;\n}\n\nfunction deleteFunctionCopy ( bound ) {\n\tdelete bound.fn[ bound.prop ];\n}","export default function Ractive$toHTML () {\n\treturn this.fragment.toString( true );\n}\n","import Hook from './shared/hooks/Hook';\nimport { warnIfDebug } from 'utils/log';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nvar unrenderHook = new Hook( 'unrender' );\n\nexport default function Ractive$unrender () {\n\tvar promise, shouldDestroy;\n\n\tif ( !this.fragment.rendered ) {\n\t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\treturn Promise.resolve();\n\t}\n\n\tpromise = runloop.start( this, true );\n\n\t// If this is a component, and the component isn't marked for destruction,\n\t// don't detach nodes from the DOM unnecessarily\n\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n\t// Cancel any animations in progress\n\twhile ( this._animations[0] ) {\n\t\tthis._animations[0].stop(); // it will remove itself from the index\n\t}\n\n\tthis.fragment.unrender( shouldDestroy );\n\n\tremoveFromArray( this.el.__ractive_instances__, this );\n\n\tunrenderHook.fire( this );\n\n\trunloop.end();\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'unshift' );\n","import Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { getKeypath, rootKeypath } from 'shared/keypaths';\n\nvar updateHook = new Hook( 'update' );\n\nexport default function Ractive$update ( keypath ) {\n\tvar promise;\n\n\tkeypath = getKeypath( keypath ) || rootKeypath;\n\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.mark( keypath );\n\trunloop.end();\n\n\tupdateHook.fire( this, keypath );\n\n\treturn promise;\n}\n","import add from 'Ractive/prototype/add';\nimport animate from 'Ractive/prototype/animate';\nimport detach from 'Ractive/prototype/detach';\nimport find from 'Ractive/prototype/find';\nimport findAll from 'Ractive/prototype/findAll';\nimport findAllComponents from 'Ractive/prototype/findAllComponents';\nimport findComponent from 'Ractive/prototype/findComponent';\nimport findContainer from 'Ractive/prototype/findContainer';\nimport findParent from 'Ractive/prototype/findParent';\nimport fire from 'Ractive/prototype/fire';\nimport get from 'Ractive/prototype/get';\nimport insert from 'Ractive/prototype/insert';\nimport merge from 'Ractive/prototype/merge';\nimport observe from 'Ractive/prototype/observe';\nimport observeOnce from 'Ractive/prototype/observeOnce';\nimport off from 'Ractive/prototype/off';\nimport on from 'Ractive/prototype/on';\nimport once from 'Ractive/prototype/once';\nimport pop from 'Ractive/prototype/pop';\nimport push from 'Ractive/prototype/push';\nimport render from 'Ractive/prototype/render';\nimport reset from 'Ractive/prototype/reset';\nimport resetPartial from 'Ractive/prototype/resetPartial';\nimport resetTemplate from 'Ractive/prototype/resetTemplate';\nimport reverse from 'Ractive/prototype/reverse';\nimport set from 'Ractive/prototype/set';\nimport shift from 'Ractive/prototype/shift';\nimport sort from 'Ractive/prototype/sort';\nimport splice from 'Ractive/prototype/splice';\nimport subtract from 'Ractive/prototype/subtract';\nimport teardown from 'Ractive/prototype/teardown';\nimport toggle from 'Ractive/prototype/toggle';\nimport toHTML from 'Ractive/prototype/toHTML';\nimport unrender from 'Ractive/prototype/unrender';\nimport unshift from 'Ractive/prototype/unshift';\nimport update from 'Ractive/prototype/update';\nimport updateModel from 'Ractive/prototype/updateModel';\n\nexport default {\n\tadd: add,\n\tanimate: animate,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindContainer: findContainer,\n\tfindParent: findParent,\n\tfire: fire,\n\tget: get,\n\tinsert: insert,\n\tmerge: merge,\n\tobserve: observe,\n\tobserveOnce: observeOnce,\n\toff: off,\n\ton: on,\n\tonce: once,\n\tpop: pop,\n\tpush: push,\n\trender: render,\n\treset: reset,\n\tresetPartial: resetPartial,\n\tresetTemplate: resetTemplate,\n\treverse: reverse,\n\tset: set,\n\tshift: shift,\n\tsort: sort,\n\tsplice: splice,\n\tsubtract: subtract,\n\tteardown: teardown,\n\ttoggle: toggle,\n\ttoHTML: toHTML,\n\ttoHtml: toHTML,\n\tunrender: unrender,\n\tunshift: unshift,\n\tupdate: update,\n\tupdateModel: updateModel\n};\n","export default function ( method, superMethod, force ) {\n\n\tif ( force || needsSuper( method, superMethod ) )  {\n\n\t\treturn function () {\n\n\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n\t\t\tthis._super = superMethod;\n\n\t\t\tresult = method.apply( this, arguments );\n\n\t\t\tif ( hasSuper ) {\n\t\t\t\tthis._super = _super;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\telse {\n\t\treturn method;\n\t}\n}\n\nfunction needsSuper ( method, superMethod ) {\n\treturn typeof superMethod === 'function' && /_super/.test( method );\n}\n","import { create, defineProperties, extend as extendObj } from 'utils/object';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport initialise from 'Ractive/initialise';\nimport Ractive from 'Ractive';\nimport unwrapExtended from './unwrapExtended';\n\nexport default extend;\n\nfunction extend ( ...options ) {\n\tif( !options.length ) {\n\t\treturn extendOne( this );\n\t} else {\n\t\treturn options.reduce( extendOne, this );\n\t}\n}\n\nfunction extendOne ( Parent, options = {} ) {\n\tvar Child, proto;\n\n\t// if we're extending with another Ractive instance...\n\t//\n\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t//   var Spiderman = Human.extend( Spider );\n\t//\n\t// ...inherit prototype methods and default options as well\n\tif ( options.prototype instanceof Ractive ) {\n\t\toptions = unwrapExtended( options );\n\t}\n\n\tChild = function ( options ) {\n\t\tif ( !( this instanceof Child ) ) return new Child( options );\n\t\tinitialise( this, options );\n\t};\n\n\tproto = create( Parent.prototype );\n\tproto.constructor = Child;\n\n\t// Static properties\n\tdefineProperties( Child, {\n\t\t// alias prototype as defaults\n\t\tdefaults: { value: proto },\n\n\t\t// extendable\n\t\textend: { value: extend, writable: true, configurable: true },\n\n\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t_Parent: { value: Parent }\n\t});\n\n\t// extend configuration\n\tconfig.extend( Parent, proto, options );\n\n\tdataConfigurator.extend( Parent, proto, options );\n\n\tif ( options.computed ) {\n\t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t}\n\n\tChild.prototype = proto;\n\n\treturn Child;\n}\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function( node ) {\n\tvar info = {}, priv, indices;\n\n\tif ( !node || !( priv = node._ractive ) ) {\n\t\treturn info;\n\t}\n\n\tinfo.ractive = priv.root;\n\tinfo.keypath = priv.keypath.str;\n\tinfo.index = {};\n\n\t// find all index references and resolve them\n\tif ( indices = findIndexRefs( priv.proxy.parentFragment ) ) {\n\t\tinfo.index = findIndexRefs.resolve( indices );\n\t}\n\n\treturn info;\n}\n","import runloop from 'global/runloop';\nimport { getKeypath } from 'shared/keypaths';\nimport resolveRef from 'shared/resolveRef';\n\nvar ReferenceResolver = function ( owner, ref, callback ) {\n\tvar keypath;\n\n\tthis.ref = ref;\n\tthis.resolved = false;\n\n\tthis.root = owner.root;\n\tthis.parentFragment = owner.parentFragment;\n\tthis.callback = callback;\n\n\tkeypath = resolveRef( owner.root, ref, owner.parentFragment );\n\tif ( keypath != undefined ) {\n\t\tthis.resolve( keypath );\n\t}\n\n\telse {\n\t\trunloop.addUnresolved( this );\n\t}\n};\n\nReferenceResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tif ( this.keypath && !keypath ) {\n\t\t\t// it was resolved, and now it's not. Can happen if e.g. `bar` in\n\t\t\t// `{{foo[bar]}}` becomes undefined\n\t\t\trunloop.addUnresolved( this );\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\tthis.keypath = keypath;\n\t\tthis.callback( keypath );\n\t},\n\n\tforceResolution: function () {\n\t\tthis.resolve( getKeypath( this.ref ) );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tvar keypath;\n\n\t\tif ( this.keypath != undefined ) {\n\t\t\tkeypath = this.keypath.replace( oldKeypath, newKeypath );\n\t\t\t// was a new keypath created?\n\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t// resolve it\n\t\t\t\tthis.resolve( keypath );\n\t\t\t}\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tif ( !this.resolved ) {\n\t\t\trunloop.removeUnresolved( this );\n\t\t}\n\t}\n};\n\n\nexport default ReferenceResolver;\n","import { SECTION_EACH } from 'config/types';\nimport { getKeypath } from 'shared/keypaths'; // TODO maybe we don't need the @ construct now that we have Keypath objects?\n\nvar SpecialResolver = function ( owner, ref, callback ) {\n\tthis.parentFragment = owner.parentFragment;\n\tthis.ref = ref;\n\tthis.callback = callback;\n\n\tthis.rebind();\n};\n\nvar props = {\n\t'@keypath': { prefix: 'c', prop: [ 'context' ] },\n\t'@index': { prefix: 'i', prop: [ 'index' ] },\n\t'@key': { prefix: 'k', prop: [ 'key', 'index' ] }\n};\n\nfunction getProp( target, prop ) {\n\tvar value;\n\tfor ( let i = 0; i < prop.prop.length; i++ ) {\n\t\tif ( ( value = target[prop.prop[i]] ) !== undefined ) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nSpecialResolver.prototype = {\n\trebind: function () {\n\t\tvar ref = this.ref, fragment = this.parentFragment, prop = props[ref], value;\n\n\t\tif ( !prop ) {\n\t\t\tthrow new Error( 'Unknown special reference \"' + ref + '\" - valid references are @index, @key and @keypath' );\n\t\t}\n\n\t\t// have we already found the nearest parent?\n\t\tif ( this.cached ) {\n\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + getProp( this.cached, prop ) ) );\n\t\t}\n\n\t\t// special case for indices, which may cross component boundaries\n\t\tif ( prop.prop.indexOf( 'index' ) !== -1 || prop.prop.indexOf( 'key' ) !== -1 ) {\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( fragment.owner.currentSubtype === SECTION_EACH && ( value = getProp( fragment, prop ) ) !== undefined ) {\n\t\t\t\t\tthis.cached = fragment;\n\n\t\t\t\t\tfragment.registerIndexRef( this );\n\n\t\t\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + value ) );\n\t\t\t\t}\n\n\t\t\t\t// watch for component boundaries\n\t\t\t\tif ( !fragment.parent && fragment.owner &&\n\t\t\t\t     fragment.owner.component && fragment.owner.component.parentFragment &&\n\t\t\t\t     !fragment.owner.component.instance.isolated ) {\n\t\t\t\t\tfragment = fragment.owner.component.parentFragment;\n\t\t\t\t} else {\n\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( ( value = getProp( fragment, prop ) ) !== undefined ) {\n\t\t\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + value.str ) );\n\t\t\t\t}\n\n\t\t\t\tfragment = fragment.parent;\n\t\t\t}\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tif ( this.cached ) {\n\t\t\tthis.cached.unregisterIndexRef( this );\n\t\t}\n\t}\n};\n\nexport default SpecialResolver;\n","import { getKeypath } from 'shared/keypaths'; // TODO find a better way than @\n\nvar IndexResolver = function ( owner, ref, callback ) {\n\tthis.parentFragment = owner.parentFragment;\n\tthis.ref = ref;\n\tthis.callback = callback;\n\n\tref.ref.fragment.registerIndexRef( this );\n\n\tthis.rebind();\n};\n\nIndexResolver.prototype = {\n\trebind: function () {\n\t\tvar index, ref = this.ref.ref;\n\n\t\tif ( ref.ref.t === 'k' ) {\n\t\t\tindex = 'k' + ref.fragment.key;\n\t\t} else {\n\t\t\tindex = 'i' + ref.fragment.index;\n\t\t}\n\n\t\tif ( index !== undefined ) {\n\t\t\tthis.callback( getKeypath( '@' + index ) );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tthis.ref.ref.fragment.unregisterIndexRef( this );\n\t}\n};\n\nexport default IndexResolver;\n","export default findIndexRefs;\n\nfunction findIndexRefs( fragment, refName ) {\n\tvar result = {}, refs, fragRefs, ref, i, owner, hit = false;\n\n\tif ( !refName ) {\n\t\tresult.refs = refs = {};\n\t}\n\n\twhile ( fragment ) {\n\t\tif ( ( owner = fragment.owner ) && ( fragRefs = owner.indexRefs ) ) {\n\n\t\t\t// we're looking for a particular ref, and it's here\n\t\t\tif ( refName && ( ref = owner.getIndexRef( refName ) ) ) {\n\t\t\t\tresult.ref = {\n\t\t\t\t\tfragment: fragment,\n\t\t\t\t\tref: ref\n\t\t\t\t};\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// we're collecting refs up-tree\n\t\t\telse if ( !refName ) {\n\t\t\t\tfor ( i in fragRefs ) {\n\t\t\t\t\tref = fragRefs[i];\n\n\t\t\t\t\t// don't overwrite existing refs - they should shadow parents\n\t\t\t\t\tif ( !refs[ref.n] ) {\n\t\t\t\t\t\thit = true;\n\t\t\t\t\t\trefs[ref.n] = {\n\t\t\t\t\t\t\tfragment: fragment,\n\t\t\t\t\t\t\tref: ref\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// watch for component boundaries\n\t\tif ( !fragment.parent && fragment.owner &&\n\t\t     fragment.owner.component && fragment.owner.component.parentFragment &&\n\t\t     !fragment.owner.component.instance.isolated ) {\n\t\t\tresult.componentBoundary = true;\n\t\t\tfragment = fragment.owner.component.parentFragment;\n\t\t} else {\n\t\t\tfragment = fragment.parent;\n\t\t}\n\t}\n\n\tif ( !hit ) {\n\t\treturn undefined;\n\t} else {\n\t\treturn result;\n\t}\n}\n\nfindIndexRefs.resolve = function resolve( indices ) {\n\tvar refs = {}, k, ref;\n\n\tfor ( k in indices.refs ) {\n\t\tref = indices.refs[k];\n\t\trefs[ ref.ref.n ] = ref.ref.t === 'k' ? ref.fragment.key : ref.fragment.index;\n\t}\n\n\treturn refs;\n};\n","import { defineProperty } from 'utils/object';\nimport { getKeypath } from 'shared/keypaths';\nimport getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from './createReferenceResolver';\nimport 'legacy'; // for fn.bind()\n\nvar ExpressionResolver, bind = Function.prototype.bind;\n\nExpressionResolver = function ( owner, parentFragment, expression, callback ) {\n\tvar ractive;\n\n\tractive = owner.root;\n\n\tthis.root = ractive;\n\tthis.parentFragment = parentFragment;\n\tthis.callback = callback;\n\tthis.owner = owner;\n\tthis.str = expression.s;\n\tthis.keypaths = [];\n\n\t// Create resolvers for each reference\n\tthis.pending = expression.r.length;\n\tthis.refResolvers = expression.r.map( ( ref, i ) => {\n\t\treturn createReferenceResolver( this, ref, keypath => {\n\t\t\tthis.resolve( i, keypath );\n\t\t});\n\t});\n\n\tthis.ready = true;\n\tthis.bubble();\n};\n\nExpressionResolver.prototype = {\n\tbubble () {\n\t\tif ( !this.ready ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.uniqueString = getUniqueString( this.str, this.keypaths );\n\t\tthis.keypath = createExpressionKeypath( this.uniqueString );\n\n\t\tthis.createEvaluator();\n\t\tthis.callback( this.keypath );\n\t},\n\n\tunbind () {\n\t\tvar resolver;\n\n\t\twhile ( resolver = this.refResolvers.pop() ) {\n\t\t\tresolver.unbind();\n\t\t}\n\t},\n\n\tresolve ( index, keypath ) {\n\t\tthis.keypaths[ index ] = keypath;\n\t\tthis.bubble();\n\t},\n\n\tcreateEvaluator () {\n\t\tvar computation, valueGetters, signature, keypath, fn;\n\n\t\tkeypath = this.keypath;\n\t\tcomputation = this.root.viewmodel.computations[ keypath.str ];\n\n\t\t// only if it doesn't exist yet!\n\t\tif ( !computation ) {\n\t\t\tfn = getFunctionFromString( this.str, this.refResolvers.length );\n\n\t\t\tvalueGetters = this.keypaths.map( keypath => {\n\t\t\t\tvar value;\n\n\t\t\t\tif ( keypath === 'undefined' ) {\n\t\t\t\t\treturn () => undefined;\n\t\t\t\t}\n\n\t\t\t\t// 'special' keypaths encode a value\n\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\tvalue = keypath.value;\n\t\t\t\t\treturn () => value;\n\t\t\t\t}\n\n\t\t\t\treturn () => {\n\t\t\t\t\tvar value = this.root.viewmodel.get( keypath, { noUnwrap: true, fullRootGet: true });\n\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\tvalue = wrapFunction( value, this.root );\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tsignature = {\n\t\t\t\tdeps: this.keypaths.filter( isValidDependency ),\n\t\t\t\tgetter () {\n\t\t\t\t\tvar args = valueGetters.map( call );\n\t\t\t\t\treturn fn.apply( null, args );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcomputation = this.root.viewmodel.compute( keypath, signature );\n\t\t} else {\n\t\t\tthis.root.viewmodel.mark( keypath );\n\t\t}\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// TODO only bubble once, no matter how many references are affected by the rebind\n\t\tthis.refResolvers.forEach( r => r.rebind( oldKeypath, newKeypath ) );\n\t}\n};\n\nexport default ExpressionResolver;\n\nfunction call ( value ) {\n\treturn value.call();\n}\n\nfunction getUniqueString ( str, keypaths ) {\n\t// get string that is unique to this expression\n\treturn str.replace( /_([0-9]+)/g, function ( match, $1 ) {\n\t\tvar keypath, value;\n\n\t\t// make sure we're not replacing a non-keypath _[0-9]\n\t\tif ( +$1 >= keypaths.length ) {\n\t\t\treturn `_${$1}`;\n\t\t}\n\n\t\tkeypath = keypaths[ $1 ];\n\n\t\tif ( keypath === undefined ) {\n\t\t\treturn 'undefined';\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\tvalue = keypath.value;\n\t\t\treturn typeof value === 'number' ? value : '\"' + value + '\"';\n\t\t}\n\n\t\treturn keypath.str;\n\t});\n}\n\nfunction createExpressionKeypath ( uniqueString ) {\n\t// Sanitize by removing any periods or square brackets. Otherwise\n\t// we can't split the keypath into keys!\n\t// Remove asterisks too, since they mess with pattern observers\n\treturn getKeypath( '${' + uniqueString.replace( /[\\.\\[\\]]/g, '-' ).replace( /\\*/, '#MUL#' ) + '}' );\n}\n\nfunction isValidDependency ( keypath ) {\n\treturn keypath !== undefined && keypath[0] !== '@';\n}\n\nfunction wrapFunction ( fn, ractive ) {\n\tvar wrapped, prop, key;\n\n\tif ( fn.__ractive_nowrap ) {\n\t\treturn fn;\n\t}\n\n\tprop = '__ractive_' + ractive._guid;\n\twrapped = fn[ prop ];\n\n\tif ( wrapped ) {\n\t\treturn wrapped;\n\t}\n\n\telse if ( /this/.test( fn.toString() ) ) {\n\t\tdefineProperty( fn, prop, {\n\t\t\tvalue: bind.call( fn, ractive ),\n\t\t\tconfigurable: true\n\t\t});\n\n\t\t// Add properties/methods to wrapped function\n\t\tfor ( key in fn ) {\n\t\t\tif ( fn.hasOwnProperty( key ) ) {\n\t\t\t\tfn[ prop ][ key ] = fn[ key ];\n\t\t\t}\n\t\t}\n\n\t\tractive._boundFunctions.push({\n\t\t\tfn: fn,\n\t\t\tprop: prop\n\t\t});\n\n\t\treturn fn[ prop ];\n\t}\n\n\tdefineProperty( fn, '__ractive_nowrap', {\n\t\tvalue: fn\n\t});\n\n\treturn fn.__ractive_nowrap;\n}\n","var cache = {};\n\nexport default function getFunctionFromString ( str, i ) {\n\tvar fn, args;\n\n\tif ( cache[ str ] ) {\n\t\treturn cache[ str ];\n\t}\n\n\targs = [];\n\twhile ( i-- ) {\n\t\targs[i] = '_' + i;\n\t}\n\n\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\n\n\tcache[ str ] = fn;\n\treturn fn;\n}\n","import { REFERENCE } from 'config/types';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\n\nvar MemberResolver = function ( template, resolver, parentFragment ) {\n\tthis.resolver = resolver;\n\tthis.root = resolver.root;\n\tthis.parentFragment = parentFragment;\n\tthis.viewmodel = resolver.root.viewmodel;\n\n\tif ( typeof template === 'string' ) {\n\t\tthis.value = template;\n\t}\n\n\t// Simple reference?\n\telse if ( template.t === REFERENCE ) {\n\t\tthis.refResolver = createReferenceResolver( this, template.n, keypath => {\n\t\t\tthis.resolve( keypath );\n\t\t});\n\t}\n\n\t// Otherwise we have an expression in its own right\n\telse {\n\t\tnew ExpressionResolver( resolver, parentFragment, template, keypath => {\n\t\t\tthis.resolve( keypath );\n\t\t});\n\t}\n};\n\nMemberResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tif ( this.keypath ) {\n\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.value = this.viewmodel.get( keypath );\n\n\t\tthis.bind();\n\n\t\tthis.resolver.bubble();\n\t},\n\n\tbind: function () {\n\t\tthis.viewmodel.register( this.keypath, this );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tsetValue: function ( value ) {\n\t\tthis.value = value;\n\t\tthis.resolver.bubble();\n\t},\n\n\tunbind: function () {\n\t\tif ( this.keypath ) {\n\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t}\n\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.unbind();\n\t\t}\n\t},\n\n\tforceResolution: function () {\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.forceResolution();\n\t\t}\n\t}\n};\n\nexport default MemberResolver;\n","import resolveRef from 'shared/resolveRef';\nimport { unbind } from 'shared/methodCallers';\nimport { getKeypath } from 'shared/keypaths';\nimport ReferenceResolver from '../ReferenceResolver';\nimport MemberResolver from './MemberResolver';\n\nvar ReferenceExpressionResolver = function ( mustache, template, callback ) {\n\tvar ractive, ref, keypath, parentFragment;\n\n\tthis.parentFragment = parentFragment = mustache.parentFragment;\n\tthis.root = ractive = mustache.root;\n\tthis.mustache = mustache;\n\n\tthis.ref = ref = template.r;\n\tthis.callback = callback;\n\n\tthis.unresolved = [];\n\n\t// Find base keypath\n\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\tthis.base = keypath;\n\t} else {\n\t\tthis.baseResolver = new ReferenceResolver( this, ref, keypath => {\n\t\t\tthis.base = keypath;\n\t\t\tthis.baseResolver = null;\n\t\t\tthis.bubble();\n\t\t});\n\t}\n\n\t// Find values for members, or mark them as unresolved\n\tthis.members = template.m.map( template => new MemberResolver( template, this, parentFragment ) );\n\n\tthis.ready = true;\n\tthis.bubble(); // trigger initial resolution if possible\n};\n\nReferenceExpressionResolver.prototype = {\n\tgetKeypath: function () {\n\t\tvar values = this.members.map( getValue );\n\n\t\tif ( !values.every( isDefined ) || this.baseResolver ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.base.join( values.join( '.' ) );\n\t},\n\n\tbubble: function () {\n\t\tif ( !this.ready || this.baseResolver ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.callback( this.getKeypath() );\n\t},\n\n\tunbind: function () {\n\t\tthis.members.forEach( unbind );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tvar changed;\n\n\t\tif ( this.base ) {\n\t\t\tlet newBase = this.base.replace( oldKeypath, newKeypath );\n\t\t\tif ( newBase && newBase !== this.base ) {\n\t\t\t\tthis.base = newBase;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.members.forEach( members => {\n\t\t\tif ( members.rebind( oldKeypath, newKeypath ) ) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t});\n\n\t\tif ( changed ) {\n\t\t\tthis.bubble();\n\t\t}\n\t},\n\n\tforceResolution: function () {\n\t\tif ( this.baseResolver ) {\n\t\t\tthis.base = getKeypath( this.ref );\n\n\t\t\tthis.baseResolver.unbind();\n\t\t\tthis.baseResolver = null;\n\t\t}\n\n\t\tthis.members.forEach( forceResolution );\n\t\tthis.bubble();\n\t}\n};\n\nfunction getValue ( member ) {\n\treturn member.value;\n}\n\nfunction isDefined ( value ) {\n\treturn value != undefined;\n}\n\nfunction forceResolution ( member ) {\n\tmember.forceResolution();\n}\n\nexport default ReferenceExpressionResolver;\n","export default function Mustache$resolve ( keypath ) {\n\tvar wasResolved, value, twowayBinding;\n\n\t// 'Special' keypaths, e.g. @foo or @7, encode a value\n\tif ( keypath && keypath.isSpecial ) {\n\t\tthis.keypath = keypath;\n\t\tthis.setValue( keypath.value );\n\t\treturn;\n\t}\n\n\t// If we resolved previously, we need to unregister\n\tif ( this.registered ) { // undefined or null\n\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\tthis.registered = false;\n\n\t\twasResolved = true;\n\t}\n\n\tthis.keypath = keypath;\n\n\t// If the new keypath exists, we need to register\n\t// with the viewmodel\n\tif ( keypath != undefined ) { // undefined or null\n\t\tvalue = this.root.viewmodel.get( keypath );\n\t\tthis.root.viewmodel.register( keypath, this );\n\n\t\tthis.registered = true;\n\t}\n\n\t// Either way we need to queue up a render (`value`\n\t// will be `undefined` if there's no keypath)\n\tthis.setValue( value );\n\n\t// Two-way bindings need to point to their new target keypath\n\tif ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {\n\t\ttwowayBinding.rebound();\n\t}\n}\n","export default function Mustache$rebind ( oldKeypath, newKeypath ) {\n\t// Children first\n\tif ( this.fragments ) {\n\t\tthis.fragments.forEach( f => f.rebind( oldKeypath, newKeypath ) );\n\t}\n\n\t// Expression mustache?\n\tif ( this.resolver ) {\n\t\tthis.resolver.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import getValue from './getValue';\nimport init from './initialise';\nimport resolve from './resolve';\nimport rebind from './rebind';\n\nexport default {\n\tgetValue: getValue,\n\tinit: init,\n\tresolve: resolve,\n\trebind: rebind\n};\n","import { INTERPOLATOR } from 'config/types';\nimport runloop from 'global/runloop';\nimport { escapeHtml } from 'utils/html';\nimport { detachNode, safeToStringValue } from 'utils/dom';\nimport { isEqual } from 'utils/is';\nimport unbind from './shared/unbind';\nimport Mustache from './shared/Mustache/_Mustache';\nimport detach from './shared/detach';\n\nvar Interpolator = function ( options ) {\n\tthis.type = INTERPOLATOR;\n\tMustache.init( this, options );\n};\n\nInterpolator.prototype = {\n\tupdate () {\n\t\tthis.node.data = ( this.value == undefined ? '' : this.value );\n\t},\n\tresolve: Mustache.resolve,\n\trebind: Mustache.rebind,\n\tdetach: detach,\n\n\tunbind: unbind,\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createTextNode( safeToStringValue(this.value) );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tdetachNode( this.node );\n\t\t}\n\t},\n\n\tgetValue: Mustache.getValue,\n\n\t// TEMP\n\tsetValue ( value ) {\n\t\tvar wrapper;\n\n\t\t// TODO is there a better way to approach this?\n\t\tif ( this.keypath && ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) ) {\n\t\t\tvalue = wrapper.get();\n\t\t}\n\n\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\tthis.value = value;\n\t\t\tthis.parentFragment.bubble();\n\n\t\t\tif ( this.node ) {\n\t\t\t\trunloop.addView( this );\n\t\t\t}\n\t\t}\n\t},\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\ttoString ( escape ) {\n\t\tvar string = ( '' + safeToStringValue(this.value) );\n\t\treturn escape ? escapeHtml( string ) : string;\n\t}\n};\n\nexport default Interpolator;\n","export default function Section$bubble () {\n\tthis.parentFragment.bubble();\n}\n","export default function Section$detach () {\n\tvar docFrag;\n\n\tif ( this.fragments.length === 1 ) {\n\t\treturn this.fragments[0].detach();\n\t}\n\n\tdocFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( item => {\n\t\tdocFrag.appendChild( item.detach() );\n\t});\n\n\treturn docFrag;\n}\n","export default function Section$find ( selector ) {\n\tvar i, len, queryResult;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( queryResult = this.fragments[i].find( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Section$findAll ( selector, query ) {\n\tvar i, len;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tthis.fragments[i].findAll( selector, query );\n\t}\n}\n","export default function Section$findComponent ( selector ) {\n\tvar i, len, queryResult;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( queryResult = this.fragments[i].findComponent( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Section$findNextNode ( fragment ) {\n\tif ( this.fragments[ fragment.index + 1 ] ) {\n\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Section$firstNode () {\n\tvar len, i, node;\n\n\tif ( len = this.fragments.length ) {\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( node = this.fragments[i].firstNode() ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","import Mustache from '../../shared/Mustache/_Mustache';\n\nexport default function( oldKeypath, newKeypath ) {\n\tMustache.rebind.call( this, oldKeypath, newKeypath );\n}\n","export default function Section$render () {\n\tthis.docFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( f => this.docFrag.appendChild( f.render() ) );\n\n\tthis.renderedFragments = this.fragments.slice();\n\tthis.fragmentsToRender = [];\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","export default function Section$toString ( escape ) {\n\tvar str, i, len;\n\n\tstr = '';\n\n\ti = 0;\n\tlen = this.length;\n\n\tfor ( i=0; i<len; i+=1 ) {\n\t\tstr += this.fragments[i].toString( escape );\n\t}\n\n\treturn str;\n}\n","export default function Section$unrender ( shouldDestroy ) {\n\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\tthis.renderedFragments = [];\n\tthis.rendered = false;\n}\n\nfunction unrenderAndDestroy ( fragment ) {\n\tfragment.unrender( true );\n}\n\nfunction unrender ( fragment ) {\n\tfragment.unrender( false );\n}\n","export default function Section$update () {\n\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n\t// `this.renderedFragments` is in the order of the previous render.\n\t// If fragments have shuffled about, this allows us to quickly\n\t// reinsert them in the correct place\n\trenderedFragments = this.renderedFragments;\n\n\t// Remove fragments that have been marked for destruction\n\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\tfragment.unrender( true );\n\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t}\n\n\t// Render new fragments (but don't insert them yet)\n\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\tfragment.render();\n\t}\n\n\tif ( this.rendered ) {\n\t\ttarget = this.parentFragment.getNode();\n\t}\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tfragment = this.fragments[i];\n\t\trenderIndex = renderedFragments.indexOf( fragment, i ); // search from current index - it's guaranteed to be the same or higher\n\n\t\tif ( renderIndex === i ) {\n\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis.docFrag.appendChild( fragment.detach() );\n\n\t\t// update renderedFragments\n\t\tif ( renderIndex !== -1 ) {\n\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t}\n\t\trenderedFragments.splice( i, 0, fragment );\n\t}\n\n\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\tanchor = this.parentFragment.findNextNode( this );\n\t\ttarget.insertBefore( this.docFrag, anchor );\n\t}\n\n\t// Save the rendering order for next time\n\tthis.renderedFragments = this.fragments.slice();\n}\n","import { SECTION, SECTION_UNLESS } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport shuffle from './prototype/shuffle';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nvar Section = function ( options ) {\n\tthis.type = SECTION;\n\tthis.subtype = this.currentSubtype = options.template.n;\n\tthis.inverted = this.subtype === SECTION_UNLESS;\n\n\n\tthis.pElement = options.pElement;\n\n\tthis.fragments = [];\n\tthis.fragmentsToCreate = [];\n\tthis.fragmentsToRender = [];\n\tthis.fragmentsToUnrender = [];\n\n\tif ( options.template.i ) {\n\t\tthis.indexRefs = options.template.i.split(',').map( ( k, i ) => {\n\t\t\treturn { n: k, t: i === 0 ? 'k' : 'i' };\n\t\t});\n\t}\n\n\tthis.renderedFragments = [];\n\n\tthis.length = 0; // number of times this section is rendered\n\n\tMustache.init( this, options );\n};\n\nSection.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetIndexRef: function( name ) {\n\t\tif ( this.indexRefs ) {\n\t\t\tlet i = this.indexRefs.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tlet ref = this.indexRefs[i];\n\t\t\t\tif ( ref.n === name ) {\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetValue: Mustache.getValue,\n\tshuffle: shuffle,\n\trebind: rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Section;\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\n\nvar elementCache = {}, ieBug, ieBlacklist;\n\ntry {\n\tcreateElement( 'table' ).innerHTML = 'foo';\n} catch ( err ) {\n\tieBug = true;\n\n\tieBlacklist = {\n\t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t};\n}\n\nexport default function ( html, node, docFrag ) {\n\tvar container, nodes = [], wrapper, selectedOption, child, i;\n\n\t// render 0 and false\n\tif ( html != null && html !== '' ) {\n\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t\t\tcontainer = container.querySelector( '.x' );\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\telse if ( node.namespaceURI === namespaces.svg ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\tcontainer = container.querySelector( '.x' );\n\t\t}\n\n\t\telse {\n\t\t\tcontainer = element( node.tagName );\n\t\t\tcontainer.innerHTML = html;\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\twhile ( child = container.firstChild ) {\n\t\t\tnodes.push( child );\n\t\t\tdocFrag.appendChild( child );\n\t\t}\n\n\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t// temporary container <select> causes the remaining ones to\n\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t// amaze me. You really do\n\t\t// ...and now Chrome too\n\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\ti = nodes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( nodes[i] !== selectedOption ) {\n\t\t\t\t\tnodes[i].selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes;\n}\n\nfunction element ( tagName ) {\n\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n}\n","export default function Triple$detach () {\n\tvar len, i;\n\n\tif ( this.docFrag ) {\n\t\tlen = this.nodes.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.docFrag.appendChild( this.nodes[i] );\n\t\t}\n\n\t\treturn this.docFrag;\n\t}\n}\n","export default function Triple$firstNode () {\n\tif ( this.rendered && this.nodes[0] ) {\n\t\treturn this.nodes[0];\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","import { TRIPLE } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport firstNode from './prototype/firstNode';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nimport unbind from '../shared/unbind';\n\nvar Triple = function ( options ) {\n\tthis.type = TRIPLE;\n\tMustache.init( this, options );\n};\n\nTriple.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfirstNode: firstNode,\n\tgetValue: Mustache.getValue,\n\trebind: Mustache.rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Triple;\n","var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\nsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\nsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\ncreateMap = function ( items ) {\n\tvar map = {}, i = items.length;\n\twhile ( i-- ) {\n\t\tmap[ items[i].toLowerCase() ] = items[i];\n\t}\n\treturn map;\n};\n\nmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\nexport default function ( elementName ) {\n\tvar lowerCaseElementName = elementName.toLowerCase();\n\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n}\n","export default function () {\n\tthis.parentFragment.bubble();\n}\n","export default function Element$detach () {\n\tvar node = this.node, parentNode;\n\n\tif ( node ) {\n\t\t// need to check for parent node - DOM may have been altered\n\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\tif ( parentNode = node.parentNode ) {\n\t\t\tparentNode.removeChild( node );\n\t\t}\n\n\t\treturn node;\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function ( selector ) {\n\tif ( !this.node ) {\n\t\t// this element hasn't been rendered yet\n\t\treturn null;\n\t}\n\n\tif ( matches( this.node, selector ) ) {\n\t\treturn this.node;\n\t}\n\n\tif ( this.fragment && this.fragment.find ) {\n\t\treturn this.fragment.find( selector );\n\t}\n}\n","export default function ( selector, query ) {\n\t// Add this node to the query, if applicable, and register the\n\t// query on this element\n\tif ( query._test( this, true ) && query.live ) {\n\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t}\n\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAll( selector, query );\n\t}\n}\n","export default function ( selector, query ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function ( selector ) {\n\tif ( this.fragment ) {\n\t\treturn this.fragment.findComponent( selector );\n\t}\n}\n","export default function Element$findNextNode () {\n\treturn null;\n}\n","export default function Element$firstNode () {\n\treturn this.node;\n}\n","export default function Element$getAttribute ( name ) {\n\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\treturn;\n\t}\n\n\treturn this.attributes[ name ].value;\n}\n","var truthy = /^true|on|yes|1$/i;\nvar isNumeric = /^[0-9]+$/;\n\nexport default function( element, template ) {\n\tvar val, attrs, attributes;\n\n\tattributes = template.a || {};\n\tattrs = {};\n\n\t// attributes that are present but don't have a value (=)\n\t// will be set to the number 0, which we condider to be true\n\t// the string '0', however is false\n\n\tval = attributes.twoway;\n\tif ( val !== undefined ) {\n\t\tattrs.twoway = val === 0 || truthy.test( val );\n\t}\n\n\tval = attributes.lazy;\n\tif ( val !== undefined ) {\n\t\t// check for timeout value\n\t\tif ( val !== 0 && isNumeric.test( val ) ) {\n\t\t\tattrs.lazy = parseInt( val );\n\t\t} else {\n\t\t\tattrs.lazy = val === 0 || truthy.test( val );\n\t\t}\n\t}\n\n\treturn attrs;\n}\n","import { namespaces } from 'config/environment';\nimport enforceCase from 'virtualdom/items/Element/shared/enforceCase';\n\nexport default function ( attribute, name ) {\n\tvar colonIndex, namespacePrefix;\n\n\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\tcolonIndex = name.indexOf( ':' );\n\tif ( colonIndex !== -1 ) {\n\n\t\t// looks like we are, yes...\n\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\n\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t// that only valid namespaces will be used)\n\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\tname = name.substring( colonIndex + 1 );\n\n\t\t\tattribute.name = enforceCase( name );\n\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\tattribute.namespacePrefix = namespacePrefix;\n\n\t\t\tif ( !attribute.namespace ) {\n\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// SVG attribute names are case sensitive\n\tattribute.name = ( attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name );\n}\n","export default function Attribute$rebind ( oldKeypath, newKeypath ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { namespaces } from 'config/environment';\n\n// the property name equivalents for element attributes, where they differ\n// from the lowercased attribute name\nvar propertyNames = {\n\t'accept-charset': 'acceptCharset',\n\t'accesskey': 'accessKey',\n\t'bgcolor': 'bgColor',\n\t'class': 'className',\n\t'codebase': 'codeBase',\n\t'colspan': 'colSpan',\n\t'contenteditable': 'contentEditable',\n\t'datetime': 'dateTime',\n\t'dirname': 'dirName',\n\t'for': 'htmlFor',\n\t'http-equiv': 'httpEquiv',\n\t'ismap': 'isMap',\n\t'maxlength': 'maxLength',\n\t'novalidate': 'noValidate',\n\t'pubdate': 'pubDate',\n\t'readonly': 'readOnly',\n\t'rowspan': 'rowSpan',\n\t'tabindex': 'tabIndex',\n\t'usemap': 'useMap'\n};\n\nexport default function Attribute$render ( node ) {\n\tvar propertyName;\n\n\tthis.node = node;\n\n\t// should we use direct property access, or setAttribute?\n\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\n\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\tthis.propertyName = propertyName;\n\t\t}\n\n\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\tif ( this.isBoolean || this.isTwoway ) {\n\t\t\tthis.useProperty = true;\n\t\t}\n\n\t\tif ( propertyName === 'value' ) {\n\t\t\tnode._ractive.value = this.value;\n\t\t}\n\t}\n\n\tthis.rendered = true;\n\tthis.update();\n}\n","export default function Attribute$toString () {\n\tvar { name, namespacePrefix, value, interpolator, fragment } = this;\n\n\t// Special case - select and textarea values (should not be stringified)\n\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\treturn;\n\t}\n\n\t// Special case - content editable\n\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\treturn;\n\t}\n\n\t// Special case - radio names\n\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\treturn 'name={{' + ( interpolator.keypath.str || interpolator.ref ) + '}}';\n\t}\n\n\t// Boolean attributes\n\tif ( this.isBoolean ) {\n\t\treturn value ? name : '';\n\t}\n\n\tif ( fragment ) {\n\t\t// special case - this catches undefined/null values (#1211)\n\t\tif ( fragment.items.length === 1 && fragment.items[0].value == null ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvalue = fragment.toString();\n\t}\n\n\tif ( namespacePrefix ) {\n\t\tname = namespacePrefix + ':' + name;\n\t}\n\n\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n}\n\nfunction escape ( value ) {\n\treturn value\n\t\t.replace( /&/g, '&amp;' )\n\t\t.replace( /\"/g, '&quot;' )\n\t\t.replace( /'/g, '&#39;' );\n}\n","export default function Attribute$unbind () {\n\t// ignore non-dynamic attributes\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.name === 'id' ) {\n\t\tdelete this.root.nodes[ this.value ];\n\t}\n}\n","export default function Attribute$updateSelect () {\n\tvar value = this.value, options, option, optionValue, i;\n\n\tif ( !this.locked ) {\n\t\tthis.node._ractive.value = value;\n\n\t\toptions = this.node.options;\n\t\ti = options.length;\n\n\t\twhile ( i-- ) {\n\t\t\toption = options[i];\n\t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\toption.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we're still here, it means the new value didn't match any of the options...\n\t// TODO figure out what to do in this situation\n}\n","export default function Attribute$updateRadioName () {\n\tvar { node, value } = this;\n\tnode.checked = ( value == node._ractive.value );\n}\n","export default function Attribute$updateIdAttribute () {\n\tvar { node, value } = this;\n\n\tthis.root.nodes[ value ] = node;\n\tnode.id = value;\n}\n","export default function Attribute$updateIEStyleAttribute () {\n\tvar node, value;\n\n\tnode = this.node;\n\tvalue = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tnode.style.setAttribute( 'cssText', value );\n}\n","export default function Attribute$updateContentEditableValue () {\n\tvar value = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tif ( !this.locked ) {\n\t\tthis.node.innerHTML = value;\n\t}\n}\n","export default function Attribute$updateValue () {\n\tvar { node, value } = this;\n\n\t// store actual value, so it doesn't get coerced to a string\n\tnode._ractive.value = value;\n\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tnode.value = ( value == undefined ? '' : value );\n\t}\n}\n","export default function Attribute$updateBooleanAttribute () {\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tthis.node[ this.propertyName ] = this.value;\n\t}\n}\n","export default function Attribute$updateEverythingElse () {\n\tvar { node, namespace, name, value, fragment } = this;\n\n\tif ( namespace ) {\n\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t}\n\n\telse if ( !this.isBoolean ) {\n\t\tif ( value == null ) {\n\t\t\tnode.removeAttribute( name );\n\t\t} else {\n\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t}\n\t}\n\n\t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n\telse {\n\t\tif ( value ) {\n\t\t\tnode.setAttribute( name, '' );\n\t\t} else {\n\t\t\tnode.removeAttribute( name );\n\t\t}\n\t}\n}\n","import bubble from './prototype/bubble';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport update from './prototype/update';\n\nvar Attribute = function ( options ) {\n\tthis.init( options );\n};\n\nAttribute.prototype = {\n\tbubble: bubble,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tupdate: update\n};\n\nexport default Attribute;\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport { toArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\n\nvar div;\n\nif ( typeof document !== 'undefined' ) {\n\tdiv = createElement( 'div' );\n}\n\nvar ConditionalAttribute = function ( element, template ) {\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\n\tthis.attributes = [];\n\n\tthis.fragment = new Fragment({\n\t\troot: element.root,\n\t\towner: this,\n\t\ttemplate: [ template ]\n\t});\n};\n\nConditionalAttribute.prototype = {\n\tbubble: function () {\n\t\tif ( this.node ) {\n\t\t\tthis.update();\n\t\t}\n\n\t\tthis.element.bubble();\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\trender: function ( node ) {\n\t\tthis.node = node;\n\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n\t\tthis.update();\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tupdate: function () {\n\t\tvar str, attrs;\n\n\t\tstr = this.fragment.toString();\n\t\tattrs = parseAttributes( str, this.isSvg );\n\n\t\t// any attributes that previously existed but no longer do\n\t\t// must be removed\n\t\tthis.attributes.filter( a => notIn( attrs, a ) ).forEach( a => {\n\t\t\tthis.node.removeAttribute( a.name );\n\t\t});\n\n\t\tattrs.forEach( a => {\n\t\t\tthis.node.setAttribute( a.name, a.value );\n\t\t});\n\n\t\tthis.attributes = attrs;\n\t},\n\n\ttoString: function () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default ConditionalAttribute;\n\n\nfunction parseAttributes ( str, isSvg ) {\n\tvar tag = isSvg ? 'svg' : 'div';\n\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\n\treturn toArray( div.childNodes[0].attributes );\n}\n\nfunction notIn ( haystack, needle ) {\n\tvar i = haystack.length;\n\n\twhile ( i-- ) {\n\t\tif ( haystack[i].name === needle.name ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","import Attribute from '../../Attribute/_Attribute';\n\nexport default function ( element, attributes ) {\n\tvar name, attribute, result = [];\n\n\tfor ( name in attributes ) {\n\t\t// skip binding attributes\n\t\tif ( name === 'twoway' || name === 'lazy') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\tattribute = new Attribute({\n\t\t\t\telement: element,\n\t\t\t\tname:    name,\n\t\t\t\tvalue:   attributes[ name ],\n\t\t\t\troot:    element.root\n\t\t\t});\n\n\t\t\tresult[ name ] = attribute;\n\n\t\t\tif ( name !== 'value' ) {\n\t\t\t\tresult.push( attribute );\n\t\t\t}\n\t\t}\n\t}\n\n\t// value attribute goes last. This is because it\n\t// may get clamped on render otherwise, e.g. in\n\t// `<input type='range' value='999' min='0' max='1000'>`\n\t// since default max is 100\n\tif ( attribute = result.value ) {\n\t\tresult.push( attribute );\n\t}\n\n\treturn result;\n}\n","import ConditionalAttribute from '../../ConditionalAttribute/_ConditionalAttribute';\n\nexport default function ( element, attributes ) {\n\tif ( !attributes ) {\n\t\treturn [];\n\t}\n\n\treturn attributes.map( a => {\n\t\treturn new ConditionalAttribute( element, a );\n\t});\n}\n","import runloop from 'global/runloop';\nimport { warnIfDebug, warnOnceIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { removeFromArray } from 'utils/array';\n\nvar Binding = function ( element ) {\n\tvar interpolator, keypath, value, parentForm;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.attribute = element.attributes[ this.name || 'value' ];\n\n\tinterpolator = this.attribute.interpolator;\n\tinterpolator.twowayBinding = this;\n\n\tif ( keypath = interpolator.keypath ) {\n\t\tif ( keypath.str.slice( -1 ) === '}' ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with expressions (`%s` on <%s>)', interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with %s', interpolator.resolver.ref, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\t}\n\n\telse {\n\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t//\n\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t// assumption. That assumption is that the input in question should\n\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t// and not `foo.bar`.\n\t\t//\n\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\tlet ref = interpolator.template.r ? `'${interpolator.template.r}' reference` : 'expression';\n\t\twarnIfDebug( 'The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity', ref, { ractive: this.root });\n\t\tinterpolator.resolver.forceResolution();\n\t\tkeypath = interpolator.keypath;\n\t}\n\n\tthis.attribute.isTwoway = true;\n\tthis.keypath = keypath;\n\n\t// initialise value, if it's undefined\n\tvalue = this.root.viewmodel.get( keypath );\n\n\tif ( value === undefined && this.getInitialValue ) {\n\t\tvalue = this.getInitialValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t}\n\t}\n\n\tif ( parentForm = findParentForm( element ) ) {\n\t\tthis.resetValue = value;\n\t\tparentForm.formBindings.push( this );\n\t}\n};\n\nBinding.prototype = {\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\t\tthis.attribute.locked = true;\n\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\trunloop.end();\n\t},\n\n\trebound: function () {\n\t\tvar bindings, oldKeypath, newKeypath;\n\n\t\toldKeypath = this.keypath;\n\t\tnewKeypath = this.attribute.interpolator.keypath;\n\n\t\t// The attribute this binding is linked to has already done the work\n\t\tif ( oldKeypath === newKeypath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath.str ], this );\n\n\t\tthis.keypath = newKeypath;\n\n\t\tbindings = this.root._twowayBindings[ newKeypath.str ] || ( this.root._twowayBindings[ newKeypath.str ] = [] );\n\t\tbindings.push( this );\n\t},\n\n\tunbind: function () {\n\t\t// this is called when the element is unbound.\n\t\t// Specialised bindings can override it\n\t}\n};\n\nBinding.extend = function ( properties ) {\n\tvar Parent = this, SpecialisedBinding;\n\n\tSpecialisedBinding = function ( element ) {\n\t\tBinding.call( this, element );\n\n\t\tif ( this.init ) {\n\t\t\tthis.init();\n\t\t}\n\t};\n\n\tSpecialisedBinding.prototype = create( Parent.prototype );\n\textend( SpecialisedBinding.prototype, properties );\n\n\tSpecialisedBinding.extend = Binding.extend;\n\n\treturn SpecialisedBinding;\n};\n\nexport default Binding;\n\nfunction findParentForm ( element ) {\n\twhile ( element = element.parent ) {\n\t\tif ( element.name === 'form' ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport { isNumeric } from 'utils/is';\n\nvar GenericBinding;\n\nGenericBinding = Binding.extend({\n\tgetInitialValue: () => '',\n\n\tgetValue: function () {\n\t\treturn this.element.node.value;\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, lazy, timeout = false;\n\t\tthis.rendered = true;\n\n\t\t// any lazy setting for this element overrides the root\n\t\t// if the value is a number, it's a timeout\n\t\tlazy = this.root.lazy;\n\t\tif ( this.element.lazy === true ) {\n\t\t\tlazy = true;\n\t\t} else if ( this.element.lazy === false ) {\n\t\t\tlazy = false;\n\t\t} else if ( isNumeric( this.element.lazy ) ) {\n\t\t\tlazy = false;\n\t\t\ttimeout = +this.element.lazy;\n\t\t} else if ( isNumeric( ( lazy || '' ) ) ) {\n\t\t\ttimeout = +lazy;\n\t\t\tlazy = false;\n\n\t\t\t// make sure the timeout is available to the handler\n\t\t\tthis.element.lazy = timeout;\n\t\t}\n\n\t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( !lazy ) {\n\t\t\tnode.addEventListener( 'input', this.handler, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\t\tthis.rendered = false;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t}\n});\n\nexport default GenericBinding;\n\n\nfunction handleBlur () {\n\tvar value;\n\n\thandleDomEvent.call( this );\n\n\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath );\n\tthis.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay () {\n\tvar binding = this._ractive.binding, el = this;\n\n\tif ( !!binding._timeout ) clearTimeout( binding._timeout );\n\n\tbinding._timeout = setTimeout( () => {\n\t\tif ( binding.rendered ) handleDomEvent.call( el );\n\t\tbinding._timeout = undefined;\n\t}, binding.element.lazy );\n}\n","import GenericBinding from './GenericBinding';\n\nvar ContentEditableBinding = GenericBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.innerHTML;\n\t}\n});\n\nexport default ContentEditableBinding;\n","var sets = {};\n\nexport default function getSiblings ( id, group, keypath ) {\n\tvar hash = id + group + keypath;\n\treturn sets[ hash ] || ( sets[ hash ] = [] );\n}\n","import runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar RadioBinding = Binding.extend({\n\tname: 'checked',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\tthis.siblings.push( this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\n\t\tthis.siblings.forEach( binding => {\n\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t});\n\n\t\trunloop.end();\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioBinding;\n","import { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport getSiblings from './shared/getSiblings';\n\nvar RadioNameBinding = Binding.extend({\n\tname: 'name',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n\t},\n\n\tgetInitialValue: function () {\n\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\treturn this.element.getAttribute( 'value' );\n\t\t}\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\tvar node = this.element.node;\n\t\treturn node._ractive ? node._ractive.value : node.value;\n\t},\n\n\thandleChange: function () {\n\t\t// If this <input> is the one that's checked, then the value of its\n\t\t// `name` keypath gets set to its value\n\t\tif ( this.element.node.checked ) {\n\t\t\tBinding.prototype.handleChange.call( this );\n\t\t}\n\t},\n\n\trebound: function ( oldKeypath, newKeypath ) {\n\t\tvar node;\n\n\t\tBinding.prototype.rebound.call( this, oldKeypath, newKeypath );\n\n\t\tif ( node = this.element.node ) {\n\t\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioNameBinding;\n","import { isArray } from 'utils/is';\nimport { arrayContains, removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxNameBinding = Binding.extend({\n\tname: 'name',\n\n\tgetInitialValue: function () {\n\t\t// This only gets called once per group (of inputs that\n\t\t// share a name), because it only gets called if there\n\t\t// isn't an initial value. By the same token, we can make\n\t\t// a note of that fact that there was no initial value,\n\t\t// and populate it using any `checked` attributes that\n\t\t// exist (which users should avoid, but which we should\n\t\t// support anyway to avoid breaking expectations)\n\t\tthis.noInitialValue = true;\n\t\treturn [];\n\t},\n\n\tinit: function () {\n\t\tvar existingValue, bindingValue;\n\n\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n\t\t// Each input has a reference to an array containing it and its\n\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t// the status of all inputs within the group\n\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tif ( this.noInitialValue ) {\n\t\t\tthis.siblings.noInitialValue = true;\n\t\t}\n\n\t\t// If no initial value was set, and this input is checked, we\n\t\t// update the model\n\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\t\texistingValue.push( bindingValue );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, existingValue, bindingValue;\n\n\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\tif ( isArray( existingValue ) ) {\n\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t} else {\n\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t}\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.isChecked;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t// in case of IE emergency, bind to click event as well\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tchanged: function () {\n\t\tvar wasChecked = !!this.isChecked;\n\t\tthis.isChecked = this.element.node.checked;\n\t\treturn this.isChecked === wasChecked;\n\t},\n\n\thandleChange: function () {\n\t\tthis.isChecked = this.element.node.checked;\n\t\tBinding.prototype.handleChange.call( this );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t}\n});\n\nfunction isChecked ( binding ) {\n\treturn binding.isChecked;\n}\n\nfunction getValue ( binding ) {\n\treturn binding.element.getAttribute( 'value' );\n}\n\nexport default CheckboxNameBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxBinding = Binding.extend({\n\tname: 'checked',\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t}\n});\n\nexport default CheckboxBinding;\n","import runloop from 'global/runloop';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar SelectBinding = Binding.extend({\n\tgetInitialValue: function () {\n\t\tvar options = this.element.options, len, i, value, optionWasSelected;\n\n\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\ti = len = options.length;\n\n\t\tif ( !len ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// take the final selected option...\n\t\twhile ( i-- ) {\n\t\t\tif ( options[i].getAttribute( 'selected' ) ) {\n\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\toptionWasSelected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// or the first non-disabled option, if none are selected\n\t\tif ( !optionWasSelected ) {\n\t\t\twhile ( ++i < len ) {\n\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t// other more expensive work\n\t\tif ( value !== undefined ) {\n\t\t\tthis.element.attributes.value.value = value;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\t// TODO this method is an anomaly... is it necessary?\n\tsetValue: function ( value ) {\n\t\tthis.root.viewmodel.set( this.keypath, value );\n\t},\n\n\tgetValue: function () {\n\t\tvar options, i, len, option, optionValue;\n\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( options[i].selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\treturn optionValue;\n\t\t\t}\n\t\t}\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t}\n});\n\nexport default SelectBinding;\n","import runloop from 'global/runloop';\nimport { arrayContentsMatch } from 'utils/array';\nimport SelectBinding from './SelectBinding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar MultipleSelectBinding = SelectBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.options\n\t\t\t.filter( option => option.getAttribute( 'selected' ) )\n\t\t\t.map( option => option.getAttribute( 'value' ) );\n\t},\n\n\trender: function () {\n\t\tvar valueFromModel;\n\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\n\t\tif ( valueFromModel === undefined ) {\n\t\t\t// get value from DOM, if possible\n\t\t\tthis.handleChange();\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tsetValue: function () {\n\t\tthrow new Error( 'TODO not implemented yet' );\n\t},\n\n\tgetValue: function () {\n\t\tvar selectedValues, options, i, len, option, optionValue;\n\n\t\tselectedValues = [];\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i=0; i<len; i+=1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( option.selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\tselectedValues.push( optionValue );\n\t\t\t}\n\t\t}\n\n\t\treturn selectedValues;\n\t},\n\n\thandleChange: function () {\n\t\tvar attribute, previousValue, value;\n\n\t\tattribute = this.attribute;\n\t\tpreviousValue = attribute.value;\n\n\t\tvalue = this.getValue();\n\n\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t},\n\n\tupdateModel: function () {\n\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t}\n\t}\n});\n\nexport default MultipleSelectBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar FileListBinding = Binding.extend({\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.files;\n\t}\n});\n\nexport default FileListBinding;\n","import GenericBinding from './GenericBinding';\n\nexport default GenericBinding.extend({\n\tgetInitialValue: () => undefined,\n\n\tgetValue: function () {\n\t\tvar value = parseFloat( this.element.node.value );\n\t\treturn isNaN( value ) ? undefined : value;\n\t}\n});\n","export default function EventHandler$bubble () {\n\tvar hasAction = this.getAction();\n\n\tif( hasAction && !this.hasListener ) {\n\t\tthis.listen();\n\t}\n\telse if ( !hasAction && this.hasListener ) {\n\t\tthis.unrender();\n\t}\n}\n","export default function EventHandler$getAction () {\n\treturn this.action.toString().trim();\n}\n","import getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport Fragment from 'virtualdom/Fragment';\nimport eventStack from 'Ractive/prototype/shared/eventStack';\nimport fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal } from 'utils/log';\n\nvar eventPattern = /^event(?:\\.(.+))?/;\n\nexport default function EventHandler$init ( element, name, template ) {\n\tvar action, refs, ractive;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\tthis.name = name;\n\n\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\tfatal( 'Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid', element.name, name );\n\t\tthis.invalid = true;\n\t}\n\n\tif ( template.m ) {\n\t\trefs = template.a.r;\n\n\t\t// This is a method call\n\t\tthis.method = template.m;\n\t\tthis.keypaths = [];\n\t\tthis.fn = getFunctionFromString( template.a.s, refs.length );\n\n\t\tthis.parentFragment = element.parentFragment;\n\t\tractive = this.root;\n\n\t\t// Create resolvers for each reference\n\t\tthis.refResolvers = [];\n\t\trefs.forEach(( ref, i ) => {\n\t\t\tlet match;\n\n\t\t\t// special case - the `event` object\n\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\tthis.keypaths[i] = {\n\t\t\t\t\teventObject: true,\n\t\t\t\t\trefinements: match[1] ? match[1].split( '.' ) : []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.refResolvers.push( createReferenceResolver( this, ref, keypath => this.resolve( i, keypath ) ) );\n\t\t\t}\n\t\t});\n\n\t\tthis.fire = fireMethodCall;\n\t}\n\n\telse {\n\t\t// Get action ('foo' in 'on-click='foo')\n\t\taction = template.n || template;\n\t\tif ( typeof action !== 'string' ) {\n\t\t\taction = new Fragment({\n\t\t\t\ttemplate: action,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tthis.action = action;\n\n\t\t// Get parameters\n\t\tif ( template.d ) {\n\t\t\tthis.dynamicParams = new Fragment({\n\t\t\t\ttemplate: template.d,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this.element\n\t\t\t});\n\n\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t} else if ( template.a ) {\n\t\t\tthis.params = template.a;\n\t\t\tthis.fire = fireEventWithParams;\n\t\t}\n\t}\n}\n\n\nfunction fireMethodCall ( event ) {\n\tvar ractive, values, args;\n\n\tractive = this.root;\n\n\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t}\n\n\tvalues = this.keypaths.map( function ( keypath ) {\n\t\tvar value, len, i;\n\n\t\tif ( keypath === undefined ) {\n\t\t\t// not yet resolved\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// TODO the refinements stuff would be better handled at parse time\n\t\tif ( keypath.eventObject ) {\n\t\t\tvalue = event;\n\n\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvalue = value[ keypath.refinements[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t}\n\n\t\treturn value;\n\t});\n\n\teventStack.enqueue( ractive, event );\n\n\targs = this.fn.apply( null, values );\n\tractive[ this.method ].apply( ractive, args );\n\n\teventStack.dequeue( ractive );\n}\n\nfunction fireEventWithParams ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event, args: this.params } );\n}\n\nfunction fireEventWithDynamicParams ( event ) {\n\tvar args = this.dynamicParams.getArgsList();\n\n\t// need to strip [] from ends if a string!\n\tif ( typeof args === 'string' ) {\n\t\targs = args.substr( 1, args.length - 2 );\n\t}\n\n\tfireEvent( this.root, this.getAction(), { event: event, args: args } );\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isJsdom } from 'config/environment';\nimport { missingPlugin } from 'config/errors';\nimport genericHandler from '../shared/genericHandler';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar customHandlers = {},\n\ttouchEvents = {\n\t\ttouchstart: true,\n\t\ttouchmove: true,\n\t\ttouchend: true,\n\t\ttouchcancel: true,\n\t\t//not w3c, but supported in some browsers\n\t\ttouchleave: true\n\t};\n\nexport default function EventHandler$listen () {\n\tvar definition, name = this.name;\n\n\tif ( this.invalid ) { return; }\n\n\tif ( definition = findInViewHierarchy( 'events', this.root, name ) ) {\n\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t} else {\n\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) && !isJsdom ) {\n\n\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\twarnOnceIfDebug( missingPlugin( name, 'event' ), { node: this.node });\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.addEventListener( name, genericHandler, false );\n\t}\n\n\tthis.hasListener = true;\n}\n\nfunction getCustomHandler ( name ) {\n\tif ( !customHandlers[ name ] ) {\n\t\tcustomHandlers[ name ] = function ( event ) {\n\t\t\tvar storage = event.node._ractive;\n\n\t\t\tevent.index = storage.index;\n\t\t\tevent.keypath = storage.keypath.str;\n\t\t\tevent.context = storage.root.viewmodel.get( storage.keypath );\n\n\t\t\tstorage.events[ name ].fire( event );\n\t\t};\n\t}\n\n\treturn customHandlers[ name ];\n}\n","export default function EventHandler$rebind ( oldKeypath, newKeypath ) {\n\tvar fragment;\n\tif ( this.method ) {\n\t\tfragment = this.element.parentFragment;\n\t\tthis.refResolvers.forEach( rebind );\n\n\t\treturn;\n\t}\n\n\tif ( typeof this.action !== 'string' ) {\n\t\trebind( this.action );\n\t}\n\n\tif ( this.dynamicParams ) {\n\t\trebind( this.dynamicParams );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing && thing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function EventHandler$render () {\n\tthis.node = this.element.node;\n\t// store this on the node itself, so it can be retrieved by a\n\t// universal handler\n\tthis.node._ractive.events[ this.name ] = this;\n\n\tif ( this.method || this.getAction() ) {\n\t\tthis.listen();\n\t}\n}\n","export default function EventHandler$resolve ( index, keypath ) {\n\tthis.keypaths[ index ] = keypath;\n}\n","import bubble from './prototype/bubble';\nimport fire from './prototype/fire';\nimport getAction from './prototype/getAction';\nimport init from './prototype/init';\nimport listen from './prototype/listen';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport resolve from './prototype/resolve';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar EventHandler = function ( element, name, template ) {\n\tthis.init( element, name, template );\n};\n\nEventHandler.prototype = {\n\tbubble: bubble,\n\tfire: fire,\n\tgetAction: getAction,\n\tinit: init,\n\tlisten: listen,\n\trebind: rebind,\n\trender: render,\n\tresolve: resolve,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default EventHandler;\n","import EventHandler from '../../EventHandler/_EventHandler';\n\nexport default function ( element, template ) {\n\tvar i, name, names, handler, result = [];\n\n\tfor ( name in template ) {\n\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\tnames = name.split( '-' );\n\t\t\ti = names.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\thandler = new EventHandler( element, names[i], template[ name ] );\n\t\t\t\tresult.push( handler );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n","import { fatal } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar Decorator = function ( element, template ) {\n\tvar self = this, ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no decorator\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = this.fragment.getArgsList();\n\n\t\tthis.fragment.bubble = function () {\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tself.params = this.getArgsList();\n\n\t\t\tif ( self.ready ) {\n\t\t\t\tself.update();\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.fn = findInViewHierarchy( 'decorators', ractive, name );\n\n\tif ( !this.fn ) {\n\t\tfatal( missingPlugin( name, 'decorator' ) );\n\t}\n};\n\nDecorator.prototype = {\n\tinit: function () {\n\t\tvar node, result, args;\n\n\t\tnode = this.element.node;\n\n\t\tif ( this.params ) {\n\t\t\targs = [ node ].concat( this.params );\n\t\t\tresult = this.fn.apply( this.root, args );\n\t\t} else {\n\t\t\tresult = this.fn.call( this.root, node );\n\t\t}\n\n\t\tif ( !result || !result.teardown ) {\n\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t}\n\n\t\t// TODO does this make sense?\n\t\tthis.actual = result;\n\t\tthis.ready = true;\n\t},\n\n\tupdate: function () {\n\t\tif ( this.actual.update ) {\n\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t}\n\n\t\telse {\n\t\t\tthis.actual.teardown( true );\n\t\t\tthis.init();\n\t\t}\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tteardown: function ( updating ) {\n\t\tthis.torndown = true;\n\t\tif ( this.ready ) {\n\t\t\tthis.actual.teardown();\n\t\t}\n\n\t\tif ( !updating && this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t}\n};\n\nexport default Decorator;\n","import { isClient, vendors } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\n\nvar prefix, prefixCache, testStyle;\n\nif ( !isClient ) {\n\tprefix = null;\n} else {\n\tprefixCache = {};\n\ttestStyle = createElement( 'div' ).style;\n\n\tprefix = function ( prop ) {\n\t\tvar i, vendor, capped;\n\n\t\tprop = camelCase( prop );\n\n\t\tif ( !prefixCache[ prop ] ) {\n\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// test vendors...\n\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[i];\n\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn prefixCache[ prop ];\n\t};\n}\n\nexport default prefix;\n","export default function ( hyphenatedStr ) {\n\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\treturn $1.toUpperCase();\n\t});\n}\n","import legacy from 'legacy';\nimport { isClient } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport prefix from '../helpers/prefix';\n\nvar getStyle, getComputedStyle;\n\nif ( !isClient ) {\n\tgetStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tgetStyle = function ( props ) {\n\t\tvar computedStyle, styles, i, prop, value;\n\n\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\tif ( typeof props === 'string' ) {\n\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( !isArray( props ) ) {\n\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t}\n\n\t\tstyles = {};\n\n\t\ti = props.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = props[i];\n\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tstyles[ prop ] = value;\n\t\t}\n\n\t\treturn styles;\n\t};\n}\n\nexport default getStyle;\n","import prefix from '../helpers/prefix';\n\nexport default function ( style, value ) {\n\tvar prop;\n\n\tif ( typeof style === 'string' ) {\n\t\tthis.node.style[ prefix( style ) ] = value;\n\t}\n\n\telse {\n\t\tfor ( prop in style ) {\n\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport getTime from 'utils/getTime';\nimport animations from 'shared/animations';\n\n// TODO what happens if a transition is aborted?\n// TODO use this with Animation to dedupe some code?\n\nvar Ticker = function ( options ) {\n\tvar easing;\n\n\tthis.duration = options.duration;\n\tthis.step = options.step;\n\tthis.complete = options.complete;\n\n\t// easing\n\tif ( typeof options.easing === 'string' ) {\n\t\teasing = options.root.easing[ options.easing ];\n\n\t\tif ( !easing ) {\n\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t\t\teasing = linear;\n\t\t}\n\t} else if ( typeof options.easing === 'function' ) {\n\t\teasing = options.easing;\n\t} else {\n\t\teasing = linear;\n\t}\n\n\tthis.easing = easing;\n\n\tthis.start = getTime();\n\tthis.end = this.start + this.duration;\n\n\tthis.running = true;\n\tanimations.add( this );\n};\n\nTicker.prototype = {\n\ttick: function ( now ) {\n\t\tvar elapsed, eased;\n\n\t\tif ( !this.running ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( now > this.end ) {\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( 1 );\n\t\t\t}\n\n\t\t\tif ( this.complete ) {\n\t\t\t\tthis.complete( 1 );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\telapsed = now - this.start;\n\t\teased = this.easing( elapsed / this.duration );\n\n\t\tif ( this.step ) {\n\t\t\tthis.step( eased );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tstop: function () {\n\t\tif ( this.abort ) {\n\t\t\tthis.abort();\n\t\t}\n\n\t\tthis.running = false;\n\t}\n};\n\nexport default Ticker;\nfunction linear ( t ) { return t; }\n","import { isClient } from 'config/environment';\nimport { warnIfDebug } from 'utils/log';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\nimport interpolate from 'shared/interpolate';\nimport Ticker from 'shared/Ticker';\nimport prefix from '../../helpers/prefix';\nimport unprefix from '../../helpers/unprefix';\nimport hyphenate from '../../helpers/hyphenate';\n\nvar createTransitions,\n\ttestStyle,\n\tTRANSITION,\n\tTRANSITIONEND,\n\tCSS_TRANSITIONS_ENABLED,\n\tTRANSITION_DURATION,\n\tTRANSITION_PROPERTY,\n\tTRANSITION_TIMING_FUNCTION,\n\tcanUseCssTransitions = {},\n\tcannotUseCssTransitions = {};\n\nif ( !isClient ) {\n\tcreateTransitions = null;\n} else {\n\ttestStyle = createElement( 'div' ).style;\n\n\t// determine some facts about our environment\n\t(function() {\n\t\tif ( testStyle.transition !== undefined ) {\n\t\t\tTRANSITION = 'transition';\n\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\tTRANSITION = 'webkitTransition';\n\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else {\n\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t}\n\t}());\n\n\tif ( TRANSITION ) {\n\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t}\n\n\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t// TODO use a fastdom-style mechanism?\n\t\tsetTimeout( function () {\n\n\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n\t\t\tcheckComplete = function () {\n\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t// which properties\n\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\tt.node.style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n\t\t\ttransitionEndHandler = function ( event ) {\n\t\t\t\tvar index;\n\n\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t// still transitioning...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\tsetTimeout( function () {\n\t\t\t\tvar i = changedProperties.length, hash, originalValue, index, propertiesToTransitionInJs = [], prop, suffix;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\thash = hashPrefix + prop;\n\n\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\n\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\n\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t// javascript transitions\n\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\tvar prop, i;\n\n\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t}\n\n\n\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}, 0 );\n\t\t}, options.delay || 0 );\n\t};\n}\n\nexport default createTransitions;\n","import { vendors } from 'config/environment';\n\nvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\nexport default function ( prop ) {\n\treturn prop.replace( unprefixPattern, '' );\n}\n","import { vendors } from 'config/environment';\n\nvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\nexport default function ( str ) {\n\tvar hyphenated;\n\n\tif ( !str ) {\n\t\treturn ''; // edge case\n\t}\n\n\tif ( vendorPattern.test( str ) ) {\n\t\tstr = '-' + str;\n\t}\n\n\thyphenated = str.replace( /[A-Z]/g, function ( match ) {\n\t\treturn '-' + match.toLowerCase();\n\t});\n\n\treturn hyphenated;\n}\n","import { vendors } from 'config/environment';\n\nvar hidden, vendor, prefix, i, visibility;\n\nif ( typeof document !== 'undefined' ) {\n\thidden = 'hidden';\n\n\tvisibility = {};\n\n\tif ( hidden in document ) {\n\t\tprefix = '';\n\t} else {\n\t\ti = vendors.length;\n\t\twhile ( i-- ) {\n\t\t\tvendor = vendors[i];\n\t\t\thidden = vendor + 'Hidden';\n\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = vendor;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( prefix !== undefined ) {\n\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\n\t\t// initialise\n\t\tonChange();\n\t}\n\n\telse {\n        // gah, we're in an old browser\n        if ( 'onfocusout' in document ) {\n        \tdocument.addEventListener( 'focusout', onHide );\n        \tdocument.addEventListener( 'focusin', onShow );\n        }\n\n        else {\n        \twindow.addEventListener( 'pagehide', onHide );\n        \twindow.addEventListener( 'blur', onHide );\n\n        \twindow.addEventListener( 'pageshow', onShow );\n        \twindow.addEventListener( 'focus', onShow );\n        }\n\n        visibility.hidden = false; // until proven otherwise. Not ideal but hey\n    }\n}\n\nfunction onChange () {\n\tvisibility.hidden = document[ hidden ];\n}\n\nfunction onHide () {\n\tvisibility.hidden = true;\n}\n\nfunction onShow () {\n\tvisibility.hidden = false;\n}\n\nexport default visibility;\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isClient } from 'config/environment';\nimport legacy from 'legacy';\nimport prefix from 'virtualdom/items/Element/Transition/helpers/prefix';\nimport Promise from 'utils/Promise';\nimport createTransitions from './createTransitions';\nimport visibility from './visibility';\n\nvar animateStyle, getComputedStyle, resolved;\n\nif ( !isClient ) {\n\tanimateStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tanimateStyle = function ( style, value, options ) {\n\t\tvar to;\n\n\t\tif ( arguments.length === 4 ) {\n\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t}\n\n\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t// that way you'll never get CSS transitionend events\n\t\tif ( visibility.hidden ) {\n\t\t\tthis.setStyle( style, value );\n\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t}\n\n\t\tif ( typeof style === 'string' ) {\n\t\t\tto = {};\n\t\t\tto[ style ] = value;\n\t\t} else {\n\t\t\tto = style;\n\n\t\t\t// shuffle arguments\n\t\t\toptions = value;\n\t\t}\n\n\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t// callback function that gets called after the animation completes\n\n\t\t// TODO remove this check in a future version\n\t\tif ( !options ) {\n\t\t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\toptions = this;\n\t\t}\n\n\t\tvar promise = new Promise( resolve => {\n\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\tif ( !options.duration ) {\n\t\t\t\tthis.setStyle( to );\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get a list of the properties we're animating\n\t\t\tpropertyNames = Object.keys( to );\n\t\t\tchangedProperties = [];\n\n\t\t\t// Store the current styles\n\t\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\t\tfrom = {};\n\t\t\ti = propertyNames.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = propertyNames[i];\n\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\n\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\tcurrent = 0;\n\t\t\t\t}\n\n\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\tchangedProperties.push( prop );\n\n\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\tthis.node.style[ prefix( prop ) ] = current;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t// will never fire! So we complete early\n\t\t\tif ( !changedProperties.length ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTransitions( this, to, options, changedProperties, resolve );\n\t\t});\n\n\t\treturn promise;\n\t};\n}\n\nexport default animateStyle;\n","import { fillGaps } from 'utils/object';\n\nexport default function ( params, defaults ) {\n\tif ( typeof params === 'number' ) {\n\t\tparams = { duration: params };\n\t}\n\n\telse if ( typeof params === 'string' ) {\n\t\tif ( params === 'slow' ) {\n\t\t\tparams = { duration: 600 };\n\t\t} else if ( params === 'fast' ) {\n\t\t\tparams = { duration: 200 };\n\t\t} else {\n\t\t\tparams = { duration: 400 };\n\t\t}\n\t} else if ( !params ) {\n\t\tparams = {};\n\t}\n\n\treturn fillGaps( {}, params, defaults );\n}\n","export default function Transition$start () {\n\tvar node, originalStyle, completed;\n\n\tnode = this.node = this.element.node;\n\toriginalStyle = node.getAttribute( 'style' );\n\n\t// create t.complete() - we don't want this on the prototype,\n\t// because we don't want `this` silliness when passing it as\n\t// an argument\n\tthis.complete = noReset => {\n\t\tif ( completed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !noReset && this.isIntro ) {\n\t\t\tresetStyle( node, originalStyle);\n\t\t}\n\n\t\tnode._ractive.transition = null;\n\t\tthis._manager.remove( this );\n\n\t\tcompleted = true;\n\t};\n\n\t// If the transition function doesn't exist, abort\n\tif ( !this._fn ) {\n\t\tthis.complete();\n\t\treturn;\n\t}\n\n\tthis._fn.apply( this.root, [ this ].concat( this.params ) );\n}\n\nfunction resetStyle ( node, style ) {\n\tif ( style ) {\n\t\tnode.setAttribute( 'style', style );\n\t} else {\n\n\t\t// Next line is necessary, to remove empty style attribute!\n\t\t// See http://stackoverflow.com/a/7167553\n\t\tnode.getAttribute( 'style' );\n\t\tnode.removeAttribute( 'style' );\n\t}\n}\n","import init from './prototype/init';\nimport getStyle from './prototype/getStyle';\nimport setStyle from './prototype/setStyle';\nimport animateStyle from './prototype/animateStyle/_animateStyle';\nimport processParams from './prototype/processParams';\nimport start from './prototype/start';\n\nvar Transition = function ( owner, template, isIntro ) {\n\tthis.init( owner, template, isIntro );\n};\n\nTransition.prototype = {\n\tinit: init,\n\tstart: start,\n\tgetStyle: getStyle,\n\tsetStyle: setStyle,\n\tanimateStyle: animateStyle,\n\tprocessParams: processParams\n};\n\nexport default Transition;\n","import { namespaces } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport { warnIfDebug } from 'utils/log';\nimport { create, defineProperty } from 'utils/object';\nimport { createElement } from 'utils/dom';\nimport noop from 'utils/noop';\nimport runloop from 'global/runloop';\nimport getInnerContext from 'shared/getInnerContext';\nimport { render as renderImage } from '../special/img';\nimport { render as renderForm } from '../special/form';\nimport Transition from '../Transition/_Transition';\n\nvar updateCss, updateScript;\n\nupdateCss = function () {\n\tvar node = this.node, content = this.fragment.toString( false );\n\n\t// IE8 has no styleSheet unless there's a type text/css\n\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\tnode.type = 'text/css';\n\t}\n\n\tif ( node.styleSheet ) {\n\t\tnode.styleSheet.cssText = content;\n\t} else {\n\n\t\twhile ( node.hasChildNodes() ) {\n\t\t\tnode.removeChild( node.firstChild );\n\t\t}\n\n\t\tnode.appendChild( document.createTextNode(content) );\n\t}\n};\n\nupdateScript = function () {\n\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\twarnIfDebug( 'Script tag was updated. This does not cause the code to be re-evaluated!', { ractive: this.root });\n\t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n\t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n\t\t// But this would be a terrible idea with unpredictable results, so let's not.\n\t}\n\n\tthis.node.text = this.fragment.toString( false );\n};\n\nexport default function Element$render () {\n\tvar root = this.root, namespace, node, transition;\n\n\tnamespace = getNamespace( this );\n\tnode = this.node = createElement( this.name, namespace );\n\n\t// Is this a top-level node of a component? If so, we may need to add\n\t// a data-ractive-css attribute, for CSS encapsulation\n\tif ( this.parentFragment.cssIds ) {\n\t\tthis.node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( x => `{${x}}` ).join( ' ' ) );\n\t}\n\n\t// Add _ractive property to the node - we use this object to store stuff\n\t// related to proxy events, two-way bindings etc\n\tdefineProperty( this.node, '_ractive', {\n\t\tvalue: {\n\t\t\tproxy: this,\n\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\tevents: create( null ),\n\t\t\troot: root\n\t\t}\n\t});\n\n\t// Render attributes\n\tthis.attributes.forEach( a => a.render( node ) );\n\tthis.conditionalAttributes.forEach( a => a.render( node ) );\n\n\t// Render children\n\tif ( this.fragment ) {\n\t\t// Special case - <script> element\n\t\tif ( this.name === 'script' ) {\n\t\t\tthis.bubble = updateScript;\n\t\t\tthis.node.text = this.fragment.toString( false ); // bypass warning initially\n\t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n\t\t}\n\n\t\t// Special case - <style> element\n\t\telse if ( this.name === 'style' ) {\n\t\t\tthis.bubble = updateCss;\n\t\t\tthis.bubble();\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\t// Special case - contenteditable\n\t\telse if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\telse {\n\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\t// deal with two-way bindings\n\tif ( this.binding ) {\n\t\tthis.binding.render();\n\t\tthis.node._ractive.binding = this.binding;\n\t}\n\n\t// Add proxy event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( h => h.render() );\n\t}\n\n\tif ( this.name === 'option' ) {\n\t\tprocessOption( this );\n\t}\n\n\t// Special cases\n\tif ( this.name === 'img' ) {\n\t\t// if this is an <img>, and we're in a crap browser, we may\n\t\t// need to prevent it from overriding width and height when\n\t\t// it loads the src\n\t\trenderImage( this );\n\t} else if ( this.name === 'form' ) {\n\t\t// forms need to keep track of their bindings, in case of reset\n\t\trenderForm( this );\n\t} else if ( this.name === 'input' || this.name === 'textarea' ) {\n\t\t// inputs and textareas should store their initial value as\n\t\t// `defaultValue` in case of reset\n\t\tthis.node.defaultValue = this.node.value;\n\t} else if ( this.name === 'option' ) {\n\t\t// similarly for option nodes\n\t\tthis.node.defaultSelected = this.node.selected;\n\t}\n\n\t// apply decorator(s)\n\tif ( this.decorator && this.decorator.fn ) {\n\t\trunloop.scheduleTask( () => {\n\t\t\tif ( !this.decorator.torndown ) {\n\t\t\t\tthis.decorator.init();\n\t\t\t}\n\t\t}, true );\n\t}\n\n\t// trigger intro transition\n\tif ( root.transitionsEnabled && this.intro ) {\n\t\ttransition = new Transition ( this, this.intro, true );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start(), true );\n\n\t\tthis.transition = transition;\n\t}\n\n\tif ( this.node.autofocus ) {\n\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\trunloop.scheduleTask( () => this.node.focus(), true );\n\t}\n\n\tupdateLiveQueries( this );\n\treturn this.node;\n}\n\nfunction getNamespace ( element ) {\n\tvar namespace, xmlns, parent;\n\n\t// Use specified namespace...\n\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\tnamespace = xmlns;\n\t}\n\n\t// ...or SVG namespace, if this is an <svg> element\n\telse if ( element.name === 'svg' ) {\n\t\tnamespace = namespaces.svg;\n\t}\n\n\telse if ( parent = element.parent ) {\n\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\tnamespace = namespaces.html;\n\t\t}\n\n\t\t// ...or inherit from the parent node\n\t\telse {\n\t\t\tnamespace = parent.node.namespaceURI;\n\t\t}\n\t}\n\n\telse {\n\t\tnamespace = element.root.el.namespaceURI;\n\t}\n\n\treturn namespace;\n}\n\nfunction processOption ( option ) {\n\tvar optionValue, selectValue, i;\n\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\tselectValue = option.select.getAttribute( 'value' );\n\tif ( selectValue === undefined ) {\n\t\treturn;\n\t}\n\n\toptionValue = option.getAttribute( 'value' );\n\n\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( optionValue == selectValue[i] ) {\n\t\t\t\toption.node.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toption.node.selected = ( optionValue == selectValue );\n\t}\n}\n\nfunction updateLiveQueries ( element ) {\n\tvar instance, liveQueries, i, selector, query;\n\n\t// Does this need to be added to any live queries?\n\tinstance = element.root;\n\n\tdo {\n\t\tliveQueries = instance._liveQueries;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tselector = liveQueries[i];\n\t\t\tquery = liveQueries[ '_' + selector ];\n\n\t\t\tif ( query._test( element ) ) {\n\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t}\n\t\t}\n\t} while ( instance = instance.parent );\n}\n","import { escapeHtml, voidElementNames } from 'utils/html';\nimport { isArray } from 'utils/is';\n\nexport default function () {\n\tvar str, escape;\n\n\tif ( this.template.y ) {\n\t\t// DOCTYPE declaration\n\t\treturn '<!DOCTYPE' + this.template.dd + '>';\n\t}\n\n\tstr = '<' + this.template.e;\n\n\tstr += this.attributes.map( stringifyAttribute ).join( '' )\n\t     + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\n\t// Special case - selected options\n\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\tstr += ' selected';\n\t}\n\n\t// Special case - two-way radio name bindings\n\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\tstr += ' checked';\n\t}\n\n\tstr += '>';\n\n\t// Special case - textarea\n\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t}\n\n\t// Special case - contenteditable\n\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t}\n\n\tif ( this.fragment ) {\n\t\tescape = ( this.name !== 'script' && this.name !== 'style' );\n\t\tstr += this.fragment.toString( escape );\n\t}\n\n\t// add a closing tag if this isn't a void element\n\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\tstr += '</' + this.template.e + '>';\n\t}\n\n\treturn str;\n}\n\nfunction optionIsSelected ( element ) {\n\tvar optionValue, selectValue, i;\n\n\toptionValue = element.getAttribute( 'value' );\n\n\tif ( optionValue === undefined || !element.select ) {\n\t\treturn false;\n\t}\n\n\tselectValue = element.select.getAttribute( 'value' );\n\n\tif ( selectValue == optionValue ) {\n\t\treturn true;\n\t}\n\n\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction inputIsCheckedRadio ( element ) {\n\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n\tattributes = element.attributes;\n\n\ttypeAttribute  = attributes.type;\n\tvalueAttribute = attributes.value;\n\tnameAttribute  = attributes.name;\n\n\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\treturn;\n\t}\n\n\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\treturn true;\n\t}\n}\n\nfunction stringifyAttribute ( attribute ) {\n\tvar str = attribute.toString();\n\treturn str ? ' ' + str : '';\n}\n","import bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport getAttribute from './prototype/getAttribute';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Element = function ( options ) {\n\tthis.init( options );\n};\n\nElement.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetAttribute: getAttribute,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Element;\n","import { lastItem } from 'utils/array';\n\nvar empty = /^\\s*$/, leadingWhitespace = /^\\s*/;\n\nexport default function ( str ) {\n\tvar lines, firstLine, lastLine, minIndent;\n\n\tlines = str.split( '\\n' );\n\n\t// remove first and last line, if they only contain whitespace\n\tfirstLine = lines[0];\n\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\tlines.shift();\n\t}\n\n\tlastLine = lastItem( lines );\n\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\tlines.pop();\n\t}\n\n\tminIndent = lines.reduce( reducer, null );\n\n\tif ( minIndent ) {\n\t\tstr = lines.map( function ( line ) {\n\t\t\treturn line.replace( minIndent, '' );\n\t\t}).join( '\\n' );\n\t}\n\n\treturn str;\n}\n\nfunction reducer ( previous, line ) {\n\tvar lineIndent = leadingWhitespace.exec( line )[0];\n\n\tif ( previous === null || ( lineIndent.length < previous.length ) ) {\n\t\treturn lineIndent;\n\t}\n\n\treturn previous;\n}\n","export default function ( string, indent ) {\n\tvar indented;\n\n\tif ( !indent ) {\n\t\treturn string;\n\t}\n\n\tindented = string.split( '\\n' ).map( function ( line, notFirstLine ) {\n\t\treturn notFirstLine ? indent + line : line;\n\t}).join( '\\n' );\n\n\treturn indented;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { PARTIAL, TEXT } from 'config/types';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\nimport Mustache from '../shared/Mustache/_Mustache';\nimport rebind from '../shared/Mustache/rebind';\nimport unbind from '../shared/unbind';\nimport getPartialTemplate from './getPartialTemplate';\nimport applyIndent from './applyIndent';\n\nlet missingPartialMessage = 'Could not find template for partial \"%s\"';\n\nlet Partial = function ( options ) {\n\tvar parentFragment, template;\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\n\tthis.root = parentFragment.root;\n\tthis.type = PARTIAL;\n\tthis.index = options.index;\n\tthis.name = options.template.r;\n\tthis.rendered = false;\n\n\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n\tMustache.init( this, options );\n\n\t// If this didn't resolve, it most likely means we have a named partial\n\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t// whose name is the value of `foo`')\n\tif ( !this.keypath ) {\n\t\tif ( template = getPartialTemplate( this.root, this.name, parentFragment ) ) {\n\t\t\tunbind.call( this ); // prevent any further changes\n\t\t\tthis.isNamed = true;\n\t\t\tthis.setTemplate( template );\n\t\t} else {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name );\n\t\t}\n\t}\n};\n\nPartial.prototype = {\n\tbubble () {\n\t\tthis.parentFragment.bubble();\n\t},\n\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tfindNextNode () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t},\n\n\tgetPartialName () {\n\t\tif ( this.isNamed && this.name ) return this.name;\n\t\telse if ( this.value === undefined ) return this.name;\n\t\telse return this.value;\n\t},\n\n\tgetValue () {\n\t\treturn this.fragment.getValue();\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// named partials aren't bound, so don't rebind\n\t\tif ( !this.isNamed ) {\n\t\t\trebind.call( this, oldKeypath, newKeypath );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\trender () {\n\t\tthis.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\n\t\tthis.rendered = true;\n\t\treturn this.docFrag;\n\t},\n\n\tresolve: Mustache.resolve,\n\n\tsetValue ( value ) {\n\t\tvar template;\n\n\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t// nothing has changed, so no work to be done\n\t\t\treturn;\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\ttemplate = getPartialTemplate( this.root, '' + value, this.parentFragment );\n\t\t}\n\n\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t// and a partial. In those cases, this becomes a named partial\n\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name, this.parentFragment ) ) ) {\n\t\t\tunbind.call( this );\n\t\t\tthis.isNamed = true;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name, { ractive: this.root });\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.setTemplate( template || [] );\n\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tsetTemplate ( template ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t}\n\t\t}\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate,\n\t\t\troot: this.root,\n\t\t\towner: this,\n\t\t\tpElement: this.parentFragment.pElement\n\t\t});\n\n\t\tthis.fragmentToRender = this.fragment;\n\t},\n\n\ttoString ( toString ) {\n\t\tvar string, previousItem, lastLine, match;\n\n\t\tstring = this.fragment.toString( toString );\n\n\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\n\t\tif ( !previousItem || ( previousItem.type !== TEXT ) ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\n\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\treturn applyIndent( string, match[0] );\n\t\t}\n\n\t\treturn string;\n\t},\n\n\tunbind () {\n\t\tif ( !this.isNamed ) { // dynamic partial - need to unbind self\n\t\t\tunbind.call( this );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( this.rendered ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t}\n\t},\n\n\tupdate() {\n\t\tvar target, anchor;\n\n\t\tif ( this.fragmentToUnrender ) {\n\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\tthis.fragmentToUnrender = null;\n\t\t}\n\n\t\tif ( this.fragmentToRender ) {\n\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\tthis.fragmentToRender = null;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t}\n};\n\nexport default Partial;\n","import runloop from 'global/runloop';\nimport { defineProperty } from 'utils/object';\nimport getNewIndices from 'shared/getNewIndices';\nimport processWrapper from './processWrapper';\n\nvar patchedArrayProto = [],\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ],\n\ttestObj,\n\tpatchArrayMethods,\n\tunpatchArrayMethods;\n\nmutatorMethods.forEach( function ( methodName ) {\n\tvar method = function ( ...args ) {\n\t\tvar newIndices,\n\t\t\tresult,\n\t\t\twrapper,\n\t\t\ti;\n\n\t\tnewIndices = getNewIndices( this, methodName, args );\n\n\t\t// apply the underlying method\n\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t// trigger changes\n\t\trunloop.start();\n\n\t\tthis._ractive.setting = true;\n\t\ti = this._ractive.wrappers.length;\n\t\twhile ( i-- ) {\n\t\t\twrapper = this._ractive.wrappers[i];\n\n\t\t\trunloop.addRactive( wrapper.root );\n\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tthis._ractive.setting = false;\n\t\treturn result;\n\t};\n\n\tdefineProperty( patchedArrayProto, methodName, {\n\t\tvalue: method\n\t});\n});\n\n// can we use prototype chain injection?\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\ntestObj = {};\n\nif ( testObj.__proto__ ) {\n\t// yes, we can\n\tpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = patchedArrayProto;\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = Array.prototype;\n\t};\n}\n\nelse {\n\t// no, we can't\n\tpatchArrayMethods = function ( array ) {\n\t\tvar i, methodName;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tmethodName = mutatorMethods[i];\n\t\t\tdefineProperty( array, methodName, {\n\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tvar i;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t}\n\t};\n}\n\npatchArrayMethods.unpatch = unpatchArrayMethods;\nexport default patchArrayMethods;\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Component$detach () {\n\tvar detached = this.instance.fragment.detach();\n\tdetachHook.fire( this.instance );\n\treturn detached;\n}\n","export default function Component$find ( selector ) {\n\treturn this.instance.fragment.find( selector );\n}\n","export default function Component$findAll ( selector, query ) {\n\treturn this.instance.fragment.findAll( selector, query );\n}\n","export default function Component$findAllComponents ( selector, query ) {\n\tquery._test( this, true );\n\n\tif ( this.instance.fragment ) {\n\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function Component$findComponent ( selector ) {\n\tif ( !selector || ( selector === this.name ) ) {\n\t\treturn this.instance;\n\t}\n\n\tif ( this.instance.fragment ) {\n\t\treturn this.instance.fragment.findComponent( selector );\n\t}\n\n\treturn null;\n}\n","export default function Component$findNextNode () {\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Component$firstNode () {\n\tif ( this.rendered ) {\n\t\treturn this.instance.fragment.firstNode();\n\t}\n\n\treturn null;\n}\n","export default function ( wrapper, array, methodName, newIndices ) {\n\tvar { root, keypath } = wrapper;\n\n\tif ( !!newIndices ) {\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t} else {\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\troot.viewmodel.mark( keypath );\n\t}\n}\n","import { default as templateConfigurator } from 'Ractive/config/custom/template/template';\nimport Fragment from 'virtualdom/Fragment';\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nexport default function Ractive$resetTemplate ( template ) {\n\tvar transitionsEnabled, component;\n\n\ttemplateConfigurator.init( null, this, { template: template });\n\n\ttransitionsEnabled = this.transitionsEnabled;\n\tthis.transitionsEnabled = false;\n\n\t// Is this is a component, we need to set the `shouldDestroy`\n\t// flag, otherwise it will assume by default that a parent node\n\t// will be detached, and therefore it doesn't need to bother\n\t// detaching its own nodes\n\tif ( component = this.component ) {\n\t\tcomponent.shouldDestroy = true;\n\t}\n\n\tthis.unrender();\n\n\tif ( component ) {\n\t\tcomponent.shouldDestroy = false;\n\t}\n\n\t// remove existing fragment and create new one\n\tthis.fragment.unbind();\n\tthis.fragment = new Fragment({\n\t\ttemplate: this.template,\n\t\troot: this,\n\t\towner: this\n\t});\n\n\tthis.render( this.el, this.anchor );\n\n\tthis.transitionsEnabled = transitionsEnabled;\n}\n","import { isObject } from 'utils/is';\nimport { getMatchingKeypaths, getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\n\nexport default function Ractive$set ( keypath, value ) {\n\tvar map, promise;\n\n\tpromise = runloop.start( this, true );\n\n\t// Set multiple keypaths in one go\n\tif ( isObject( keypath ) ) {\n\t\tmap = keypath;\n\n\t\tfor ( keypath in map ) {\n\t\t\tif ( map.hasOwnProperty( keypath) ) {\n\t\t\t\tvalue = map[ keypath ];\n\t\t\t\tset( this, keypath, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set a single keypath\n\telse {\n\t\tset( this, keypath, value );\n\t}\n\n\trunloop.end();\n\n\treturn promise;\n}\n\nfunction set ( ractive, keypath, value ) {\n\tkeypath = getKeypath( normalise( keypath ) );\n\n\tif ( keypath.isPattern ) {\n\t\tgetMatchingKeypaths( ractive, keypath ).forEach( keypath => {\n\t\t\tractive.viewmodel.set( keypath, value );\n\t\t});\n\t} else {\n\t\tractive.viewmodel.set( keypath, value );\n\t}\n}","import add from './shared/add';\n\nexport default function Ractive$subtract ( keypath, d ) {\n\treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n}\n","import { badArguments } from 'config/errors';\nimport { getKeypath, getMatchingKeypaths, normalise } from 'shared/keypaths';\n\nexport default function Ractive$toggle ( keypath ) {\n\tif ( typeof keypath !== 'string' ) {\n\t\tthrow new TypeError( badArguments );\n\t}\n\n\tlet changes;\n\n\tif ( /\\*/.test( keypath ) ) {\n\t\tchanges = {};\n\n\t\tgetMatchingKeypaths( this, getKeypath( normalise( keypath ) ) ).forEach( keypath => {\n\t\t\tchanges[ keypath.str ] = !this.viewmodel.get( keypath );\n\t\t});\n\n\t\treturn this.set( changes );\n\t}\n\n\treturn this.set( keypath, !this.get( keypath ) );\n}\n","import { arrayContentsMatch } from 'utils/array';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\n\nexport default function Ractive$updateModel ( keypath, cascade ) {\n\tvar values, key, bindings;\n\n\tif ( typeof keypath === 'string' && !cascade ) {\n\t\tbindings = this._twowayBindings[ keypath ];\n\t} else {\n\t\tbindings = [];\n\n\t\tfor ( key in this._twowayBindings ) {\n\t\t\tif ( !keypath || getKeypath( key ).equalsOrStartsWith( keypath ) ) { // TODO is this right?\n\t\t\t\tbindings.push.apply( bindings, this._twowayBindings[ key ]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalues = consolidate( this, bindings );\n\treturn this.set( values );\n}\n\nfunction consolidate ( ractive, bindings ) {\n\tvar values = {}, checkboxGroups = [];\n\n\tbindings.forEach( b => {\n\t\tvar oldValue, newValue;\n\n\t\t// special case - radio name bindings\n\t\tif ( b.radioName && !b.element.node.checked ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - checkbox name bindings come in groups, so\n\t\t// we want to get the value once at most\n\t\tif ( b.checkboxName ) {\n\t\t\tif ( !checkboxGroups[ b.keypath.str ] && !b.changed() ) {\n\t\t\t\tcheckboxGroups.push( b.keypath );\n\t\t\t\tcheckboxGroups[ b.keypath.str ] = b;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\toldValue = b.attribute.value;\n\t\tnewValue = b.getValue();\n\n\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\tvalues[ b.keypath.str ] = newValue;\n\t\t}\n\t});\n\n\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\tif ( checkboxGroups.length ) {\n\t\tcheckboxGroups.forEach( keypath => {\n\t\t\tvar binding, oldValue, newValue;\n\n\t\t\tbinding = checkboxGroups[ keypath.str ]; // one to represent the entire group\n\t\t\toldValue = binding.attribute.value;\n\t\t\tnewValue = binding.getValue();\n\n\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\tvalues[ keypath.str ] = newValue;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn values;\n}\n","import wrap from 'utils/wrapMethod';\nimport registries from 'Ractive/config/registries';\nimport Ractive from 'Ractive';\n\nexport default function unwrap ( Child ) {\n\tlet options = {};\n\n\twhile ( Child ) {\n\t\taddRegistries( Child, options );\n\t\taddOtherOptions( Child, options );\n\n\t\tif ( Child._Parent !== Ractive ) {\n\t\t\tChild = Child._Parent;\n\t\t} else {\n\t\t\tChild = false;\n\t\t}\n\t}\n\n\treturn options;\n}\n\nfunction addRegistries ( Child, options ) {\n\tregistries.forEach( r => {\n\t\taddRegistry(\n\t\t\tr.useDefaults ? Child.prototype : Child,\n\t\t\toptions, r.name );\n\t});\n}\n\nfunction addRegistry ( target, options, name ) {\n\tvar registry, keys = Object.keys( target[ name ] );\n\n\tif ( !keys.length ) { return; }\n\n\tif ( !( registry = options[ name ] ) ) {\n\t\tregistry = options[ name ] = {};\n\t}\n\n\tkeys\n\t\t.filter( key => !( key in registry ) )\n\t\t.forEach( key => registry[ key ] = target[ name ][ key ] );\n}\n\nfunction addOtherOptions ( Child, options ) {\n\tObject.keys( Child.prototype ).forEach( key => {\n\t\tif ( key === 'computed' ) { return; }\n\n\t\tvar value = Child.prototype[ key ];\n\n\t\tif ( !( key in options ) ) {\n\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t}\n\n\t\t// is it a wrapped function?\n\t\telse if ( typeof options[ key ] === 'function'\n\t\t\t\t&& typeof value === 'function'\n\t\t\t\t&& options[ key ]._method ) {\n\n\t\t\tlet result, needsSuper = value._method;\n\n\t\t\tif ( needsSuper ) { value = value._method; }\n\n\t\t\t// rewrap bound directly to parent fn\n\t\t\tresult = wrap( options[ key ]._method, value );\n\n\t\t\tif ( needsSuper ) { result._method = result; }\n\n\t\t\toptions[ key ] = result;\n\t\t}\n\t});\n}","export var TEMPLATE_VERSION = 3;","/*global console, navigator */\nvar isClient, isJsdom, hasConsole, magic, namespaces, svg, vendors;\n\nisClient = ( typeof document === 'object' );\n\nisJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );\n\nhasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\tmagic = true;\n} catch ( e ) {\n\tmagic = false;\n}\n\nnamespaces = {\n\thtml:   'http://www.w3.org/1999/xhtml',\n\tmathml: 'http://www.w3.org/1998/Math/MathML',\n\tsvg:    'http://www.w3.org/2000/svg',\n\txlink:  'http://www.w3.org/1999/xlink',\n\txml:    'http://www.w3.org/XML/1998/namespace',\n\txmlns:  'http://www.w3.org/2000/xmlns/'\n};\n\nif ( typeof document === 'undefined' ) {\n\tsvg = false;\n} else {\n\tsvg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );\n}\n\nvendors = [ 'o', 'ms', 'moz', 'webkit' ];\n\nexport { isClient, isJsdom, hasConsole, magic, namespaces, svg, vendors };","import { TEMPLATE_VERSION } from 'config/template';\n\nvar defaultOptions = {\n\n\t// render placement:\n\tel:                 void 0,\n\tappend:\t\t\t\tfalse,\n\n\t// template:\n\ttemplate:           { v: TEMPLATE_VERSION, t: [] },\n\n\t// parse:     // TODO static delimiters?\n\tpreserveWhitespace: false,\n\tsanitize:           false,\n\tstripComments:      true,\n\tdelimiters:         [ '{{', '}}' ],\n\ttripleDelimiters:   [ '{{{', '}}}' ],\n\tinterpolate:        false,\n\n\t// data & binding:\n\tdata:               {},\n\tcomputed:           {},\n\tmagic:              false,\n\tmodifyArrays:       true,\n\tadapt:              [],\n\tisolated:           false,\n\ttwoway:             true,\n\tlazy:               false,\n\n\t// transitions:\n\tnoIntro:            false,\n\ttransitionsEnabled: true,\n\tcomplete:           void 0,\n\n\t// css:\n\tcss:                null,\n\tnoCssTransform:     false\n};\n\nexpo