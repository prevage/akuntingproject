{"version":3,"file":"ractive-legacy.runtime.min.js","sources":["../src/virtualdom/items/Element/prototype/toString.js","../src/virtualdom/items/Element/_Element.js","../src/virtualdom/items/Partial/deIndent.js","../src/virtualdom/items/Partial/applyIndent.js","../src/virtualdom/items/Partial/_Partial.js","../src/Ractive/static/adaptors/array/patch.js","../src/virtualdom/items/Component/prototype/detach.js","../src/virtualdom/items/Component/prototype/find.js","../src/virtualdom/items/Component/prototype/findAll.js","../src/virtualdom/items/Component/prototype/findAllComponents.js","../src/virtualdom/items/Component/prototype/findComponent.js","../src/virtualdom/items/Component/prototype/findNextNode.js","../src/virtualdom/items/Component/prototype/firstNode.js","../src/Ractive/static/adaptors/array/processWrapper.js","../src/Ractive/static/adaptors/array/index.js","../src/Ractive/static/adaptors/magic.js","../src/utils/createBranch.js","../src/Ractive/static/adaptors/magicArray.js","../src/viewmodel/prototype/adapt.js","../src/viewmodel/prototype/applyChanges/notifyPatternObservers.js","../src/viewmodel/prototype/capture.js","../src/viewmodel/prototype/clearCache.js","../src/viewmodel/Computation/UnresolvedDependency.js","../src/viewmodel/Computation/Computation.js","../src/viewmodel/prototype/get.js","../src/viewmodel/prototype/init.js","../src/viewmodel/prototype/map.js","../src/viewmodel/prototype/mark.js","../src/viewmodel/prototype/merge/mapOldToNewIndex.js","../src/viewmodel/prototype/merge.js","../src/viewmodel/prototype/register.js","../src/viewmodel/prototype/release.js","../src/viewmodel/prototype/reset.js","../src/viewmodel/prototype/smartUpdate.js","../src/viewmodel/prototype/teardown.js","../src/viewmodel/Viewmodel.js","../src/Ractive/prototype/shared/hooks/HookQueue.js","../src/Ractive/helpers/getComputationSignatures.js","../src/Ractive/initialise.js","../src/virtualdom/items/Component/initialise/ComplexParameter.js","../src/virtualdom/items/Component/initialise/createInstance.js","../src/virtualdom/items/Component/initialise/updateLiveQueries.js","../src/virtualdom/items/Component/prototype/rebind.js","../src/virtualdom/items/Component/prototype/render.js","../src/virtualdom/items/Component/prototype/toString.js","../src/virtualdom/items/Component/prototype/unbind.js","../src/virtualdom/items/Component/prototype/unrender.js","../src/virtualdom/items/Component/_Component.js","../src/virtualdom/items/Comment.js","../src/virtualdom/items/Yielder.js","../src/virtualdom/items/Doctype.js","../src/virtualdom/Fragment/prototype/render.js","../src/virtualdom/Fragment/prototype/toString.js","../src/virtualdom/Fragment/prototype/unbind.js","../src/virtualdom/Fragment/prototype/unrender.js","../src/virtualdom/Fragment.js","../src/Ractive.js","../src/Ractive/prototype/reset.js","../src/Ractive/prototype/resetPartial.js","../src/Ractive/prototype/reverse.js","../src/Ractive/prototype/shift.js","../src/Ractive/prototype/sort.js","../src/Ractive/prototype/splice.js","../src/Ractive/prototype/teardown.js","../src/Ractive/prototype/toHTML.js","../src/Ractive/prototype/unrender.js","../src/Ractive/prototype/unshift.js","../src/Ractive/prototype/update.js","../src/Ractive/prototype.js","../src/utils/wrapMethod.js","../src/extend/_extend.js","../src/Ractive/static/getNodeInfo.js","../src/utils/parseJSON.js","../src/utils/html.js","../src/virtualdom/Fragment/prototype/shared/processItems.js","../src/virtualdom/Fragment/prototype/getNode.js","../src/virtualdom/items/shared/detach.js","../src/virtualdom/items/Text.js","../src/virtualdom/items/shared/Mustache/getValue.js","../src/virtualdom/items/shared/Resolvers/ReferenceResolver.js","../src/virtualdom/items/shared/Resolvers/SpecialResolver.js","../src/virtualdom/items/shared/Resolvers/IndexResolver.js","../src/virtualdom/items/shared/Resolvers/findIndexRefs.js","../src/virtualdom/items/shared/Resolvers/ExpressionResolver.js","../src/shared/getFunctionFromString.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js","../src/virtualdom/items/shared/Mustache/resolve.js","../src/virtualdom/items/shared/Mustache/rebind.js","../src/virtualdom/items/shared/Mustache/_Mustache.js","../src/virtualdom/items/Interpolator.js","../src/virtualdom/items/Section/prototype/bubble.js","../src/virtualdom/items/Section/prototype/detach.js","../src/virtualdom/items/Section/prototype/find.js","../src/virtualdom/items/Section/prototype/findAll.js","../src/virtualdom/items/Section/prototype/findComponent.js","../src/virtualdom/items/Section/prototype/findNextNode.js","../src/virtualdom/items/Section/prototype/firstNode.js","../src/virtualdom/items/Section/prototype/rebind.js","../src/virtualdom/items/Section/prototype/render.js","../src/virtualdom/items/Section/prototype/toString.js","../src/virtualdom/items/Section/prototype/unrender.js","../src/virtualdom/items/Section/prototype/update.js","../src/virtualdom/items/Section/_Section.js","../src/virtualdom/items/Triple/helpers/insertHtml.js","../src/virtualdom/items/Triple/prototype/detach.js","../src/virtualdom/items/Triple/prototype/firstNode.js","../src/virtualdom/items/Triple/_Triple.js","../src/virtualdom/items/Element/shared/enforceCase.js","../src/virtualdom/items/Element/prototype/bubble.js","../src/virtualdom/items/Element/prototype/detach.js","../src/virtualdom/items/Element/prototype/find.js","../src/virtualdom/items/Element/prototype/findAll.js","../src/virtualdom/items/Element/prototype/findAllComponents.js","../src/virtualdom/items/Element/prototype/findComponent.js","../src/virtualdom/items/Element/prototype/findNextNode.js","../src/virtualdom/items/Element/prototype/firstNode.js","../src/virtualdom/items/Element/prototype/getAttribute.js","../src/virtualdom/items/Element/prototype/init/processBindingAttributes.js","../src/virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js","../src/virtualdom/items/Element/Attribute/prototype/rebind.js","../src/virtualdom/items/Element/Attribute/prototype/render.js","../src/virtualdom/items/Element/Attribute/prototype/toString.js","../src/virtualdom/items/Element/Attribute/prototype/unbind.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js","../src/virtualdom/items/Element/Attribute/_Attribute.js","../src/virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js","../src/virtualdom/items/Element/prototype/init/createAttributes.js","../src/virtualdom/items/Element/prototype/init/createConditionalAttributes.js","../src/virtualdom/items/Element/Binding/Binding.js","../src/virtualdom/items/Element/Binding/GenericBinding.js","../src/virtualdom/items/Element/Binding/ContentEditableBinding.js","../src/virtualdom/items/Element/Binding/shared/getSiblings.js","../src/virtualdom/items/Element/Binding/RadioBinding.js","../src/virtualdom/items/Element/Binding/RadioNameBinding.js","../src/virtualdom/items/Element/Binding/CheckboxNameBinding.js","../src/virtualdom/items/Element/Binding/CheckboxBinding.js","../src/virtualdom/items/Element/Binding/SelectBinding.js","../src/virtualdom/items/Element/Binding/MultipleSelectBinding.js","../src/virtualdom/items/Element/Binding/FileListBinding.js","../src/virtualdom/items/Element/Binding/NumericBinding.js","../src/virtualdom/items/Element/EventHandler/prototype/bubble.js","../src/virtualdom/items/Element/EventHandler/prototype/getAction.js","../src/virtualdom/items/Element/EventHandler/prototype/init.js","../src/virtualdom/items/Element/EventHandler/prototype/listen.js","../src/virtualdom/items/Element/EventHandler/prototype/rebind.js","../src/virtualdom/items/Element/EventHandler/prototype/render.js","../src/virtualdom/items/Element/EventHandler/prototype/resolve.js","../src/virtualdom/items/Element/EventHandler/_EventHandler.js","../src/virtualdom/items/Element/prototype/init/createEventHandlers.js","../src/virtualdom/items/Element/Decorator/_Decorator.js","../src/virtualdom/items/Element/Transition/helpers/prefix.js","../src/utils/camelCase.js","../src/virtualdom/items/Element/Transition/prototype/getStyle.js","../src/virtualdom/items/Element/Transition/prototype/setStyle.js","../src/shared/Ticker.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js","../src/virtualdom/items/Element/Transition/helpers/unprefix.js","../src/virtualdom/items/Element/Transition/helpers/hyphenate.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js","../src/virtualdom/items/Element/Transition/prototype/processParams.js","../src/virtualdom/items/Element/Transition/prototype/start.js","../src/virtualdom/items/Element/Transition/_Transition.js","../src/virtualdom/items/Element/prototype/render.js","../src/Ractive/prototype/resetTemplate.js","../src/Ractive/prototype/set.js","../src/Ractive/prototype/subtract.js","../src/Ractive/prototype/toggle.js","../src/Ractive/prototype/updateModel.js","../src/extend/unwrapExtended.js","../src/config/template.js","../src/config/environment.js","../src/Ractive/config/defaults.js","../src/Ractive/static/easing.js","../src/utils/dom.js","../src/utils/noop.js","../src/legacy.js","../src/utils/object.js","../src/utils/log.js","../src/utils/is.js","../src/config/errors.js","../src/shared/interpolate.js","../src/Ractive/static/interpolators.js","../src/utils/getPotentialWildcardMatches.js","../src/shared/keypaths.js","../src/utils/requestAnimationFrame.js","../src/Ractive/prototype/shared/add.js","../src/utils/getTime.js","../src/Ractive/prototype/shared/hooks/Hook.js","../src/utils/Promise.js","../src/shared/getInnerContext.js","../src/global/TransitionManager.js","../src/global/runloop.js","../src/shared/animations.js","../src/Ractive/prototype/animate/Animation.js","../src/Ractive/prototype/animate.js","../src/Ractive/prototype/detach.js","../src/Ractive/prototype/find.js","../src/Ractive/prototype/shared/makeQuery/cancel.js","../src/Ractive/prototype/shared/makeQuery/sortByItemPosition.js","../src/Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js","../src/Ractive/prototype/shared/makeQuery/sort.js","../src/Ractive/prototype/shared/makeQuery/dirty.js","../src/Ractive/prototype/shared/makeQuery/remove.js","../src/Ractive/prototype/findComponent.js","../src/Ractive/prototype/findParent.js","../src/Ractive/prototype/shared/eventStack.js","../src/Ractive/prototype/get.js","../src/Ractive/prototype/insert.js","../src/Ractive/prototype/observe/Observer.js","../src/Ractive/prototype/observe/PatternObserver.js","../src/global/css.js","../src/Ractive/prototype/observe/getObserverFacade.js","../src/Ractive/prototype/observeOnce.js","../src/Ractive/prototype/shared/trim.js","../src/Ractive/prototype/shared/notEmptyString.js","../src/Ractive/prototype/once.js","../src/Ractive/prototype/shared/makeArrayMethod.js","../src/Ractive/prototype/pop.js","../src/Ractive/prototype/push.js","../src/Ractive/config/registries.js","../src/Ractive/prototype/render.js","../src/Ractive/config/custom/adapt.js","../src/Ractive/config/custom/css/transform.js","../src/Ractive/config/custom/css/css.js","../src/Ractive/config/custom/data.js","../src/Ractive/config/custom/template/parser.js","../src/Ractive/config/custom/template/template.js","../src/Ractive/config/config.js","../src/parse/Parser.js","../src/virtualdom/Fragment/prototype/bubble.js","../src/virtualdom/Fragment/prototype/detach.js","../src/virtualdom/Fragment/prototype/find.js","../src/virtualdom/Fragment/prototype/findAll.js","../src/virtualdom/Fragment/prototype/findAllComponents.js","../src/virtualdom/Fragment/prototype/findComponent.js","../src/virtualdom/Fragment/prototype/findNextNode.js","../src/virtualdom/Fragment/prototype/firstNode.js","../src/parse/converters/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js","../src/config/types.js","../src/parse/converters/expressions/primary/literal/readStringLiteral.js","../src/parse/converters/expressions/primary/literal/readNumberLiteral.js","../src/parse/converters/expressions/shared/patterns.js","../src/parse/converters/expressions/shared/readKey.js","../src/virtualdom/items/Triple/prototype/update.js","../src/virtualdom/items/Element/Attribute/prototype/bubble.js","../src/virtualdom/items/Element/Attribute/helpers/getInterpolator.js","../src/virtualdom/items/Element/Attribute/prototype/init.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateClassName.js","../src/virtualdom/items/Element/Attribute/prototype/update.js","../src/virtualdom/items/Element/Binding/shared/handleDomEvent.js","../src/virtualdom/items/Element/prototype/init/createTwowayBinding.js","../src/virtualdom/items/Element/EventHandler/prototype/fire.js","../src/virtualdom/items/Element/EventHandler/shared/genericHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/unbind.js","../src/virtualdom/items/Element/EventHandler/prototype/unrender.js","../src/virtualdom/items/Element/special/select.js","../src/virtualdom/items/Element/special/option.js","../src/virtualdom/items/Element/prototype/init.js","../src/virtualdom/items/Element/prototype/rebind.js","../src/virtualdom/items/Element/special/img.js","../src/virtualdom/items/Element/special/form.js","../src/virtualdom/items/Element/Transition/prototype/init.js","../src/virtualdom/items/Element/prototype/unbind.js","../src/virtualdom/items/Element/prototype/unrender.js","../src/virtualdom/items/Partial/getPartialTemplate.js","../src/virtualdom/items/Component/getComponent.js","../src/viewmodel/helpers/getUpstreamChanges.js","../src/viewmodel/prototype/applyChanges.js","../src/viewmodel/prototype/compute.js","../src/viewmodel/prototype/set.js","../src/viewmodel/prototype/unregister.js","../src/virtualdom/items/Component/initialise/propagateEvents.js","../src/virtualdom/items/Component/prototype/init.js","../src/virtualdom/Fragment/prototype/init.js","../src/virtualdom/Fragment/prototype/rebind.js","../src/shared/registry.js","../src/Ractive/prototype/add.js","../src/utils/array.js","../src/shared/resolveRef.js","../src/shared/methodCallers.js","../src/Ractive/prototype/shared/makeQuery/test.js","../src/Ractive/prototype/shared/makeQuery/_makeQuery.js","../src/Ractive/prototype/findAll.js","../src/Ractive/prototype/findAllComponents.js","../src/Ractive/prototype/findContainer.js","../src/Ractive/prototype/shared/fireEvent.js","../src/Ractive/prototype/fire.js","../src/Ractive/prototype/merge.js","../src/Ractive/prototype/observe/getPattern.js","../src/Ractive/prototype/observe.js","../src/Ractive/prototype/off.js","../src/Ractive/prototype/on.js","../src/shared/getNewIndices.js","../src/Ractive/config/wrapPrototypeMethod.js","../src/Ractive/config/deprecate.js","../src/virtualdom/Fragment/prototype/getArgsList.js","../src/virtualdom/Fragment/prototype/getValue.js","../src/virtualdom/items/shared/unbind.js","../src/virtualdom/items/shared/Resolvers/createReferenceResolver.js","../src/virtualdom/items/shared/Mustache/initialise.js","../src/virtualdom/items/Section/prototype/findAllComponents.js","../src/virtualdom/items/Section/prototype/shuffle.js","../src/virtualdom/items/Section/prototype/setValue.js","../src/virtualdom/items/Section/prototype/unbind.js","../src/virtualdom/items/Triple/prototype/find.js","../src/virtualdom/items/Triple/prototype/findAll.js","../src/virtualdom/items/Triple/helpers/updateSelect.js","../src/virtualdom/items/Triple/prototype/render.js","../src/virtualdom/items/Triple/prototype/setValue.js","../src/virtualdom/items/Triple/prototype/toString.js","../src/virtualdom/items/Triple/prototype/unrender.js"],"sourcesContent":["import { escapeHtml, voidElementNames } from 'utils/html';\nimport { isArray } from 'utils/is';\n\nexport default function () {\n\tvar str, escape;\n\n\tif ( this.template.y ) {\n\t\t// DOCTYPE declaration\n\t\treturn '<!DOCTYPE' + this.template.dd + '>';\n\t}\n\n\tstr = '<' + this.template.e;\n\n\tstr += this.attributes.map( stringifyAttribute ).join( '' )\n\t     + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\n\t// Special case - selected options\n\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\tstr += ' selected';\n\t}\n\n\t// Special case - two-way radio name bindings\n\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\tstr += ' checked';\n\t}\n\n\tstr += '>';\n\n\t// Special case - textarea\n\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t}\n\n\t// Special case - contenteditable\n\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t}\n\n\tif ( this.fragment ) {\n\t\tescape = ( this.name !== 'script' && this.name !== 'style' );\n\t\tstr += this.fragment.toString( escape );\n\t}\n\n\t// add a closing tag if this isn't a void element\n\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\tstr += '</' + this.template.e + '>';\n\t}\n\n\treturn str;\n}\n\nfunction optionIsSelected ( element ) {\n\tvar optionValue, selectValue, i;\n\n\toptionValue = element.getAttribute( 'value' );\n\n\tif ( optionValue === undefined || !element.select ) {\n\t\treturn false;\n\t}\n\n\tselectValue = element.select.getAttribute( 'value' );\n\n\tif ( selectValue == optionValue ) {\n\t\treturn true;\n\t}\n\n\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction inputIsCheckedRadio ( element ) {\n\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n\tattributes = element.attributes;\n\n\ttypeAttribute  = attributes.type;\n\tvalueAttribute = attributes.value;\n\tnameAttribute  = attributes.name;\n\n\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\treturn;\n\t}\n\n\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\treturn true;\n\t}\n}\n\nfunction stringifyAttribute ( attribute ) {\n\tvar str = attribute.toString();\n\treturn str ? ' ' + str : '';\n}\n","import bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport getAttribute from './prototype/getAttribute';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Element = function ( options ) {\n\tthis.init( options );\n};\n\nElement.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetAttribute: getAttribute,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Element;\n","import { lastItem } from 'utils/array';\n\nvar empty = /^\\s*$/, leadingWhitespace = /^\\s*/;\n\nexport default function ( str ) {\n\tvar lines, firstLine, lastLine, minIndent;\n\n\tlines = str.split( '\\n' );\n\n\t// remove first and last line, if they only contain whitespace\n\tfirstLine = lines[0];\n\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\tlines.shift();\n\t}\n\n\tlastLine = lastItem( lines );\n\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\tlines.pop();\n\t}\n\n\tminIndent = lines.reduce( reducer, null );\n\n\tif ( minIndent ) {\n\t\tstr = lines.map( function ( line ) {\n\t\t\treturn line.replace( minIndent, '' );\n\t\t}).join( '\\n' );\n\t}\n\n\treturn str;\n}\n\nfunction reducer ( previous, line ) {\n\tvar lineIndent = leadingWhitespace.exec( line )[0];\n\n\tif ( previous === null || ( lineIndent.length < previous.length ) ) {\n\t\treturn lineIndent;\n\t}\n\n\treturn previous;\n}\n","export default function ( string, indent ) {\n\tvar indented;\n\n\tif ( !indent ) {\n\t\treturn string;\n\t}\n\n\tindented = string.split( '\\n' ).map( function ( line, notFirstLine ) {\n\t\treturn notFirstLine ? indent + line : line;\n\t}).join( '\\n' );\n\n\treturn indented;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { PARTIAL, TEXT } from 'config/types';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\nimport Mustache from '../shared/Mustache/_Mustache';\nimport rebind from '../shared/Mustache/rebind';\nimport unbind from '../shared/unbind';\nimport getPartialTemplate from './getPartialTemplate';\nimport applyIndent from './applyIndent';\n\nlet missingPartialMessage = 'Could not find template for partial \"%s\"';\n\nlet Partial = function ( options ) {\n\tvar parentFragment, template;\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\n\tthis.root = parentFragment.root;\n\tthis.type = PARTIAL;\n\tthis.index = options.index;\n\tthis.name = options.template.r;\n\tthis.rendered = false;\n\n\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n\tMustache.init( this, options );\n\n\t// If this didn't resolve, it most likely means we have a named partial\n\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t// whose name is the value of `foo`')\n\tif ( !this.keypath ) {\n\t\tif ( template = getPartialTemplate( this.root, this.name, parentFragment ) ) {\n\t\t\tunbind.call( this ); // prevent any further changes\n\t\t\tthis.isNamed = true;\n\t\t\tthis.setTemplate( template );\n\t\t} else {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name );\n\t\t}\n\t}\n};\n\nPartial.prototype = {\n\tbubble () {\n\t\tthis.parentFragment.bubble();\n\t},\n\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tfindNextNode () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t},\n\n\tgetPartialName () {\n\t\tif ( this.isNamed && this.name ) return this.name;\n\t\telse if ( this.value === undefined ) return this.name;\n\t\telse return this.value;\n\t},\n\n\tgetValue () {\n\t\treturn this.fragment.getValue();\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// named partials aren't bound, so don't rebind\n\t\tif ( !this.isNamed ) {\n\t\t\trebind.call( this, oldKeypath, newKeypath );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\trender () {\n\t\tthis.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\n\t\tthis.rendered = true;\n\t\treturn this.docFrag;\n\t},\n\n\tresolve: Mustache.resolve,\n\n\tsetValue ( value ) {\n\t\tvar template;\n\n\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t// nothing has changed, so no work to be done\n\t\t\treturn;\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\ttemplate = getPartialTemplate( this.root, '' + value, this.parentFragment );\n\t\t}\n\n\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t// and a partial. In those cases, this becomes a named partial\n\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name, this.parentFragment ) ) ) {\n\t\t\tunbind.call( this );\n\t\t\tthis.isNamed = true;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name, { ractive: this.root });\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.setTemplate( template || [] );\n\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tsetTemplate ( template ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t}\n\t\t}\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate,\n\t\t\troot: this.root,\n\t\t\towner: this,\n\t\t\tpElement: this.parentFragment.pElement\n\t\t});\n\n\t\tthis.fragmentToRender = this.fragment;\n\t},\n\n\ttoString ( toString ) {\n\t\tvar string, previousItem, lastLine, match;\n\n\t\tstring = this.fragment.toString( toString );\n\n\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\n\t\tif ( !previousItem || ( previousItem.type !== TEXT ) ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\n\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\treturn applyIndent( string, match[0] );\n\t\t}\n\n\t\treturn string;\n\t},\n\n\tunbind () {\n\t\tif ( !this.isNamed ) { // dynamic partial - need to unbind self\n\t\t\tunbind.call( this );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( this.rendered ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t}\n\t},\n\n\tupdate() {\n\t\tvar target, anchor;\n\n\t\tif ( this.fragmentToUnrender ) {\n\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\tthis.fragmentToUnrender = null;\n\t\t}\n\n\t\tif ( this.fragmentToRender ) {\n\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\tthis.fragmentToRender = null;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t}\n};\n\nexport default Partial;\n","import runloop from 'global/runloop';\nimport { defineProperty } from 'utils/object';\nimport getNewIndices from 'shared/getNewIndices';\nimport processWrapper from './processWrapper';\n\nvar patchedArrayProto = [],\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ],\n\ttestObj,\n\tpatchArrayMethods,\n\tunpatchArrayMethods;\n\nmutatorMethods.forEach( function ( methodName ) {\n\tvar method = function ( ...args ) {\n\t\tvar newIndices,\n\t\t\tresult,\n\t\t\twrapper,\n\t\t\ti;\n\n\t\tnewIndices = getNewIndices( this, methodName, args );\n\n\t\t// apply the underlying method\n\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t// trigger changes\n\t\trunloop.start();\n\n\t\tthis._ractive.setting = true;\n\t\ti = this._ractive.wrappers.length;\n\t\twhile ( i-- ) {\n\t\t\twrapper = this._ractive.wrappers[i];\n\n\t\t\trunloop.addRactive( wrapper.root );\n\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tthis._ractive.setting = false;\n\t\treturn result;\n\t};\n\n\tdefineProperty( patchedArrayProto, methodName, {\n\t\tvalue: method\n\t});\n});\n\n// can we use prototype chain injection?\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\ntestObj = {};\n\nif ( testObj.__proto__ ) {\n\t// yes, we can\n\tpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = patchedArrayProto;\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = Array.prototype;\n\t};\n}\n\nelse {\n\t// no, we can't\n\tpatchArrayMethods = function ( array ) {\n\t\tvar i, methodName;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tmethodName = mutatorMethods[i];\n\t\t\tdefineProperty( array, methodName, {\n\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tvar i;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t}\n\t};\n}\n\npatchArrayMethods.unpatch = unpatchArrayMethods;\nexport default patchArrayMethods;\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Component$detach () {\n\tvar detached = this.instance.fragment.detach();\n\tdetachHook.fire( this.instance );\n\treturn detached;\n}\n","export default function Component$find ( selector ) {\n\treturn this.instance.fragment.find( selector );\n}\n","export default function Component$findAll ( selector, query ) {\n\treturn this.instance.fragment.findAll( selector, query );\n}\n","export default function Component$findAllComponents ( selector, query ) {\n\tquery._test( this, true );\n\n\tif ( this.instance.fragment ) {\n\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function Component$findComponent ( selector ) {\n\tif ( !selector || ( selector === this.name ) ) {\n\t\treturn this.instance;\n\t}\n\n\tif ( this.instance.fragment ) {\n\t\treturn this.instance.fragment.findComponent( selector );\n\t}\n\n\treturn null;\n}\n","export default function Component$findNextNode () {\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Component$firstNode () {\n\tif ( this.rendered ) {\n\t\treturn this.instance.fragment.firstNode();\n\t}\n\n\treturn null;\n}\n","export default function ( wrapper, array, methodName, newIndices ) {\n\tvar { root, keypath } = wrapper;\n\n\tif ( !!newIndices ) {\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t} else {\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\troot.viewmodel.mark( keypath );\n\t}\n}\n","import { defineProperty } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport { getKeypath } from 'shared/keypaths';\nimport patch from './patch';\n\nvar arrayAdaptor,\n\n\t// helpers\n\tArrayWrapper,\n\terrorMessage;\n\narrayAdaptor = {\n\tfilter: function ( object ) {\n\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t// or the array didn't trigger the get() itself\n\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t},\n\twrap: function ( ractive, array, keypath ) {\n\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t}\n};\n\nArrayWrapper = function ( ractive, array, keypath ) {\n\tthis.root = ractive;\n\tthis.value = array;\n\tthis.keypath = getKeypath( keypath );\n\n\t// if this array hasn't already been ractified, ractify it\n\tif ( !array._ractive ) {\n\n\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\tdefineProperty( array, '_ractive', {\n\t\t\tvalue: {\n\t\t\t\twrappers: [],\n\t\t\t\tinstances: [],\n\t\t\t\tsetting: false\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tpatch( array );\n\t}\n\n\t// store the ractive instance, so we can handle transitions later\n\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\tarray._ractive.instances.push( ractive );\n\t}\n\n\tarray._ractive.instances[ ractive._guid ] += 1;\n\tarray._ractive.wrappers.push( this );\n};\n\nArrayWrapper.prototype = {\n\tget: function () {\n\t\treturn this.value;\n\t},\n\tteardown: function () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n};\n\nerrorMessage = 'Something went wrong in a rather interesting way';\nexport default arrayAdaptor;\n","import runloop from 'global/runloop';\nimport createBranch from 'utils/createBranch';\nimport { getKeypath } from 'shared/keypaths';\nimport { isArray } from 'utils/is';\n\nvar magicAdaptor, MagicWrapper;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tmagicAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\tvar parentWrapper, parentValue;\n\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tkeypath = getKeypath( keypath );\n\n\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t// we shouldn't wrap this property\n\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ keypath.parent.str ] ) && !parentWrapper.magic ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparentValue = ractive.viewmodel.get( keypath.parent );\n\n\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( keypath.lastKey ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) );\n\t\t},\n\t\twrap: function ( ractive, property, keypath ) {\n\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t}\n\t};\n\n\tMagicWrapper = function ( ractive, value, keypath ) {\n\t\tvar objKeypath, template, siblings;\n\n\t\tkeypath = getKeypath( keypath );\n\n\t\tthis.magic = true;\n\n\t\tthis.ractive = ractive;\n\t\tthis.keypath = keypath;\n\t\tthis.value = value;\n\n\t\tthis.prop = keypath.lastKey;\n\n\t\tobjKeypath = keypath.parent;\n\t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get( objKeypath );\n\n\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\n\t\t// Has this property already been wrapped?\n\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\tsiblings.push( this );\n\t\t\t}\n\n\t\t\treturn; // already wrapped\n\t\t}\n\n\t\t// No, it hasn't been wrapped\n\t\tcreateAccessors( this, value, template );\n\t};\n\n\tMagicWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\treset: function ( value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updating = true;\n\t\t\tthis.obj[ this.prop ] = value; // trigger set() accessor\n\t\t\trunloop.addRactive( this.ractive );\n\t\t\tthis.ractive.viewmodel.mark( this.keypath, { keepExistingWrapper: true } );\n\t\t\tthis.updating = false;\n\t\t\treturn true;\n\t\t},\n\t\tset: function ( key, value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\n\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tvar template, set, value, wrappers, index;\n\n\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t// so that it doesn't get torn down\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\tset = template && template.set;\n\n\t\t\tif ( !set ) {\n\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twrappers = set._ractiveWrappers;\n\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t}\n\n\t\t\t// Last one out, turn off the lights\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tvalue = this.obj[ this.prop ];\n\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t}\n\t\t}\n\t};\n} catch ( err ) {\n\tmagicAdaptor = false; // no magic in this browser\n}\n\nexport default magicAdaptor;\n\nfunction createAccessors ( originalWrapper, value, template ) {\n\n\tvar object, property, oldGet, oldSet, get, set;\n\n\tobject = originalWrapper.obj;\n\tproperty = originalWrapper.prop;\n\n\t// Is this template configurable?\n\tif ( template && !template.configurable ) {\n\t\t// Special case - array length\n\t\tif ( property === 'length' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t}\n\n\n\t// Time to wrap this property\n\tif ( template ) {\n\t\toldGet = template.get;\n\t\toldSet = template.set;\n\t}\n\n\tget = oldGet || function () {\n\t\treturn value;\n\t};\n\n\tset = function ( v ) {\n\t\tif ( oldSet ) {\n\t\t\toldSet( v );\n\t\t}\n\n\t\tvalue = oldGet ? oldGet() : v;\n\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t};\n\n\tfunction updateWrapper ( wrapper ) {\n\t\tvar keypath, ractive;\n\n\t\twrapper.value = value;\n\n\t\tif ( wrapper.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tractive = wrapper.ractive;\n\t\tkeypath = wrapper.keypath;\n\n\t\twrapper.updating = true;\n\t\trunloop.start( ractive );\n\n\t\tractive.viewmodel.mark( keypath );\n\n\t\trunloop.end();\n\t\twrapper.updating = false;\n\t}\n\n\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\tset._ractiveWrappers = [ originalWrapper ];\n\tObject.defineProperty( object, property, { get: get, set: set, enumerable: true, configurable: true });\n}\n","var numeric = /^\\s*[0-9]+\\s*$/;\n\nexport default function ( key ) {\n\treturn numeric.test( key ) ? [] : {};\n}\n","import magicAdaptor from './magic';\nimport arrayAdaptor from './array/index';\n\nvar magicArrayAdaptor, MagicArrayWrapper;\n\nif ( magicAdaptor ) {\n\tmagicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tMagicArrayWrapper = function ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t};\n\n\tMagicArrayWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t},\n\t\treset: function ( value ) {\n\t\t\treturn this.magicWrapper.reset( value );\n\t\t}\n\t};\n}\n\nexport default magicArrayAdaptor;\n","var prefixers = {};\n\nexport default function Viewmodel$adapt ( keypath, value ) {\n\tvar len, i, adaptor, wrapped;\n\n\tif ( !this.adaptors ) return;\n\n\t// Do we have an adaptor for this value?\n\tlen = this.adaptors.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tadaptor = this.adaptors[i];\n\n\t\tif ( adaptor.filter( value, keypath, this.ractive ) ) {\n\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( this.ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\twrapped.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nfunction prefixKeypath ( obj, prefix ) {\n\tvar prefixed = {}, key;\n\n\tif ( !prefix ) {\n\t\treturn obj;\n\t}\n\n\tprefix += '.';\n\n\tfor ( key in obj ) {\n\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn prefixed;\n}\n\nfunction getPrefixer ( rootKeypath ) {\n\tvar rootDot;\n\n\tif ( !prefixers[ rootKeypath ] ) {\n\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\tvar obj;\n\n\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t}\n\t\t};\n\t}\n\n\treturn prefixers[ rootKeypath ];\n}\n","export default notifyPatternObservers;\n\nfunction notifyPatternObservers ( viewmodel, keypath, onlyDirect ) {\n\tvar potentialWildcardMatches;\n\n\tupdateMatchingPatternObservers( viewmodel, keypath );\n\n\tif ( onlyDirect ) {\n\t\treturn;\n\t}\n\n\tpotentialWildcardMatches = keypath.wildcardMatches();\n\tpotentialWildcardMatches.forEach( upstreamPattern => {\n\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t});\n}\n\n\nfunction cascade ( viewmodel, upstreamPattern, keypath ) {\n\tvar group, map, actualChildKeypath;\n\n\t// TODO should be one or the other\n\tupstreamPattern = ( upstreamPattern.str || upstreamPattern );\n\n\tgroup = viewmodel.depsMap.patternObservers;\n\tmap = group && group[ upstreamPattern ];\n\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\tmap.forEach( childKeypath => {\n\t\tactualChildKeypath = keypath.join( childKeypath.lastKey ); // 'foo.bar.baz'\n\n\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t});\n}\n\nfunction updateMatchingPatternObservers ( viewmodel, keypath ) {\n\tviewmodel.patternObservers.forEach( observer => {\n\t\tif ( observer.regex.test( keypath.str ) ) {\n\t\t\tobserver.update( keypath );\n\t\t}\n\t});\n}\n","export default function Viewmodel$capture () {\n\tthis.captureGroups.push([]);\n}\n","export default function Viewmodel$clearCache ( keypath, keepExistingWrapper ) {\n\tvar cacheMap, wrapper;\n\n\tif ( !keepExistingWrapper ) {\n\t\t// Is there a wrapped property at this keypath?\n\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t// Did we unwrap it?\n\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t// Is this right?\n\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache[ keypath ] = undefined;\n\n\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\twhile ( cacheMap.length ) {\n\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t}\n\t}\n}\n","var UnresolvedDependency = function ( computation, ref ) {\n\tthis.computation = computation;\n\tthis.viewmodel = computation.viewmodel;\n\tthis.ref = ref;\n\n\t// TODO this seems like a red flag!\n\tthis.root = this.viewmodel.ractive;\n\tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n};\n\nUnresolvedDependency.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.computation.softDeps.push( keypath );\n\t\tthis.computation.unresolvedDeps[ keypath.str ] = null;\n\t\tthis.viewmodel.register( keypath, this.computation, 'computed' );\n\t}\n};\n\nexport default UnresolvedDependency;","import runloop from 'global/runloop';\nimport { logIfDebug, warnIfDebug, warnOnce } from 'utils/log';\nimport { isEqual } from 'utils/is';\nimport UnresolvedDependency from './UnresolvedDependency';\n\nvar Computation = function ( key, signature ) {\n\tthis.key = key;\n\n\tthis.getter = signature.getter;\n\tthis.setter = signature.setter;\n\n\tthis.hardDeps = signature.deps || [];\n\tthis.softDeps = [];\n\tthis.unresolvedDeps = {};\n\n\tthis.depValues = {};\n\n\tthis._dirty = this._firstRun = true;\n};\n\nComputation.prototype = {\n\tconstructor: Computation,\n\n\tinit ( viewmodel ) {\n\t\tvar initial;\n\n\t\tthis.viewmodel = viewmodel;\n\t\tthis.bypass = true;\n\n\t\tinitial = viewmodel.get( this.key );\n\t\tviewmodel.clearCache( this.key.str );\n\n\t\tthis.bypass = false;\n\n\t\tif ( this.setter && initial !== undefined ) {\n\t\t\tthis.set( initial );\n\t\t}\n\n\t\tif ( this.hardDeps ) {\n\t\t\tthis.hardDeps.forEach( d => viewmodel.register( d, this, 'computed' ) );\n\t\t}\n\t},\n\n\tinvalidate () {\n\t\tthis._dirty = true;\n\t},\n\n\tget () {\n\t\tvar newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\n\t\tif ( this.getting ) {\n\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\tlet msg = `The ${this.key.str} computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by \\`array.sort(...)\\` - if that\\'s the case, clone the array first with \\`array.slice().sort(...)\\``;\n\t\t\twarnOnce( msg );\n\t\t\treturn this.value;\n\t\t}\n\n\t\tthis.getting = true;\n\n\t\tif ( this._dirty ) {\n\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t// other computed values\n\t\t\tif ( this._firstRun || ( !this.hardDeps.length && !this.softDeps.length ) ) {\n\t\t\t\tdependencyValuesChanged = true;\n\t\t\t} else {\n\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\tvar keypath, value, i;\n\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ti = deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = deps[i];\n\t\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\n\t\t\t\t\t\tif ( !isEqual( value, this.depValues[ keypath.str ] ) ) {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = value;\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\tthis.viewmodel.capture();\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.value = this.getter();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( 'Failed to compute \"%s\"', this.key.str );\n\t\t\t\t\tlogIfDebug( err.stack || err );\n\n\t\t\t\t\tthis.value = void 0;\n\t\t\t\t}\n\n\t\t\t\tnewDeps = this.viewmodel.release();\n\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\t\tdeps.forEach( keypath => {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = this.viewmodel.get( keypath );\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tthis.getting = this._firstRun = false;\n\t\treturn this.value;\n\t},\n\n\tset ( value ) {\n\t\tif ( this.setting ) {\n\t\t\tthis.value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.setter ) {\n\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t}\n\n\t\tthis.setter( value );\n\t},\n\n\tupdateDependencies ( newDeps ) {\n\t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n\t\toldDeps = this.softDeps;\n\n\t\t// remove dependencies that are no longer used\n\t\ti = oldDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = oldDeps[i];\n\n\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\tdependenciesChanged = true;\n\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t}\n\t\t}\n\n\t\t// create references for any new dependencies\n\t\ti = newDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = newDeps[i];\n\n\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\tdependenciesChanged = true;\n\n\t\t\t\t// if this keypath is currently unresolved, we need to mark\n\t\t\t\t// it as such. TODO this is a bit muddy...\n\t\t\t\tif ( isUnresolved( this.viewmodel, keypath ) && ( !this.unresolvedDeps[ keypath.str ] ) ) {\n\t\t\t\t\tunresolved = new UnresolvedDependency( this, keypath.str );\n\t\t\t\t\tnewDeps.splice( i, 1 );\n\n\t\t\t\t\tthis.unresolvedDeps[ keypath.str ] = unresolved;\n\t\t\t\t\trunloop.addUnresolved( unresolved );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dependenciesChanged ) {\n\t\t\tthis.softDeps = newDeps.slice();\n\t\t}\n\n\t\treturn dependenciesChanged;\n\t}\n};\n\nfunction isUnresolved( viewmodel, keypath ) {\n\tvar key = keypath.firstKey;\n\n\treturn !( key in viewmodel.data ) &&\n\t       !( key in viewmodel.computations ) &&\n\t       !( key in viewmodel.mappings );\n}\n\nexport default Computation;\n","import { lastItem } from 'utils/array';\nimport { hasOwn } from 'utils/object';\nimport FAILED_LOOKUP from './get/FAILED_LOOKUP';\n\nvar empty = {};\n\nexport default function Viewmodel$get ( keypath, options ) {\n\tvar cache = this.cache,\n\t\tvalue,\n\t\tcomputation,\n\t\twrapped,\n\t\tcaptureGroup,\n\t\tkeypathStr = keypath.str,\n\t\tkey;\n\n\toptions = options || empty;\n\n\t// capture the keypath, if we're inside a computation\n\tif ( options.capture && ( captureGroup = lastItem( this.captureGroups ) ) ) {\n\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\tcaptureGroup.push( keypath );\n\t\t}\n\t}\n\n\tif ( hasOwn.call( this.mappings, keypath.firstKey ) ) {\n\t\treturn this.mappings[ keypath.firstKey ].get( keypath, options );\n\t}\n\n\tif ( keypath.isSpecial ) {\n\t\treturn keypath.value;\n\t}\n\n\tif ( cache[ keypathStr ] === undefined ) {\n\n\t\t// Is this a computed property?\n\t\tif ( ( computation = this.computations[ keypathStr ] ) && !computation.bypass ) {\n\t\t\tvalue = computation.get();\n\t\t\tthis.adapt( keypathStr, value );\n\t\t}\n\n\t\t// Is this a wrapped property?\n\t\telse if ( wrapped = this.wrapped[ keypathStr ] ) {\n\t\t\tvalue = wrapped.value;\n\t\t}\n\n\t\t// Is it the root?\n\t\telse if ( keypath.isRoot ) {\n\t\t\tthis.adapt( '', this.data );\n\t\t\tvalue = this.data;\n\t\t}\n\n\t\t// No? Then we need to retrieve the value one key at a time\n\t\telse {\n\t\t\tvalue = retrieve( this, keypath );\n\t\t}\n\n\t\tcache[ keypathStr ] = value;\n\t} else {\n\t\tvalue = cache[ keypathStr ];\n\t}\n\n\tif ( !options.noUnwrap && ( wrapped = this.wrapped[ keypathStr ] ) ) {\n\t\tvalue = wrapped.get();\n\t}\n\n\tif ( keypath.isRoot && options.fullRootGet ) {\n\t\tfor ( key in this.mappings ) {\n\t\t\tvalue[ key ] = this.mappings[ key ].getValue();\n\t\t}\n\t}\n\n\treturn value === FAILED_LOOKUP ? void 0 : value;\n}\n\nfunction retrieve ( viewmodel, keypath ) {\n\n\tvar parentValue, cacheMap, value, wrapped;\n\n\tparentValue = viewmodel.get( keypath.parent );\n\n\tif ( wrapped = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\tparentValue = wrapped.get();\n\t}\n\n\tif ( parentValue === null || parentValue === undefined ) {\n\t\treturn;\n\t}\n\n\t// update cache map\n\tif ( !( cacheMap = viewmodel.cacheMap[ keypath.parent.str ] ) ) {\n\t\tviewmodel.cacheMap[ keypath.parent.str ] = [ keypath.str ];\n\t} else {\n\t\tif ( cacheMap.indexOf( keypath.str ) === -1 ) {\n\t\t\tcacheMap.push( keypath.str );\n\t\t}\n\t}\n\n\t// If this property doesn't exist, we return a sentinel value\n\t// so that we know to query parent scope (if such there be)\n\tif ( typeof parentValue === 'object' && !( keypath.lastKey in parentValue ) ) {\n\t\treturn viewmodel.cache[ keypath.str ] = FAILED_LOOKUP;\n\t}\n\n\tvalue = parentValue[ keypath.lastKey ];\n\n\t// Do we have an adaptor for this value?\n\tviewmodel.adapt( keypath.str, value, false );\n\n\t// Update cache\n\tviewmodel.cache[ keypath.str ] = value;\n\treturn value;\n}\n","export default function Viewmodel$init () {\n\tvar key;\n\n\tfor ( key in this.computations ) {\n\t\tthis.computations[ key ].init( this );\n\t}\n}","export default function Viewmodel$map ( key, options ) {\n\tvar mapping = this.mappings[ key.str ] = new Mapping( key, options );\n\tmapping.initViewmodel( this );\n\treturn mapping;\n}\n\nvar Mapping = function ( localKey, options ) {\n\tthis.localKey = localKey;\n\tthis.keypath = options.keypath;\n\tthis.origin = options.origin;\n\n\tthis.deps = [];\n\tthis.unresolved = [];\n\n\tthis.resolved = false;\n};\n\nMapping.prototype = {\n\tforceResolution () {\n\t\t// TODO warn, as per #1692?\n\t\tthis.keypath = this.localKey;\n\t\tthis.setup();\n\t},\n\n\tget ( keypath, options ) {\n\t\tif ( !this.resolved ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.map( keypath ), options );\n\t},\n\n\tgetValue () {\n\t\tif ( !this.keypath ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.keypath );\n\t},\n\n\tinitViewmodel ( viewmodel ) {\n\t\tthis.local = viewmodel;\n\t\tthis.setup();\n\t},\n\n\tmap ( keypath ) {\n    \t\tif( typeof this.keypath === undefined ) {\n    \t\t\treturn this.localKey;\n    \t\t}\n    \t\treturn keypath.replace( this.localKey, this.keypath );\n\t},\n\n\tregister ( keypath, dependant, group ) {\n\t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n\t\tif ( this.resolved ) {\n\t\t\tthis.origin.register( this.map( keypath ), dependant, group );\n\t\t}\n\t},\n\n\tresolve ( keypath ) {\n\t\tif ( this.keypath !== undefined ) {\n\t\t\tthis.unbind( true );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.setup();\n\t},\n\n\tset ( keypath, value ) {\n\t\tif ( !this.resolved ) {\n\t\t\tthis.forceResolution();\n\t\t}\n\n\t\tthis.origin.set( this.map( keypath ), value );\n\t},\n\n\tsetup () {\n\t\tif ( this.keypath === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\t// accumulated dependants can now be registered\n\t\tif ( this.deps.length ) {\n\t\t\tthis.deps.forEach( d => {\n\t\t\t\tvar keypath = this.map( d.keypath );\n\t\t\t\tthis.origin.register( keypath, d.dep, d.group );\n\n\t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n\t\t\t\tif ( d.dep.setValue ) {\n\t\t\t\t\td.dep.setValue( this.origin.get( keypath ) );\n\t\t\t\t} else if ( d.dep.invalidate ) {\n\t\t\t\t\td.dep.invalidate();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.origin.mark( this.keypath );\n\t\t}\n\t},\n\n\tsetValue ( value ) {\n\t\tif ( !this.keypath ) {\n\t\t\tthrow new Error( 'Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t}\n\n\t\tthis.origin.set( this.keypath, value );\n\t},\n\n\tunbind ( keepLocal ) {\n\t\tif ( !keepLocal ) {\n\t\t\tdelete this.local.mappings[ this.localKey ];\n\t\t}\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deps.forEach( d => {\n\t\t\tthis.origin.unregister( this.map( d.keypath ), d.dep, d.group );\n\t\t});\n\n\t\tif ( this.tracker ) {\n\t\t\tthis.origin.unregister( this.keypath, this.tracker );\n\t\t}\n\t},\n\n\tunregister ( keypath, dependant, group ) {\n\t\tvar deps, i;\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeps = this.deps;\n\t\ti = deps.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( deps[i].dep === dependant ) {\n\t\t\t\tdeps.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.origin.unregister( this.map( keypath ), dependant, group );\n\t}\n};\n","export default function Viewmodel$mark ( keypath, options ) {\n\tvar computation, keypathStr = keypath.str;\n\n\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t// should not be picked up by pattern observers\n\tif ( options ) {\n\t\tif ( options.implicit ) {\n\t\t\tthis.implicitChanges[ keypathStr ] = true;\n\t\t}\n\t\tif ( options.noCascade ) {\n\t\t\tthis.noCascade[ keypathStr ] = true;\n\t\t}\n\t}\n\n\tif ( computation = this.computations[ keypathStr ] ) {\n\t\tcomputation.invalidate();\n\t}\n\n\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\tthis.changes.push( keypath );\n\t}\n\n\t// pass on keepExistingWrapper, if we can\n\tlet keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n\tthis.clearCache( keypathStr, keepExistingWrapper );\n\n\tif ( this.ready ) {\n\t\tthis.onchange();\n\t}\n}\n","export default function ( oldArray, newArray ) {\n\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n\tusedIndices = {};\n\tfirstUnusedIndex = 0;\n\n\tnewIndices = oldArray.map( function ( item, i ) {\n\t\tvar index, start, len;\n\n\t\tstart = firstUnusedIndex;\n\t\tlen = newArray.length;\n\n\t\tdo {\n\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\tif ( index === -1 ) {\n\t\t\t\tchanged = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstart = index + 1;\n\t\t} while ( usedIndices[ index ] && start < len );\n\n\t\t// keep track of the first unused index, so we don't search\n\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\tif ( index === firstUnusedIndex ) {\n\t\t\tfirstUnusedIndex += 1;\n\t\t}\n\n\t\tif ( index !== i ) {\n\t\t\tchanged = true;\n\t\t}\n\n\t\tusedIndices[ index ] = true;\n\t\treturn index;\n\t});\n\n\treturn newIndices;\n}\n","import { warnIfDebug } from 'utils/log';\nimport mapOldToNewIndex from './merge/mapOldToNewIndex';\n\nvar comparators = {};\n\nexport default function Viewmodel$merge ( keypath, currentArray, array, options ) {\n\tvar oldArray,\n\t\tnewArray,\n\t\tcomparator,\n\t\tnewIndices;\n\n\tthis.mark( keypath );\n\n\tif ( options && options.compare ) {\n\n\t\tcomparator = getComparatorFunction( options.compare );\n\n\t\ttry {\n\t\t\toldArray = currentArray.map( comparator );\n\t\t\tnewArray = array.map( comparator );\n\t\t} catch ( err ) {\n\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t// to do more DOM manipulation than we thought...\n\t\t\twarnIfDebug( 'merge(): \"%s\" comparison failed. Falling back to identity checking', keypath );\n\n\t\t\toldArray = currentArray;\n\t\t\tnewArray = array;\n\t\t}\n\n\t} else {\n\t\toldArray = currentArray;\n\t\tnewArray = array;\n\t}\n\n\t// find new indices for members of oldArray\n\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\n\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n}\n\nfunction stringify ( item ) {\n\treturn JSON.stringify( item );\n}\n\nfunction getComparatorFunction ( comparator ) {\n\t// If `compare` is `true`, we use JSON.stringify to compare\n\t// objects that are the same shape, but non-identical - i.e.\n\t// { foo: 'bar' } !== { foo: 'bar' }\n\tif ( comparator === true ) {\n\t\treturn stringify;\n\t}\n\n\tif ( typeof comparator === 'string' ) {\n\t\tif ( !comparators[ comparator ] ) {\n\t\t\tcomparators[ comparator ] = function ( item ) {\n\t\t\t\treturn item[ comparator ];\n\t\t\t};\n\t\t}\n\n\t\treturn comparators[ comparator ];\n\t}\n\n\tif ( typeof comparator === 'function' ) {\n\t\treturn comparator;\n\t}\n\n\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n}\n","export default function Viewmodel$register ( keypath, dependant, group = 'default' ) {\n\tvar mapping, depsByKeypath, deps;\n\n\tif ( dependant.isStatic ) {\n\t\treturn; // TODO we should never get here if a dependant is static...\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\tmapping.register( keypath, dependant, group );\n\t}\n\n\telse {\n\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\tdeps = depsByKeypath[ keypath.str ] || ( depsByKeypath[ keypath.str ] = [] );\n\n\t\tdeps.push( dependant );\n\n\t\tif ( !this.depsMap[ group ] ) {\n\t\t\tthis.depsMap[ group ] = {};\n\t\t}\n\n\t\tif ( !keypath.isRoot ) {\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t}\n\t}\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent, keypathStr;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ] || ( map[ keypath.parent.str ] = [] );\n\n\t\tkeypathStr = keypath.str;\n\n\t\t// TODO find an alternative to this nasty approach\n\t\tif ( parent[ '_' + keypathStr ] === undefined ) {\n\t\t\tparent[ '_' + keypathStr ] = 0;\n\t\t\tparent.push( keypath );\n\t\t}\n\n\t\tparent[ '_' + keypathStr ] += 1;\n\t\tkeypath = keypath.parent;\n\t}\n}\n","export default function Viewmodel$release () {\n\treturn this.captureGroups.pop();\n}\n","export default function Viewmodel$reset ( data ) {\n\tthis.data = data;\n\tthis.clearCache( '' );\n}","var implicitOption = { implicit: true }, noCascadeOption = { noCascade: true };\n\nexport default function Viewmodel$smartUpdate ( keypath, array, newIndices ) {\n\tvar dependants, oldLength, i;\n\n\toldLength = newIndices.length;\n\n\t// Indices that are being removed should be marked as dirty\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.mark( keypath.join( oldIndex ), noCascadeOption );\n\t\t}\n\t});\n\n\t// Update the model\n\t// TODO allow existing array to be updated in place, rather than replaced?\n\tthis.set( keypath, array, { silent: true } );\n\n\tif ( dependants = this.deps[ 'default' ][ keypath.str ] ) {\n\t\tdependants.filter( canShuffle ).forEach( d => d.shuffle( newIndices, array ) );\n\t}\n\n\tif ( oldLength !== array.length ) {\n\t\tthis.mark( keypath.join( 'length' ), implicitOption );\n\n\t\tfor ( i = newIndices.touchedFrom; i < array.length; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ) );\n\t\t}\n\n\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t// TODO is this still necessary, now that computations are lazy?\n\t\tfor ( i = array.length; i < oldLength; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ), noCascadeOption );\n\t\t}\n\t}\n}\n\nfunction canShuffle ( dependant ) {\n\treturn typeof dependant.shuffle === 'function';\n}\n","export default function Viewmodel$teardown () {\n\tvar unresolvedImplicitDependency;\n\n\t// Clear entire cache - this has the desired side-effect\n\t// of unwrapping adapted values (e.g. arrays)\n\tObject.keys( this.cache ).forEach( keypath => this.clearCache( keypath ) );\n\n\t// Teardown any failed lookups - we don't need them to resolve any more\n\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\tunresolvedImplicitDependency.teardown();\n\t}\n}\n","import { fatal } from 'utils/log';\nimport { getKeypath } from 'shared/keypaths';\nimport { create } from 'utils/object';\nimport adapt from './prototype/adapt';\nimport applyChanges from './prototype/applyChanges';\nimport capture from './prototype/capture';\nimport clearCache from './prototype/clearCache';\nimport compute from './prototype/compute';\nimport get from './prototype/get';\nimport init from './prototype/init';\nimport map from './prototype/map';\nimport mark from './prototype/mark';\nimport merge from './prototype/merge';\nimport register from './prototype/register';\nimport release from './prototype/release';\nimport reset from './prototype/reset';\nimport set from './prototype/set';\nimport smartUpdate from './prototype/smartUpdate';\nimport teardown from './prototype/teardown';\nimport unregister from './prototype/unregister';\n\nvar Viewmodel = function ( options ) {\n\tvar { adapt, data, ractive, computed, mappings } = options,\n\t\tkey,\n\t\tmapping;\n\n\t// TODO is it possible to remove this reference?\n\tthis.ractive = ractive;\n\n\tthis.adaptors = adapt;\n\tthis.onchange = options.onchange;\n\n\tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n\tthis.cacheMap = create( null );\n\n\tthis.deps = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\tthis.depsMap = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\n\tthis.patternObservers = [];\n\n\tthis.specials = create( null );\n\n\tthis.wrapped = create( null );\n\tthis.computations = create( null );\n\n\tthis.captureGroups = [];\n\tthis.unresolvedImplicitDependencies = [];\n\n\tthis.changes = [];\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\tthis.data = data;\n\n\t// set up explicit mappings\n\tthis.mappings = create( null );\n\tfor ( key in mappings ) {\n\t\tthis.map( getKeypath( key ), mappings[ key ] );\n\t}\n\n\tif ( data ) {\n\t\t// if data exists locally, but is missing on the parent,\n\t\t// we transfer ownership to the parent\n\t\tfor ( key in data ) {\n\t\t\tif ( ( mapping = this.mappings[ key ] ) && mapping.getValue() === undefined ) {\n\t\t\t\tmapping.setValue( data[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( key in computed ) {\n\t\tif ( mappings && key in mappings ) {\n\t\t\tfatal( 'Cannot map to a computed property (\\'%s\\')', key );\n\t\t}\n\n\t\tthis.compute( getKeypath( key ), computed[ key ] );\n\t}\n\n\tthis.ready = true;\n};\n\nViewmodel.prototype = {\n\tadapt: adapt,\n\tapplyChanges: applyChanges,\n\tcapture: capture,\n\tclearCache: clearCache,\n\tcompute: compute,\n\tget: get,\n\tinit: init,\n\tmap: map,\n\tmark: mark,\n\tmerge: merge,\n\tregister: register,\n\trelease: release,\n\treset: reset,\n\tset: set,\n\tsmartUpdate: smartUpdate,\n\tteardown: teardown,\n\tunregister: unregister\n};\n\nexport default Viewmodel;\n","import Hook from './Hook';\n\nfunction HookQueue ( event ) {\n\tthis.hook = new Hook( event );\n\tthis.inProcess = {};\n\tthis.queue = {};\n}\n\nHookQueue.prototype = {\n\n\tconstructor: HookQueue,\n\n\tbegin: function ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t},\n\n\tend: function ( ractive ) {\n\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t}\n};\n\nfunction getChildQueue ( queue, ractive ) {\n\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n}\n\nfunction fire ( hookQueue, ractive ) {\n\n\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\thookQueue.hook.fire( ractive );\n\n\t// queue is \"live\" because components can end up being\n\t// added while hooks fire on parents that modify data values.\n\twhile ( childQueue.length ) {\n\t\tfire( hookQueue, childQueue.shift() );\n\t}\n\n\tdelete hookQueue.queue[ ractive._guid ];\n}\n\n\nexport default HookQueue;\n","import { fatal } from 'utils/log';\n\nvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\nexport default function getComputationSignatures ( ractive, computed ) {\n\tvar signatures = {}, key;\n\n\tfor ( key in computed ) {\n\t\tsignatures[ key ] = getComputationSignature( ractive, key, computed[ key ] );\n\t}\n\n\treturn signatures;\n}\n\nfunction getComputationSignature ( ractive, key, signature ) {\n\tvar getter, setter;\n\n\tif ( typeof signature === 'function' ) {\n\t\tgetter = bind( signature, ractive );\n\t}\n\n\tif ( typeof signature === 'string' ) {\n\t\tgetter = createFunctionFromString( ractive, signature );\n\t}\n\n\tif ( typeof signature === 'object' ) {\n\t\tif ( typeof signature.get === 'string' ) {\n\t\t\tgetter = createFunctionFromString( ractive, signature.get );\n\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\tgetter = bind( signature.get, ractive );\n\t\t} else {\n\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t}\n\n\t\tif ( typeof signature.set === 'function' ) {\n\t\t\tsetter = bind( signature.set, ractive );\n\t\t}\n\t}\n\n\treturn { getter: getter, setter: setter };\n}\n\nfunction createFunctionFromString ( ractive, str ) {\n\tvar functionBody, hasThis, fn;\n\n\tfunctionBody = 'return (' + str.replace( pattern, ( match, keypath ) => {\n\t\thasThis = true;\n\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t}) + ');';\n\n\tif ( hasThis ) {\n\t\tfunctionBody = 'var __ractive = this; ' + functionBody;\n\t}\n\n\tfn = new Function( functionBody );\n\treturn hasThis ? fn.bind( ractive ) : fn;\n}\n\nfunction bind ( fn, context ) {\n\treturn /this/.test( fn.toString() ) ? fn.bind( context ) : fn;\n}","import { fatal, logIfDebug, warnIfDebug, warnOnceIfDebug, welcome } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport { magic as magicSupported } from 'config/environment';\nimport { ensureArray } from 'utils/array';\nimport { findInViewHierarchy } from 'shared/registry';\nimport arrayAdaptor from 'Ractive/static/adaptors/array/index';\nimport magicAdaptor from 'Ractive/static/adaptors/magic';\nimport magicArrayAdaptor from 'Ractive/static/adaptors/magicArray';\nimport { getElement } from 'utils/dom';\nimport { create, defineProperty, extend } from 'utils/object';\nimport runloop from 'global/runloop';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport Fragment from 'virtualdom/Fragment';\nimport Viewmodel from 'viewmodel/Viewmodel';\nimport Hook from './prototype/shared/hooks/Hook';\nimport HookQueue from './prototype/shared/hooks/HookQueue';\nimport getComputationSignatures from './helpers/getComputationSignatures';\nimport Ractive from '../Ractive';\n\nlet constructHook = new Hook( 'construct' );\nlet configHook = new Hook( 'config' );\nlet initHook = new HookQueue( 'init' );\nlet uid = 0;\n\nlet registryNames = [\n\t'adaptors',\n\t'components',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nexport default initialiseRactiveInstance;\n\nfunction initialiseRactiveInstance ( ractive, userOptions = {}, options = {} ) {\n\tvar el, viewmodel;\n\n\tif ( Ractive.DEBUG ) {\n\t\twelcome();\n\t}\n\n\tinitialiseProperties( ractive, options );\n\n\t// TODO remove this, eventually\n\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\tconstructHook.fire( ractive, userOptions );\n\n\t// Add registries\n\tregistryNames.forEach( name => {\n\t\tractive[ name ] = extend( create( ractive.constructor[ name ] || null ), userOptions[ name ] );\n\t});\n\n\t// Create a viewmodel\n\tviewmodel = new Viewmodel({\n\t\tadapt: getAdaptors( ractive, ractive.adapt, userOptions ),\n\t\tdata: dataConfigurator.init( ractive.constructor, ractive, userOptions ),\n\t\tcomputed: getComputationSignatures( ractive, extend( create( ractive.constructor.prototype.computed ), userOptions.computed ) ),\n\t\tmappings: options.mappings,\n\t\tractive: ractive,\n\t\tonchange: () => runloop.addRactive( ractive )\n\t});\n\n\tractive.viewmodel = viewmodel;\n\n\t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n\tviewmodel.init();\n\n\t// init config from Parent and options\n\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\tconfigHook.fire( ractive );\n\tinitHook.begin( ractive );\n\n\t// // If this is a component with a function `data` property, call the function\n\t// // with `ractive` as context (unless the child was also a function)\n\t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n\t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n\t// }\n\n\n\t// Render virtual DOM\n\tif ( ractive.template ) {\n\t\tlet cssIds;\n\n\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n\t\t\tif ( ractive.cssId ) {\n\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t}\n\t\t}\n\n\t\tractive.fragment = new Fragment({\n\t\t\ttemplate: ractive.template,\n\t\t\troot: ractive,\n\t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n\t\t\tcssIds\n\t\t});\n\t}\n\n\tinitHook.end( ractive );\n\n\t// render automatically ( if `el` is specified )\n\tif ( el = getElement( ractive.el ) ) {\n\t\tlet promise = ractive.render( el, ractive.append );\n\n\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\tpromise.catch( err => {\n\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive });\n\t\t\t\terr.stack && logIfDebug( err.stack );\n\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction getAdaptors ( ractive, protoAdapt, userOptions ) {\n\tvar adapt, magic, modifyArrays;\n\n\tprotoAdapt = protoAdapt.map( lookup );\n\tadapt = ensureArray( userOptions.adapt ).map( lookup );\n\n\tadapt = combine( protoAdapt, adapt );\n\n\tmagic = 'magic' in userOptions ? userOptions.magic : ractive.magic;\n\tmodifyArrays = 'modifyArrays' in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n\tif ( magic ) {\n\t\tif ( !magicSupported ) {\n\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t}\n\n\t\tif ( modifyArrays ) {\n\t\t\tadapt.push( magicArrayAdaptor );\n\t\t}\n\n\t\tadapt.push( magicAdaptor );\n\t}\n\n\tif ( modifyArrays ) {\n\t\tadapt.push( arrayAdaptor );\n\t}\n\n\treturn adapt;\n\n\n\tfunction lookup ( adaptor ) {\n\t\tif ( typeof adaptor === 'string' ) {\n\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\tif ( !adaptor ) {\n\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t}\n\t\t}\n\n\t\treturn adaptor;\n\t}\n}\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}\n\nfunction initialiseProperties ( ractive, options ) {\n\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t// existed\n\tractive._guid = 'r-' + uid++;\n\n\t// events\n\tractive._subs = create( null );\n\n\t// storage for item configuration from instantiation to reset,\n\t// like dynamic functions or original values\n\tractive._config = {};\n\n\t// two-way bindings\n\tractive._twowayBindings = create( null );\n\n\t// animations (so we can stop any in progress at teardown)\n\tractive._animations = [];\n\n\t// nodes registry\n\tractive.nodes = {};\n\n\t// live queries\n\tractive._liveQueries = [];\n\tractive._liveComponentQueries = [];\n\n\t// bound data functions\n\tractive._boundFunctions = [];\n\n\t// observers\n\tractive._observers = [];\n\n\n\t// properties specific to inline components\n\tif ( options.component ) {\n\t\tractive.parent = options.parent;\n\t\tractive.container = options.container || null;\n\t\tractive.root = ractive.parent.root;\n\n\t\tractive.component = options.component;\n\t\toptions.component.instance = ractive;\n\n\t\t// for hackability, this could be an open option\n\t\t// for any ractive instance, but for now, just\n\t\t// for components and just for ractive...\n\t\tractive._inlinePartials = options.inlinePartials;\n\t} else {\n\t\tractive.root = ractive;\n\t\tractive.parent = ractive.container = null;\n\t}\n}\n\nfunction deprecateRactiveData () {\n\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n}\n","import runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nfunction ComplexParameter ( component, template, callback ) {\n\tthis.parentFragment = component.parentFragment;\n\tthis.callback = callback;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: template,\n\t\troot:     component.root,\n\t\towner:    this\n\t});\n\n\tthis.update();\n}\n\nexport default ComplexParameter;\n\nComplexParameter.prototype = {\n\tbubble: function () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\tthis.callback( this.fragment.getValue() );\n\t\tthis.dirty = false;\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t}\n};\n\n","import { INTERPOLATOR, YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport parseJSON from 'utils/parseJSON';\nimport initialise from 'Ractive/initialise';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\nimport ReferenceExpressionResolver from 'virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ComplexParameter from './ComplexParameter';\n\nexport default function ( component, Component, attributes, yieldTemplate, partials ) {\n\tvar instance, parentFragment, ractive, fragment, container, inlinePartials = {}, data = {}, mappings = {}, ready, resolvers = [];\n\n\tparentFragment = component.parentFragment;\n\tractive = component.root;\n\n\tpartials = partials || {};\n\textend( inlinePartials, partials );\n\n\t// Make contents available as a {{>content}} partial\n\tpartials.content = yieldTemplate || [];\n\n\t// set a default partial for yields with no name\n\tinlinePartials[''] = partials.content;\n\n\tif ( Component.defaults.el ) {\n\t\twarnIfDebug( 'The <%s/> component has a default `el` property; it has been disregarded', component.name );\n\t}\n\n\t// find container\n\tfragment = parentFragment;\n\twhile ( fragment ) {\n\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\tcontainer = fragment.owner.container;\n\t\t\tbreak;\n\t\t}\n\n\t\tfragment = fragment.parent;\n\t}\n\n\t// each attribute represents either a) data or b) a mapping\n\tif ( attributes ) {\n\t\tObject.keys( attributes ).forEach( key => {\n\t\t\tvar attribute = attributes[ key ], parsed, resolver;\n\n\t\t\tif ( typeof attribute === 'string' ) {\n\t\t\t\t// it's static data\n\t\t\t\tparsed = parseJSON( attribute );\n\t\t\t\tdata[ key ] = parsed ? parsed.value : attribute;\n\t\t\t}\n\n\t\t\telse if ( attribute === 0 ) {\n\t\t\t\t// it had no '=', so we'll call it true\n\t\t\t\tdata[ key ] = true;\n\t\t\t}\n\n\t\t\telse if ( isArray( attribute ) ) {\n\t\t\t\t// this represents dynamic data\n\t\t\t\tif ( isSingleInterpolator( attribute ) ) {\n\t\t\t\t\tmappings[ key ] = {\n\t\t\t\t\t\torigin: component.root.viewmodel,\n\t\t\t\t\t\tkeypath: undefined\n\t\t\t\t\t};\n\n\t\t\t\t\tresolver = createResolver( component, attribute[0], function ( keypath ) {\n\t\t\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.set( key, keypath.value ); // TODO use viewmodel?\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[ key ] = keypath.value;\n\n\t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n\t\t\t\t\t\t\t\tdelete mappings[ key ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.viewmodel.mappings[ key ].resolve( keypath );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// resolved immediately\n\t\t\t\t\t\t\t\tmappings[ key ].keypath = keypath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresolver = new ComplexParameter( component, attribute, function ( value ) {\n\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\tinstance.set( key, value ); // TODO use viewmodel?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tresolvers.push( resolver );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow new Error( 'erm wut' );\n\t\t\t}\n\t\t});\n\t}\n\n\tinstance = create( Component.prototype );\n\n\tinitialise( instance, {\n\t\tel: null,\n\t\tappend: true,\n\t\tdata,\n\t\tpartials,\n\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\tmodifyArrays: ractive.modifyArrays,\n\t\t// need to inherit runtime parent adaptors\n\t\tadapt: ractive.adapt\n\t}, {\n\t\tparent: ractive,\n\t\tcomponent,\n\t\tcontainer,\n\t\tmappings,\n\t\tinlinePartials,\n\t\tcssIds: parentFragment.cssIds\n\t});\n\n\tready = true;\n\tcomponent.resolvers = resolvers;\n\n\treturn instance;\n}\n\nfunction createResolver ( component, template, callback ) {\n\tvar resolver;\n\n\tif ( template.r ) {\n\t\tresolver = createReferenceResolver( component, template.r, callback );\n\t}\n\n\telse if ( template.x ) {\n\t\tresolver = new ExpressionResolver( component, component.parentFragment, template.x, callback );\n\t}\n\n\telse if ( template.rx ) {\n\t\tresolver = new ReferenceExpressionResolver( component, template.rx, callback );\n\t}\n\n\treturn resolver;\n}\n\nfunction isSingleInterpolator( template ){\n\treturn template.length === 1 && template[0].t === INTERPOLATOR;\n}\n","export default function ( component ) {\n\tvar ancestor, query;\n\n\t// If there's a live query for this component type, add it\n\tancestor = component.root;\n\twhile ( ancestor ) {\n\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery.push( component.instance );\n\t\t}\n\n\t\tancestor = ancestor.parent;\n\t}\n}\n","export default function Component$rebind ( oldKeypath, newKeypath ) {\n\tvar query;\n\n\tthis.resolvers.forEach( rebind );\n\n\tfor ( let k in this.yielders ) {\n\t\tif ( this.yielders[k][0] ) {\n\t\t\trebind( this.yielders[k][0] );\n\t\t}\n\t}\n\n\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\tquery._makeDirty();\n\t}\n\n\tfunction rebind ( x ) {\n\t\tx.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function Component$render () {\n\tvar instance = this.instance;\n\n\tinstance.render( this.parentFragment.getNode() );\n\n\tthis.rendered = true;\n\treturn instance.fragment.detach();\n}\n","export default function Component$toString () {\n\treturn this.instance.fragment.toString();\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport { unbind, cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\nexport default function Component$unbind () {\n\tvar instance = this.instance;\n\n\tthis.resolvers.forEach( unbind );\n\n\tremoveFromLiveComponentQueries( this );\n\n\tinstance._observers.forEach( cancel );\n\n\t// teardown the instance\n\tinstance.fragment.unbind();\n\tinstance.viewmodel.teardown();\n\n\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t}\n\n\tteardownHook.fire( instance );\n}\n\nfunction removeFromLiveComponentQueries ( component ) {\n\tvar instance, query;\n\n\tinstance = component.root;\n\n\tdo {\n\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery._remove( component );\n\t\t}\n\t} while ( instance = instance.parent );\n}","export default function Component$unrender ( shouldDestroy ) {\n\tthis.shouldDestroy = shouldDestroy;\n\tthis.instance.unrender();\n}\n","import detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Component = function ( options, Constructor ) {\n\tthis.init( options, Constructor );\n};\n\nComponent.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Component;\n","import { COMMENT } from 'config/types';\nimport detach from './shared/detach';\n\nvar Comment = function ( options ) {\n\tthis.type = COMMENT;\n\tthis.value = options.template.c;\n};\n\nComment.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createComment( this.value );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString () {\n\t\treturn '<!--' + this.value + '-->';\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t}\n\t}\n};\n\nexport default Comment;\n","import { YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\nimport { isArray } from 'utils/is';\n\nvar Yielder = function ( options ) {\n\tvar container, component;\n\n\tthis.type = YIELDER;\n\n\tthis.container = container = options.parentFragment.root;\n\tthis.component = component = container.component;\n\n\tthis.container = container;\n\tthis.containerFragment = options.parentFragment;\n\tthis.parentFragment = component.parentFragment;\n\n\tlet name = this.name = options.template.n || '';\n\n\tlet template = container._inlinePartials[ name ];\n\n\tif ( !template ) {\n\t\twarnIfDebug( `Could not find template for partial \"${name}\"`, { ractive: options.root });\n\t\ttemplate = [];\n\t}\n\n\tthis.fragment = new Fragment({\n\t\towner: this,\n\t\troot: container.parent,\n\t\ttemplate,\n\t\tpElement: this.containerFragment.pElement\n\t});\n\n\t// even though only one yielder is allowed, we need to have an array of them\n\t// as it's possible to cause a yielder to be created before the last one\n\t// was destroyed in the same turn of the runloop\n\tif ( !isArray( component.yielders[ name ] ) ) {\n\t\tcomponent.yielders[ name ] = [ this ];\n\t} else {\n\t\tcomponent.yielders[ name ].push( this );\n\t}\n\n\trunloop.scheduleTask( () => {\n\t\tif ( component.yielders[ name ].length > 1 ) {\n\t\t\tthrow new Error( 'A component template can only have one {{yield' + (name ? ' ' + name : '') + '}} declaration at a time' );\n\t\t}\n\t});\n};\n\nYielder.prototype = {\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfindNextNode () {\n\t\treturn this.containerFragment.findNextNode( this );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tgetValue ( options ) {\n\t\treturn this.fragment.getValue( options );\n\t},\n\n\trender () {\n\t\treturn this.fragment.render();\n\t},\n\n\tunbind () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tthis.fragment.unrender( shouldDestroy );\n\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\ttoString () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default Yielder;\n","import noop from 'utils/noop';\n\nvar Doctype = function ( options ) {\n\tthis.declaration = options.template.a;\n};\n\nDoctype.prototype = {\n\tinit: noop,\n\trender: noop,\n\tunrender: noop,\n\tteardown: noop,\n\ttoString () {\n\t\treturn '<!DOCTYPE' + this.declaration + '>';\n\t}\n};\n\nexport default Doctype;","export default function Fragment$render () {\n\tvar result;\n\n\tif ( this.items.length === 1 ) {\n\t\tresult = this.items[0].render();\n\t} else {\n\t\tresult = document.createDocumentFragment();\n\n\t\tthis.items.forEach( item => {\n\t\t\tresult.appendChild( item.render() );\n\t\t});\n\t}\n\n\tthis.rendered = true;\n\treturn result;\n}\n","export default function Fragment$toString ( escape ) {\n\tif ( !this.items ) {\n\t\treturn '';\n\t}\n\n\treturn this.items.map( escape ? toEscapedString : toString ).join( '' );\n}\n\nfunction toString ( item ) {\n\treturn item.toString();\n}\n\nfunction toEscapedString ( item ) {\n\treturn item.toString( true );\n}","export default function Fragment$unbind () {\n\tif ( !this.bound ) {\n\t\treturn;\n\t}\n\n\tthis.items.forEach( unbindItem );\n\tthis.bound = false;\n}\n\nfunction unbindItem ( item ) {\n\tif ( item.unbind ) {\n\t\titem.unbind();\n\t}\n}\n","export default function Fragment$unrender ( shouldDestroy ) {\n\tif ( !this.rendered ) {\n\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t}\n\n\tthis.items.forEach( i => i.unrender( shouldDestroy ) );\n\tthis.rendered = false;\n}\n","import bubble from './Fragment/prototype/bubble';\nimport detach from './Fragment/prototype/detach';\nimport find from './Fragment/prototype/find';\nimport findAll from './Fragment/prototype/findAll';\nimport findAllComponents from './Fragment/prototype/findAllComponents';\nimport findComponent from './Fragment/prototype/findComponent';\nimport findNextNode from './Fragment/prototype/findNextNode';\nimport firstNode from './Fragment/prototype/firstNode';\nimport getArgsList from './Fragment/prototype/getArgsList';\nimport getNode from './Fragment/prototype/getNode';\nimport getValue from './Fragment/prototype/getValue';\nimport init from './Fragment/prototype/init';\nimport rebind from './Fragment/prototype/rebind';\nimport render from './Fragment/prototype/render';\nimport toString from './Fragment/prototype/toString';\nimport unbind from './Fragment/prototype/unbind';\nimport unrender from './Fragment/prototype/unrender';\n\nvar Fragment = function ( options ) {\n\tthis.init( options );\n};\n\nFragment.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetArgsList: getArgsList,\n\tgetNode: getNode,\n\tgetValue: getValue,\n\tinit: init,\n\trebind: rebind,\n\tregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tif ( idxs.indexOf( idx ) === -1 ) {\n\t\t\tidxs.push( idx );\n\t\t}\n\t},\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tidxs.splice( idxs.indexOf( idx ), 1 );\n\t},\n\tunrender: unrender\n};\n\nexport default Fragment;\n","import defaults from 'Ractive/config/defaults';\nimport easing from 'Ractive/static/easing';\nimport interpolators from 'Ractive/static/interpolators';\nimport { magic, svg } from 'config/environment';\nimport { defineProperties, extend as extendObj } from 'utils/object';\nimport proto from 'Ractive/prototype';\nimport Promise from 'utils/Promise';\nimport extend from 'extend/_extend';\nimport parse from 'parse/_parse';\nimport getNodeInfo from 'Ractive/static/getNodeInfo';\nimport initialise from 'Ractive/initialise';\n\nvar Ractive, properties;\n\n// Main Ractive required object\nRactive = function ( options ) {\n\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\tinitialise( this, options );\n};\n\n\n// Ract