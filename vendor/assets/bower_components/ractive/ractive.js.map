{"version":3,"file":"ractive.js","sources":["../src/Ractive.js","../src/Ractive/static/getNodeInfo.js","../src/extend/_extend.js","../src/extend/unwrapExtended.js","../src/utils/wrapMethod.js","../src/Ractive/prototype.js","../src/Ractive/prototype/updateModel.js","../src/Ractive/prototype/update.js","../src/Ractive/prototype/unshift.js","../src/Ractive/prototype/unrender.js","../src/Ractive/prototype/toHTML.js","../src/Ractive/prototype/toggle.js","../src/Ractive/prototype/teardown.js","../src/Ractive/prototype/subtract.js","../src/Ractive/prototype/splice.js","../src/Ractive/prototype/sort.js","../src/Ractive/prototype/shift.js","../src/Ractive/prototype/set.js","../src/Ractive/prototype/reverse.js","../src/Ractive/prototype/resetTemplate.js","../src/Ractive/prototype/resetPartial.js","../src/Ractive/prototype/reset.js","../src/virtualdom/Fragment.js","../src/virtualdom/Fragment/prototype/unrender.js","../src/virtualdom/Fragment/prototype/unbind.js","../src/virtualdom/Fragment/prototype/toString.js","../src/virtualdom/Fragment/prototype/render.js","../src/virtualdom/Fragment/prototype/rebind.js","../src/virtualdom/Fragment/prototype/init.js","../src/virtualdom/items/Doctype.js","../src/virtualdom/items/Yielder.js","../src/virtualdom/items/Comment.js","../src/virtualdom/items/Component/_Component.js","../src/virtualdom/items/Component/prototype/unrender.js","../src/virtualdom/items/Component/prototype/unbind.js","../src/virtualdom/items/Component/prototype/toString.js","../src/virtualdom/items/Component/prototype/render.js","../src/virtualdom/items/Component/prototype/rebind.js","../src/virtualdom/items/Component/prototype/init.js","../src/virtualdom/items/Component/initialise/updateLiveQueries.js","../src/virtualdom/items/Component/initialise/propagateEvents.js","../src/virtualdom/items/Component/initialise/createInstance.js","../src/virtualdom/items/Component/initialise/ComplexParameter.js","../src/Ractive/initialise.js","../src/Ractive/helpers/getComputationSignatures.js","../src/Ractive/prototype/shared/hooks/HookQueue.js","../src/viewmodel/Viewmodel.js","../src/viewmodel/prototype/unregister.js","../src/viewmodel/prototype/teardown.js","../src/viewmodel/prototype/smartUpdate.js","../src/viewmodel/prototype/set.js","../src/viewmodel/prototype/reset.js","../src/viewmodel/prototype/release.js","../src/viewmodel/prototype/register.js","../src/viewmodel/prototype/merge.js","../src/viewmodel/prototype/merge/mapOldToNewIndex.js","../src/viewmodel/prototype/mark.js","../src/viewmodel/prototype/map.js","../src/viewmodel/prototype/init.js","../src/viewmodel/prototype/get.js","../src/viewmodel/prototype/compute.js","../src/viewmodel/Computation/Computation.js","../src/viewmodel/Computation/UnresolvedDependency.js","../src/viewmodel/prototype/clearCache.js","../src/viewmodel/prototype/capture.js","../src/viewmodel/prototype/applyChanges.js","../src/viewmodel/prototype/applyChanges/notifyPatternObservers.js","../src/viewmodel/helpers/getUpstreamChanges.js","../src/viewmodel/prototype/adapt.js","../src/Ractive/static/adaptors/magicArray.js","../src/Ractive/static/adaptors/magic.js","../src/utils/createBranch.js","../src/Ractive/static/adaptors/array/index.js","../src/Ractive/static/adaptors/array/patch.js","../src/Ractive/static/adaptors/array/processWrapper.js","../src/virtualdom/items/Component/prototype/firstNode.js","../src/virtualdom/items/Component/prototype/findNextNode.js","../src/virtualdom/items/Component/prototype/findComponent.js","../src/virtualdom/items/Component/prototype/findAllComponents.js","../src/virtualdom/items/Component/prototype/findAll.js","../src/virtualdom/items/Component/prototype/find.js","../src/virtualdom/items/Component/prototype/detach.js","../src/virtualdom/items/Component/getComponent.js","../src/virtualdom/items/Partial/_Partial.js","../src/virtualdom/items/Partial/applyIndent.js","../src/virtualdom/items/Partial/getPartialTemplate.js","../src/virtualdom/items/Partial/deIndent.js","../src/virtualdom/items/Element/_Element.js","../src/virtualdom/items/Element/prototype/unrender.js","../src/virtualdom/items/Element/prototype/unbind.js","../src/virtualdom/items/Element/prototype/toString.js","../src/virtualdom/items/Element/prototype/render.js","../src/virtualdom/items/Element/Transition/_Transition.js","../src/virtualdom/items/Element/Transition/prototype/start.js","../src/virtualdom/items/Element/Transition/prototype/processParams.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js","../src/virtualdom/items/Element/Transition/helpers/hyphenate.js","../src/virtualdom/items/Element/Transition/helpers/unprefix.js","../src/shared/Ticker.js","../src/virtualdom/items/Element/Transition/prototype/setStyle.js","../src/virtualdom/items/Element/Transition/prototype/getStyle.js","../src/virtualdom/items/Element/Transition/helpers/prefix.js","../src/utils/camelCase.js","../src/virtualdom/items/Element/Transition/prototype/init.js","../src/virtualdom/items/Element/special/form.js","../src/virtualdom/items/Element/special/img.js","../src/virtualdom/items/Element/prototype/rebind.js","../src/virtualdom/items/Element/prototype/init.js","../src/virtualdom/items/Element/special/option.js","../src/virtualdom/items/Element/special/select.js","../src/virtualdom/items/Element/Decorator/_Decorator.js","../src/virtualdom/items/Element/prototype/init/createEventHandlers.js","../src/virtualdom/items/Element/EventHandler/_EventHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/unrender.js","../src/virtualdom/items/Element/EventHandler/prototype/unbind.js","../src/virtualdom/items/Element/EventHandler/prototype/resolve.js","../src/virtualdom/items/Element/EventHandler/prototype/render.js","../src/virtualdom/items/Element/EventHandler/prototype/rebind.js","../src/virtualdom/items/Element/EventHandler/prototype/listen.js","../src/virtualdom/items/Element/EventHandler/shared/genericHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/init.js","../src/virtualdom/items/Element/EventHandler/prototype/getAction.js","../src/virtualdom/items/Element/EventHandler/prototype/fire.js","../src/virtualdom/items/Element/EventHandler/prototype/bubble.js","../src/virtualdom/items/Element/prototype/init/createTwowayBinding.js","../src/virtualdom/items/Element/Binding/NumericBinding.js","../src/virtualdom/items/Element/Binding/FileListBinding.js","../src/virtualdom/items/Element/Binding/MultipleSelectBinding.js","../src/virtualdom/items/Element/Binding/SelectBinding.js","../src/virtualdom/items/Element/Binding/CheckboxBinding.js","../src/virtualdom/items/Element/Binding/CheckboxNameBinding.js","../src/virtualdom/items/Element/Binding/RadioNameBinding.js","../src/virtualdom/items/Element/Binding/RadioBinding.js","../src/virtualdom/items/Element/Binding/shared/getSiblings.js","../src/virtualdom/items/Element/Binding/ContentEditableBinding.js","../src/virtualdom/items/Element/Binding/GenericBinding.js","../src/virtualdom/items/Element/Binding/shared/handleDomEvent.js","../src/virtualdom/items/Element/Binding/Binding.js","../src/virtualdom/items/Element/prototype/init/createConditionalAttributes.js","../src/virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js","../src/virtualdom/items/Element/prototype/init/createAttributes.js","../src/virtualdom/items/Element/Attribute/_Attribute.js","../src/virtualdom/items/Element/Attribute/prototype/update.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateClassName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/unbind.js","../src/virtualdom/items/Element/Attribute/prototype/toString.js","../src/virtualdom/items/Element/Attribute/prototype/render.js","../src/virtualdom/items/Element/Attribute/prototype/rebind.js","../src/virtualdom/items/Element/Attribute/prototype/init.js","../src/virtualdom/items/Element/Attribute/helpers/getInterpolator.js","../src/virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js","../src/virtualdom/items/Element/shared/enforceCase.js","../src/virtualdom/items/Element/Attribute/prototype/bubble.js","../src/virtualdom/items/Element/prototype/init/processBindingAttributes.js","../src/virtualdom/items/Element/prototype/getAttribute.js","../src/virtualdom/items/Element/prototype/firstNode.js","../src/virtualdom/items/Element/prototype/findNextNode.js","../src/virtualdom/items/Element/prototype/findComponent.js","../src/virtualdom/items/Element/prototype/findAllComponents.js","../src/virtualdom/items/Element/prototype/findAll.js","../src/virtualdom/items/Element/prototype/find.js","../src/virtualdom/items/Element/prototype/detach.js","../src/virtualdom/items/Element/prototype/bubble.js","../src/virtualdom/items/Triple/_Triple.js","../src/virtualdom/items/Triple/prototype/update.js","../src/virtualdom/items/Triple/prototype/unrender.js","../src/virtualdom/items/Triple/prototype/toString.js","../src/virtualdom/items/Triple/prototype/setValue.js","../src/virtualdom/items/Triple/prototype/render.js","../src/virtualdom/items/Triple/helpers/updateSelect.js","../src/virtualdom/items/Triple/helpers/insertHtml.js","../src/virtualdom/items/Triple/prototype/firstNode.js","../src/virtualdom/items/Triple/prototype/findAll.js","../src/virtualdom/items/Triple/prototype/find.js","../src/virtualdom/items/Triple/prototype/detach.js","../src/virtualdom/items/Section/_Section.js","../src/virtualdom/items/Section/prototype/update.js","../src/virtualdom/items/Section/prototype/unrender.js","../src/virtualdom/items/Section/prototype/unbind.js","../src/virtualdom/items/Section/prototype/toString.js","../src/virtualdom/items/Section/prototype/setValue.js","../src/virtualdom/items/Section/prototype/render.js","../src/virtualdom/items/Section/prototype/rebind.js","../src/virtualdom/items/Section/prototype/shuffle.js","../src/virtualdom/items/Section/prototype/firstNode.js","../src/virtualdom/items/Section/prototype/findNextNode.js","../src/virtualdom/items/Section/prototype/findComponent.js","../src/virtualdom/items/Section/prototype/findAllComponents.js","../src/virtualdom/items/Section/prototype/findAll.js","../src/virtualdom/items/Section/prototype/find.js","../src/virtualdom/items/Section/prototype/detach.js","../src/virtualdom/items/Section/prototype/bubble.js","../src/virtualdom/items/Interpolator.js","../src/virtualdom/items/shared/Mustache/_Mustache.js","../src/virtualdom/items/shared/Mustache/rebind.js","../src/virtualdom/items/shared/Mustache/resolve.js","../src/virtualdom/items/shared/Mustache/initialise.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js","../src/virtualdom/items/shared/Resolvers/ExpressionResolver.js","../src/shared/getFunctionFromString.js","../src/virtualdom/items/shared/Resolvers/createReferenceResolver.js","../src/virtualdom/items/shared/Resolvers/findIndexRefs.js","../src/virtualdom/items/shared/Resolvers/IndexResolver.js","../src/virtualdom/items/shared/Resolvers/SpecialResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceResolver.js","../src/virtualdom/items/shared/Mustache/getValue.js","../src/virtualdom/items/shared/unbind.js","../src/virtualdom/items/Text.js","../src/virtualdom/items/shared/detach.js","../src/virtualdom/Fragment/prototype/getValue.js","../src/virtualdom/Fragment/prototype/getNode.js","../src/virtualdom/Fragment/prototype/getArgsList.js","../src/virtualdom/Fragment/prototype/shared/processItems.js","../src/virtualdom/Fragment/prototype/firstNode.js","../src/virtualdom/Fragment/prototype/findNextNode.js","../src/virtualdom/Fragment/prototype/findComponent.js","../src/virtualdom/Fragment/prototype/findAllComponents.js","../src/virtualdom/Fragment/prototype/findAll.js","../src/virtualdom/Fragment/prototype/find.js","../src/virtualdom/Fragment/prototype/detach.js","../src/virtualdom/Fragment/prototype/bubble.js","../src/Ractive/config/config.js","../src/Ractive/config/deprecate.js","../src/Ractive/config/wrapPrototypeMethod.js","../src/Ractive/config/registries.js","../src/Ractive/config/custom/template/template.js","../src/Ractive/config/custom/template/parser.js","../src/parse/_parse.js","../src/parse/converters/readTemplate.js","../src/parse/converters/readPartialDefinitionSection.js","../src/parse/converters/readPartialDefinitionComment.js","../src/utils/escapeRegExp.js","../src/parse/converters/readText.js","../src/parse/converters/readElement.js","../src/parse/converters/element/processDirective.js","../src/utils/parseJSON.js","../src/parse/converters/element/readAttribute.js","../src/parse/converters/utils/getLowestIndex.js","../src/parse/converters/element/readClosingTag.js","../src/parse/utils/cleanup.js","../src/parse/utils/trimWhitespace.js","../src/parse/utils/stripStandalones.js","../src/utils/html.js","../src/parse/converters/readHtmlComment.js","../src/parse/converters/mustache/readSection.js","../src/parse/converters/mustache/handlebarsBlockCodes.js","../src/parse/converters/mustache/section/readElseIf.js","../src/parse/converters/mustache/section/readElse.js","../src/parse/converters/mustache/section/readClosing.js","../src/parse/converters/mustache/readYielder.js","../src/parse/converters/mustache/readInterpolator.js","../src/parse/converters/readExpressionOrReference.js","../src/parse/converters/mustache/readMustacheComment.js","../src/parse/converters/mustache/readPartial.js","../src/parse/converters/mustache/readUnescaped.js","../src/parse/converters/mustache/readTriple.js","../src/parse/utils/refineExpression.js","../src/parse/utils/flattenExpression.js","../src/parse/converters/readExpression.js","../src/parse/converters/expressions/readConditional.js","../src/parse/converters/expressions/readLogicalOr.js","../src/parse/converters/expressions/readTypeof.js","../src/parse/converters/expressions/readMemberOrInvocation.js","../src/parse/converters/expressions/shared/readRefinement.js","../src/parse/converters/expressions/readPrimary.js","../src/parse/converters/expressions/primary/readBracketedExpression.js","../src/parse/converters/expressions/primary/readReference.js","../src/parse/converters/expressions/primary/readLiteral.js","../src/parse/converters/expressions/primary/literal/readArrayLiteral.js","../src/parse/converters/expressions/shared/readExpressionList.js","../src/parse/converters/expressions/primary/literal/readObjectLiteral.js","../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePairs.js","../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePair.js","../src/parse/converters/expressions/shared/readKey.js","../src/parse/converters/expressions/shared/patterns.js","../src/parse/converters/expressions/primary/literal/readStringLiteral.js","../src/parse/converters/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js","../src/parse/converters/expressions/primary/literal/readBooleanLiteral.js","../src/parse/converters/expressions/primary/literal/readNumberLiteral.js","../src/parse/converters/expressions/shared/errors.js","../src/parse/converters/readMustache.js","../src/parse/converters/expressions/primary/literal/readRegexpLiteral.js","../src/parse/converters/mustache/readDelimiterChange.js","../src/config/types.js","../src/parse/Parser.js","../src/Ractive/config/custom/data.js","../src/Ractive/config/custom/css/css.js","../src/Ractive/config/custom/css/transform.js","../src/Ractive/config/custom/adapt.js","../src/Ractive/prototype/render.js","../src/global/css.js","../src/Ractive/prototype/push.js","../src/Ractive/prototype/pop.js","../src/Ractive/prototype/shared/makeArrayMethod.js","../src/shared/getNewIndices.js","../src/Ractive/prototype/once.js","../src/Ractive/prototype/on.js","../src/Ractive/prototype/off.js","../src/Ractive/prototype/shared/notEmptyString.js","../src/Ractive/prototype/shared/trim.js","../src/Ractive/prototype/observeOnce.js","../src/Ractive/prototype/observe.js","../src/Ractive/prototype/observe/getObserverFacade.js","../src/Ractive/prototype/observe/PatternObserver.js","../src/Ractive/prototype/observe/getPattern.js","../src/Ractive/prototype/observe/Observer.js","../src/Ractive/prototype/merge.js","../src/Ractive/prototype/insert.js","../src/Ractive/prototype/get.js","../src/Ractive/prototype/fire.js","../src/Ractive/prototype/shared/fireEvent.js","../src/Ractive/prototype/shared/eventStack.js","../src/Ractive/prototype/findParent.js","../src/Ractive/prototype/findContainer.js","../src/Ractive/prototype/findComponent.js","../src/Ractive/prototype/findAllComponents.js","../src/Ractive/prototype/findAll.js","../src/Ractive/prototype/shared/makeQuery/_makeQuery.js","../src/Ractive/prototype/shared/makeQuery/remove.js","../src/Ractive/prototype/shared/makeQuery/dirty.js","../src/Ractive/prototype/shared/makeQuery/sort.js","../src/Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js","../src/Ractive/prototype/shared/makeQuery/sortByItemPosition.js","../src/Ractive/prototype/shared/makeQuery/cancel.js","../src/Ractive/prototype/shared/makeQuery/test.js","../src/Ractive/prototype/find.js","../src/Ractive/prototype/detach.js","../src/Ractive/prototype/animate.js","../src/Ractive/prototype/animate/Animation.js","../src/shared/animations.js","../src/global/runloop.js","../src/global/TransitionManager.js","../src/shared/methodCallers.js","../src/shared/resolveRef.js","../src/shared/getInnerContext.js","../src/utils/Promise.js","../src/utils/array.js","../src/Ractive/prototype/shared/hooks/Hook.js","../src/utils/getTime.js","../src/utils/requestAnimationFrame.js","../src/Ractive/prototype/add.js","../src/Ractive/prototype/shared/add.js","../src/shared/keypaths.js","../src/utils/getPotentialWildcardMatches.js","../src/Ractive/static/interpolators.js","../src/shared/interpolate.js","../src/shared/registry.js","../src/config/errors.js","../src/utils/log.js","../src/utils/noop.js","../src/utils/is.js","../src/utils/object.js","../src/legacy.js","../src/utils/dom.js","../src/config/environment.js","../src/Ractive/static/easing.js","../src/Ractive/config/defaults.js","../src/config/template.js"],"sourcesContent":["import defaults from 'Ractive/config/defaults';\nimport easing from 'Ractive/static/easing';\nimport interpolators from 'Ractive/static/interpolators';\nimport { magic, svg } from 'config/environment';\nimport { defineProperties, extend as extendObj } from 'utils/object';\nimport proto from 'Ractive/prototype';\nimport Promise from 'utils/Promise';\nimport extend from 'extend/_extend';\nimport parse from 'parse/_parse';\nimport getNodeInfo from 'Ractive/static/getNodeInfo';\nimport initialise from 'Ractive/initialise';\n\nvar Ractive, properties;\n\n// Main Ractive required object\nRactive = function ( options ) {\n\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\tinitialise( this, options );\n};\n\n\n// Ractive properties\nproperties = {\n\n\t// debug flag\n\tDEBUG:          { writable: true, value: true },\n\tDEBUG_PROMISES: { writable: true, value: true },\n\n\t// static methods:\n\textend:         { value: extend },\n\tgetNodeInfo:    { value: getNodeInfo },\n\tparse:          { value: parse },\n\n\t// Namespaced constructors\n\tPromise:        { value: Promise },\n\n\t// support\n\tsvg:            { value: svg },\n\tmagic:          { value: magic },\n\n\t// version\n\tVERSION:        { value: '<@version@>' },\n\n\t// Plugins\n\tadaptors:       { writable: true, value: {} },\n\tcomponents:     { writable: true, value: {} },\n\tdecorators:     { writable: true, value: {} },\n\teasing:         { writable: true, value: easing },\n\tevents:         { writable: true, value: {} },\n\tinterpolators:  { writable: true, value: interpolators },\n\tpartials:       { writable: true, value: {} },\n\ttransitions:    { writable: true, value: {} }\n};\n\n\n// Ractive properties\ndefineProperties( Ractive, properties );\n\nRactive.prototype = extendObj( proto, defaults );\n\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as defaults\nRactive.defaults = Ractive.prototype;\n\n// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n// older browsers, these are made available via a shim - here, we do a quick\n// pre-flight check to make sure that either a) we're not in a shit browser,\n// or b) we're using a Ractive-legacy.js build\nvar FUNCTION = 'function';\n\nif (\n\ttypeof Date.now !== FUNCTION                 ||\n\ttypeof String.prototype.trim !== FUNCTION    ||\n\ttypeof Object.keys !== FUNCTION              ||\n\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\ttypeof Array.prototype.map !== FUNCTION      ||\n\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t( typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION )\n) {\n\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n}\n\nexport default Ractive;\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function( node ) {\n\tvar info = {}, priv, indices;\n\n\tif ( !node || !( priv = node._ractive ) ) {\n\t\treturn info;\n\t}\n\n\tinfo.ractive = priv.root;\n\tinfo.keypath = priv.keypath.str;\n\tinfo.index = {};\n\n\t// find all index references and resolve them\n\tif ( indices = findIndexRefs( priv.proxy.parentFragment ) ) {\n\t\tinfo.index = findIndexRefs.resolve( indices );\n\t}\n\n\treturn info;\n}\n","import { create, defineProperties, extend as extendObj } from 'utils/object';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport initialise from 'Ractive/initialise';\nimport Ractive from 'Ractive';\nimport unwrapExtended from './unwrapExtended';\n\nexport default extend;\n\nfunction extend ( ...options ) {\n\tif( !options.length ) {\n\t\treturn extendOne( this );\n\t} else {\n\t\treturn options.reduce( extendOne, this );\n\t}\n}\n\nfunction extendOne ( Parent, options = {} ) {\n\tvar Child, proto;\n\n\t// if we're extending with another Ractive instance...\n\t//\n\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t//   var Spiderman = Human.extend( Spider );\n\t//\n\t// ...inherit prototype methods and default options as well\n\tif ( options.prototype instanceof Ractive ) {\n\t\toptions = unwrapExtended( options );\n\t}\n\n\tChild = function ( options ) {\n\t\tif ( !( this instanceof Child ) ) return new Child( options );\n\t\tinitialise( this, options );\n\t};\n\n\tproto = create( Parent.prototype );\n\tproto.constructor = Child;\n\n\t// Static properties\n\tdefineProperties( Child, {\n\t\t// alias prototype as defaults\n\t\tdefaults: { value: proto },\n\n\t\t// extendable\n\t\textend: { value: extend, writable: true, configurable: true },\n\n\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t_Parent: { value: Parent }\n\t});\n\n\t// extend configuration\n\tconfig.extend( Parent, proto, options );\n\n\tdataConfigurator.extend( Parent, proto, options );\n\n\tif ( options.computed ) {\n\t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t}\n\n\tChild.prototype = proto;\n\n\treturn Child;\n}\n","import wrap from 'utils/wrapMethod';\nimport registries from 'Ractive/config/registries';\nimport Ractive from 'Ractive';\n\nexport default function unwrap ( Child ) {\n\tlet options = {};\n\n\twhile ( Child ) {\n\t\taddRegistries( Child, options );\n\t\taddOtherOptions( Child, options );\n\n\t\tif ( Child._Parent !== Ractive ) {\n\t\t\tChild = Child._Parent;\n\t\t} else {\n\t\t\tChild = false;\n\t\t}\n\t}\n\n\treturn options;\n}\n\nfunction addRegistries ( Child, options ) {\n\tregistries.forEach( r => {\n\t\taddRegistry(\n\t\t\tr.useDefaults ? Child.prototype : Child,\n\t\t\toptions, r.name );\n\t});\n}\n\nfunction addRegistry ( target, options, name ) {\n\tvar registry, keys = Object.keys( target[ name ] );\n\n\tif ( !keys.length ) { return; }\n\n\tif ( !( registry = options[ name ] ) ) {\n\t\tregistry = options[ name ] = {};\n\t}\n\n\tkeys\n\t\t.filter( key => !( key in registry ) )\n\t\t.forEach( key => registry[ key ] = target[ name ][ key ] );\n}\n\nfunction addOtherOptions ( Child, options ) {\n\tObject.keys( Child.prototype ).forEach( key => {\n\t\tif ( key === 'computed' ) { return; }\n\n\t\tvar value = Child.prototype[ key ];\n\n\t\tif ( !( key in options ) ) {\n\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t}\n\n\t\t// is it a wrapped function?\n\t\telse if ( typeof options[ key ] === 'function'\n\t\t\t\t&& typeof value === 'function'\n\t\t\t\t&& options[ key ]._method ) {\n\n\t\t\tlet result, needsSuper = value._method;\n\n\t\t\tif ( needsSuper ) { value = value._method; }\n\n\t\t\t// rewrap bound directly to parent fn\n\t\t\tresult = wrap( options[ key ]._method, value );\n\n\t\t\tif ( needsSuper ) { result._method = result; }\n\n\t\t\toptions[ key ] = result;\n\t\t}\n\t});\n}","export default function ( method, superMethod, force ) {\n\n\tif ( force || needsSuper( method, superMethod ) )  {\n\n\t\treturn function () {\n\n\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n\t\t\tthis._super = superMethod;\n\n\t\t\tresult = method.apply( this, arguments );\n\n\t\t\tif ( hasSuper ) {\n\t\t\t\tthis._super = _super;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\telse {\n\t\treturn method;\n\t}\n}\n\nfunction needsSuper ( method, superMethod ) {\n\treturn typeof superMethod === 'function' && /_super/.test( method );\n}\n","import add from 'Ractive/prototype/add';\nimport animate from 'Ractive/prototype/animate';\nimport detach from 'Ractive/prototype/detach';\nimport find from 'Ractive/prototype/find';\nimport findAll from 'Ractive/prototype/findAll';\nimport findAllComponents from 'Ractive/prototype/findAllComponents';\nimport findComponent from 'Ractive/prototype/findComponent';\nimport findContainer from 'Ractive/prototype/findContainer';\nimport findParent from 'Ractive/prototype/findParent';\nimport fire from 'Ractive/prototype/fire';\nimport get from 'Ractive/prototype/get';\nimport insert from 'Ractive/prototype/insert';\nimport merge from 'Ractive/prototype/merge';\nimport observe from 'Ractive/prototype/observe';\nimport observeOnce from 'Ractive/prototype/observeOnce';\nimport off from 'Ractive/prototype/off';\nimport on from 'Ractive/prototype/on';\nimport once from 'Ractive/prototype/once';\nimport pop from 'Ractive/prototype/pop';\nimport push from 'Ractive/prototype/push';\nimport render from 'Ractive/prototype/render';\nimport reset from 'Ractive/prototype/reset';\nimport resetPartial from 'Ractive/prototype/resetPartial';\nimport resetTemplate from 'Ractive/prototype/resetTemplate';\nimport reverse from 'Ractive/prototype/reverse';\nimport set from 'Ractive/prototype/set';\nimport shift from 'Ractive/prototype/shift';\nimport sort from 'Ractive/prototype/sort';\nimport splice from 'Ractive/prototype/splice';\nimport subtract from 'Ractive/prototype/subtract';\nimport teardown from 'Ractive/prototype/teardown';\nimport toggle from 'Ractive/prototype/toggle';\nimport toHTML from 'Ractive/prototype/toHTML';\nimport unrender from 'Ractive/prototype/unrender';\nimport unshift from 'Ractive/prototype/unshift';\nimport update from 'Ractive/prototype/update';\nimport updateModel from 'Ractive/prototype/updateModel';\n\nexport default {\n\tadd: add,\n\tanimate: animate,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindContainer: findContainer,\n\tfindParent: findParent,\n\tfire: fire,\n\tget: get,\n\tinsert: insert,\n\tmerge: merge,\n\tobserve: observe,\n\tobserveOnce: observeOnce,\n\toff: off,\n\ton: on,\n\tonce: once,\n\tpop: pop,\n\tpush: push,\n\trender: render,\n\treset: reset,\n\tresetPartial: resetPartial,\n\tresetTemplate: resetTemplate,\n\treverse: reverse,\n\tset: set,\n\tshift: shift,\n\tsort: sort,\n\tsplice: splice,\n\tsubtract: subtract,\n\tteardown: teardown,\n\ttoggle: toggle,\n\ttoHTML: toHTML,\n\ttoHtml: toHTML,\n\tunrender: unrender,\n\tunshift: unshift,\n\tupdate: update,\n\tupdateModel: updateModel\n};\n","import { arrayContentsMatch } from 'utils/array';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\n\nexport default function Ractive$updateModel ( keypath, cascade ) {\n\tvar values, key, bindings;\n\n\tif ( typeof keypath === 'string' && !cascade ) {\n\t\tbindings = this._twowayBindings[ keypath ];\n\t} else {\n\t\tbindings = [];\n\n\t\tfor ( key in this._twowayBindings ) {\n\t\t\tif ( !keypath || getKeypath( key ).equalsOrStartsWith( keypath ) ) { // TODO is this right?\n\t\t\t\tbindings.push.apply( bindings, this._twowayBindings[ key ]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalues = consolidate( this, bindings );\n\treturn this.set( values );\n}\n\nfunction consolidate ( ractive, bindings ) {\n\tvar values = {}, checkboxGroups = [];\n\n\tbindings.forEach( b => {\n\t\tvar oldValue, newValue;\n\n\t\t// special case - radio name bindings\n\t\tif ( b.radioName && !b.element.node.checked ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - checkbox name bindings come in groups, so\n\t\t// we want to get the value once at most\n\t\tif ( b.checkboxName ) {\n\t\t\tif ( !checkboxGroups[ b.keypath.str ] && !b.changed() ) {\n\t\t\t\tcheckboxGroups.push( b.keypath );\n\t\t\t\tcheckboxGroups[ b.keypath.str ] = b;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\toldValue = b.attribute.value;\n\t\tnewValue = b.getValue();\n\n\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\tvalues[ b.keypath.str ] = newValue;\n\t\t}\n\t});\n\n\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\tif ( checkboxGroups.length ) {\n\t\tcheckboxGroups.forEach( keypath => {\n\t\t\tvar binding, oldValue, newValue;\n\n\t\t\tbinding = checkboxGroups[ keypath.str ]; // one to represent the entire group\n\t\t\toldValue = binding.attribute.value;\n\t\t\tnewValue = binding.getValue();\n\n\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\tvalues[ keypath.str ] = newValue;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn values;\n}\n","import Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { getKeypath, rootKeypath } from 'shared/keypaths';\n\nvar updateHook = new Hook( 'update' );\n\nexport default function Ractive$update ( keypath ) {\n\tvar promise;\n\n\tkeypath = getKeypath( keypath ) || rootKeypath;\n\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.mark( keypath );\n\trunloop.end();\n\n\tupdateHook.fire( this, keypath );\n\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'unshift' );\n","import Hook from './shared/hooks/Hook';\nimport { warnIfDebug } from 'utils/log';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nvar unrenderHook = new Hook( 'unrender' );\n\nexport default function Ractive$unrender () {\n\tvar promise, shouldDestroy;\n\n\tif ( !this.fragment.rendered ) {\n\t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\treturn Promise.resolve();\n\t}\n\n\tpromise = runloop.start( this, true );\n\n\t// If this is a component, and the component isn't marked for destruction,\n\t// don't detach nodes from the DOM unnecessarily\n\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n\t// Cancel any animations in progress\n\twhile ( this._animations[0] ) {\n\t\tthis._animations[0].stop(); // it will remove itself from the index\n\t}\n\n\tthis.fragment.unrender( shouldDestroy );\n\n\tremoveFromArray( this.el.__ractive_instances__, this );\n\n\tunrenderHook.fire( this );\n\n\trunloop.end();\n\treturn promise;\n}\n","export default function Ractive$toHTML () {\n\treturn this.fragment.toString( true );\n}\n","import { badArguments } from 'config/errors';\nimport { getKeypath, getMatchingKeypaths, normalise } from 'shared/keypaths';\n\nexport default function Ractive$toggle ( keypath ) {\n\tif ( typeof keypath !== 'string' ) {\n\t\tthrow new TypeError( badArguments );\n\t}\n\n\tlet changes;\n\n\tif ( /\\*/.test( keypath ) ) {\n\t\tchanges = {};\n\n\t\tgetMatchingKeypaths( this, getKeypath( normalise( keypath ) ) ).forEach( keypath => {\n\t\t\tchanges[ keypath.str ] = !this.viewmodel.get( keypath );\n\t\t});\n\n\t\treturn this.set( changes );\n\t}\n\n\treturn this.set( keypath, !this.get( keypath ) );\n}\n","import Hook from './shared/hooks/Hook';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport { cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nexport default function Ractive$teardown () {\n\tvar promise;\n\n\tthis.fragment.unbind();\n\tthis.viewmodel.teardown();\n\n\tthis._observers.forEach( cancel );\n\n\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\n\tthis.shouldDestroy = true;\n\tpromise = ( this.fragment.rendered ? this.unrender() : Promise.resolve() );\n\n\tteardownHook.fire( this );\n\n\tthis._boundFunctions.forEach( deleteFunctionCopy );\n\n\treturn promise;\n}\n\nfunction deleteFunctionCopy ( bound ) {\n\tdelete bound.fn[ bound.prop ];\n}","import add from './shared/add';\n\nexport default function Ractive$subtract ( keypath, d ) {\n\treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'splice' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'sort' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'shift' );\n","import { isObject } from 'utils/is';\nimport { getMatchingKeypaths, getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\n\nexport default function Ractive$set ( keypath, value ) {\n\tvar map, promise;\n\n\tpromise = runloop.start( this, true );\n\n\t// Set multiple keypaths in one go\n\tif ( isObject( keypath ) ) {\n\t\tmap = keypath;\n\n\t\tfor ( keypath in map ) {\n\t\t\tif ( map.hasOwnProperty( keypath) ) {\n\t\t\t\tvalue = map[ keypath ];\n\t\t\t\tset( this, keypath, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set a single keypath\n\telse {\n\t\tset( this, keypath, value );\n\t}\n\n\trunloop.end();\n\n\treturn promise;\n}\n\nfunction set ( ractive, keypath, value ) {\n\tkeypath = getKeypath( normalise( keypath ) );\n\n\tif ( keypath.isPattern ) {\n\t\tgetMatchingKeypaths( ractive, keypath ).forEach( keypath => {\n\t\t\tractive.viewmodel.set( keypath, value );\n\t\t});\n\t} else {\n\t\tractive.viewmodel.set( keypath, value );\n\t}\n}","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'reverse' );\n","import { default as templateConfigurator } from 'Ractive/config/custom/template/template';\nimport Fragment from 'virtualdom/Fragment';\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nexport default function Ractive$resetTemplate ( template ) {\n\tvar transitionsEnabled, component;\n\n\ttemplateConfigurator.init( null, this, { template: template });\n\n\ttransitionsEnabled = this.transitionsEnabled;\n\tthis.transitionsEnabled = false;\n\n\t// Is this is a component, we need to set the `shouldDestroy`\n\t// flag, otherwise it will assume by default that a parent node\n\t// will be detached, and therefore it doesn't need to bother\n\t// detaching its own nodes\n\tif ( component = this.component ) {\n\t\tcomponent.shouldDestroy = true;\n\t}\n\n\tthis.unrender();\n\n\tif ( component ) {\n\t\tcomponent.shouldDestroy = false;\n\t}\n\n\t// remove existing fragment and create new one\n\tthis.fragment.unbind();\n\tthis.fragment = new Fragment({\n\t\ttemplate: this.template,\n\t\troot: this,\n\t\towner: this\n\t});\n\n\tthis.render( this.el, this.anchor );\n\n\tthis.transitionsEnabled = transitionsEnabled;\n}\n","import { isArray } from 'utils/is';\nimport runloop from 'global/runloop';\nimport { PARTIAL, COMPONENT, ELEMENT } from 'config/types';\n\nexport default function ( name, partial ) {\n\tvar promise, collection = [];\n\n\tfunction collect( source, dest, ractive ) {\n\t\t// if this is a component and it has its own partial, bail\n\t\tif ( ractive && ractive.partials[name] ) return;\n\n\t\tsource.forEach( item => {\n\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\tif ( item.type === PARTIAL && item.getPartialName() === name ) {\n\t\t\t\tdest.push( item );\n\t\t\t}\n\n\t\t\t// if it has a fragment, process its items\n\t\t\tif ( item.fragment ) {\n\t\t\t\tcollect( item.fragment.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it has fragments\n\t\t\tif ( isArray( item.fragments ) ) {\n\t\t\t\tcollect( item.fragments, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is itself a fragment, process its items\n\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\tcollect( item.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is a component, step in and process its items\n\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\tcollect( item.instance.fragment.items, dest, item.instance );\n\t\t\t}\n\n\t\t\t// if the item is an element, process its attributes too\n\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\tcollect( item.attributes, dest, ractive );\n\t\t\t\t}\n\n\t\t\t\tif ( isArray( item.conditionalAttributes ) ) {\n\t\t\t\t\tcollect( item.conditionalAttributes, dest, ractive );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tcollect( this.fragment.items, collection );\n\tthis.partials[name] = partial;\n\n\tpromise = runloop.start( this, true );\n\n\tcollection.forEach( item => {\n\t\titem.value = undefined;\n\t\titem.setValue( name );\n\t});\n\n\trunloop.end();\n\n\treturn promise;\n}\n","import config from 'Ractive/config/config';\nimport Fragment from 'virtualdom/Fragment';\nimport Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { rootKeypath } from 'shared/keypaths';\n\nvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ],\n\tresetHook = new Hook( 'reset' );\n\nexport default function Ractive$reset ( data ) {\n\tvar promise, wrapper, changes, i, rerender;\n\n\tdata = data || {};\n\n\tif ( typeof data !== 'object' ) {\n\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t}\n\n\t// If the root object is wrapped, try and use the wrapper's reset value\n\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t// reset was rejected, we need to replace the object\n\t\t\tthis.viewmodel.reset( data );\n\t\t}\n\t} else {\n\t\tthis.viewmodel.reset( data );\n\t}\n\n\t// reset config items and track if need to rerender\n\tchanges = config.reset( this );\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\trerender = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( rerender ) {\n\t\tlet component;\n\n\t\tthis.viewmodel.mark( rootKeypath );\n\n\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t \t// flag, otherwise it will assume by default that a parent node\n\t \t// will be detached, and therefore it doesn't need to bother\n\t \t// detaching its own nodes\n\t \tif ( component = this.component ) {\n\t \t\tcomponent.shouldDestroy = true;\n\t \t}\n\n\t\tthis.unrender();\n\n\t\tif ( component ) {\n\t\t\tcomponent.shouldDestroy = false;\n\t\t}\n\n\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t// TODO if we're here, presumably it did?\n\t\tif ( this.fragment.template !== this.template ) {\n\t\t\tthis.fragment.unbind();\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tpromise = this.render( this.el, this.anchor );\n\t} else {\n\t\tpromise = runloop.start( this, true );\n\t\tthis.viewmodel.mark( rootKeypath );\n\t\trunloop.end();\n\t}\n\n\tresetHook.fire( this, data );\n\n\treturn promise;\n}\n","import bubble from './Fragment/prototype/bubble';\nimport detach from './Fragment/prototype/detach';\nimport find from './Fragment/prototype/find';\nimport findAll from './Fragment/prototype/findAll';\nimport findAllComponents from './Fragment/prototype/findAllComponents';\nimport findComponent from './Fragment/prototype/findComponent';\nimport findNextNode from './Fragment/prototype/findNextNode';\nimport firstNode from './Fragment/prototype/firstNode';\nimport getArgsList from './Fragment/prototype/getArgsList';\nimport getNode from './Fragment/prototype/getNode';\nimport getValue from './Fragment/prototype/getValue';\nimport init from './Fragment/prototype/init';\nimport rebind from './Fragment/prototype/rebind';\nimport render from './Fragment/prototype/render';\nimport toString from './Fragment/prototype/toString';\nimport unbind from './Fragment/prototype/unbind';\nimport unrender from './Fragment/prototype/unrender';\n\nvar Fragment = function ( options ) {\n\tthis.init( options );\n};\n\nFragment.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetArgsList: getArgsList,\n\tgetNode: getNode,\n\tgetValue: getValue,\n\tinit: init,\n\trebind: rebind,\n\tregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tif ( idxs.indexOf( idx ) === -1 ) {\n\t\t\tidxs.push( idx );\n\t\t}\n\t},\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tidxs.splice( idxs.indexOf( idx ), 1 );\n\t},\n\tunrender: unrender\n};\n\nexport default Fragment;\n","export default function Fragment$unrender ( shouldDestroy ) {\n\tif ( !this.rendered ) {\n\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t}\n\n\tthis.items.forEach( i => i.unrender( shouldDestroy ) );\n\tthis.rendered = false;\n}\n","export default function Fragment$unbind () {\n\tif ( !this.bound ) {\n\t\treturn;\n\t}\n\n\tthis.items.forEach( unbindItem );\n\tthis.bound = false;\n}\n\nfunction unbindItem ( item ) {\n\tif ( item.unbind ) {\n\t\titem.unbind();\n\t}\n}\n","export default function Fragment$toString ( escape ) {\n\tif ( !this.items ) {\n\t\treturn '';\n\t}\n\n\treturn this.items.map( escape ? toEscapedString : toString ).join( '' );\n}\n\nfunction toString ( item ) {\n\treturn item.toString();\n}\n\nfunction toEscapedString ( item ) {\n\treturn item.toString( true );\n}","export default function Fragment$render () {\n\tvar result;\n\n\tif ( this.items.length === 1 ) {\n\t\tresult = this.items[0].render();\n\t} else {\n\t\tresult = document.createDocumentFragment();\n\n\t\tthis.items.forEach( item => {\n\t\t\tresult.appendChild( item.render() );\n\t\t});\n\t}\n\n\tthis.rendered = true;\n\treturn result;\n}\n","import { assignNewKeypath } from 'shared/keypaths';\n\nexport default function Fragment$rebind ( oldKeypath, newKeypath ) {\n\n\t// assign new context keypath if needed\n\tif ( !this.owner || this.owner.hasContext ) {\n\t\tassignNewKeypath( this, 'context', oldKeypath, newKeypath );\n\t}\n\n\tthis.items.forEach( item => {\n\t\tif ( item.rebind ) {\n\t\t\titem.rebind( oldKeypath, newKeypath );\n\t\t}\n\t});\n}\n","import { YIELDER, INTERPOLATOR, SECTION, TRIPLE, ELEMENT, PARTIAL, COMMENT, DOCTYPE } from 'config/types';\nimport Text from 'virtualdom/items/Text';\nimport Interpolator from 'virtualdom/items/Interpolator';\nimport Section from 'virtualdom/items/Section/_Section';\nimport Triple from 'virtualdom/items/Triple/_Triple';\nimport Element from 'virtualdom/items/Element/_Element';\nimport Partial from 'virtualdom/items/Partial/_Partial';\nimport getComponent from 'virtualdom/items/Component/getComponent';\nimport Component from 'virtualdom/items/Component/_Component';\nimport Comment from 'virtualdom/items/Comment';\nimport Yielder from 'virtualdom/items/Yielder';\nimport Doctype from 'virtualdom/items/Doctype';\n\nexport default function Fragment$init ( options ) {\n\tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\tthis.parent = this.owner.parentFragment;\n\n\t// inherited properties\n\tthis.root = options.root;\n\tthis.pElement = options.pElement;\n\tthis.context = options.context;\n\tthis.index = options.index;\n\tthis.key = options.key;\n\tthis.registeredIndexRefs = [];\n\n\t// encapsulated styles should be inherited until they get applied by an element\n\tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\n\tthis.items = options.template.map( ( template, i ) => createItem({\n\t\tparentFragment: this,\n\t\tpElement: options.pElement,\n\t\ttemplate: template,\n\t\tindex: i\n\t}) );\n\n\tthis.value = this.argsList = null;\n\tthis.dirtyArgs = this.dirtyValue = true;\n\n\tthis.bound = true;\n}\n\nfunction createItem ( options ) {\n\tif ( typeof options.template === 'string' ) {\n\t\treturn new Text( options );\n\t}\n\n\tswitch ( options.template.t ) {\n\t\tcase YIELDER:      return new Yielder( options );\n\t\tcase INTERPOLATOR: return new Interpolator( options );\n\t\tcase SECTION:      return new Section( options );\n\t\tcase TRIPLE:       return new Triple( options );\n\t\tcase ELEMENT:\n\t\t\tlet constructor;\n\t\t\tif ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {\n\t\t\t\treturn new Component( options, constructor );\n\t\t\t}\n\t\t\treturn new Element( options );\n\t\tcase PARTIAL:      return new Partial( options );\n\t\tcase COMMENT:      return new Comment( options );\n\t\tcase DOCTYPE:      return new Doctype( options );\n\n\t\tdefault: throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );\n\t}\n}\n","import noop from 'utils/noop';\n\nvar Doctype = function ( options ) {\n\tthis.declaration = options.template.a;\n};\n\nDoctype.prototype = {\n\tinit: noop,\n\trender: noop,\n\tunrender: noop,\n\tteardown: noop,\n\ttoString () {\n\t\treturn '<!DOCTYPE' + this.declaration + '>';\n\t}\n};\n\nexport default Doctype;","import { YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\nimport { isArray } from 'utils/is';\n\nvar Yielder = function ( options ) {\n\tvar container, component;\n\n\tthis.type = YIELDER;\n\n\tthis.container = container = options.parentFragment.root;\n\tthis.component = component = container.component;\n\n\tthis.container = container;\n\tthis.containerFragment = options.parentFragment;\n\tthis.parentFragment = component.parentFragment;\n\n\tlet name = this.name = options.template.n || '';\n\n\tlet template = container._inlinePartials[ name ];\n\n\tif ( !template ) {\n\t\twarnIfDebug( `Could not find template for partial \"${name}\"`, { ractive: options.root });\n\t\ttemplate = [];\n\t}\n\n\tthis.fragment = new Fragment({\n\t\towner: this,\n\t\troot: container.parent,\n\t\ttemplate,\n\t\tpElement: this.containerFragment.pElement\n\t});\n\n\t// even though only one yielder is allowed, we need to have an array of them\n\t// as it's possible to cause a yielder to be created before the last one\n\t// was destroyed in the same turn of the runloop\n\tif ( !isArray( component.yielders[ name ] ) ) {\n\t\tcomponent.yielders[ name ] = [ this ];\n\t} else {\n\t\tcomponent.yielders[ name ].push( this );\n\t}\n\n\trunloop.scheduleTask( () => {\n\t\tif ( component.yielders[ name ].length > 1 ) {\n\t\t\tthrow new Error( 'A component template can only have one {{yield' + (name ? ' ' + name : '') + '}} declaration at a time' );\n\t\t}\n\t});\n};\n\nYielder.prototype = {\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfindNextNode () {\n\t\treturn this.containerFragment.findNextNode( this );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tgetValue ( options ) {\n\t\treturn this.fragment.getValue( options );\n\t},\n\n\trender () {\n\t\treturn this.fragment.render();\n\t},\n\n\tunbind () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tthis.fragment.unrender( shouldDestroy );\n\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\ttoString () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default Yielder;\n","import { COMMENT } from 'config/types';\nimport detach from './shared/detach';\n\nvar Comment = function ( options ) {\n\tthis.type = COMMENT;\n\tthis.value = options.template.c;\n};\n\nComment.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createComment( this.value );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString () {\n\t\treturn '<!--' + this.value + '-->';\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t}\n\t}\n};\n\nexport default Comment;\n","import detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Component = function ( options, Constructor ) {\n\tthis.init( options, Constructor );\n};\n\nComponent.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Component;\n","export default function Component$unrender ( shouldDestroy ) {\n\tthis.shouldDestroy = shouldDestroy;\n\tthis.instance.unrender();\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport { unbind, cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\nexport default function Component$unbind () {\n\tvar instance = this.instance;\n\n\tthis.resolvers.forEach( unbind );\n\n\tremoveFromLiveComponentQueries( this );\n\n\tinstance._observers.forEach( cancel );\n\n\t// teardown the instance\n\tinstance.fragment.unbind();\n\tinstance.viewmodel.teardown();\n\n\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t}\n\n\tteardownHook.fire( instance );\n}\n\nfunction removeFromLiveComponentQueries ( component ) {\n\tvar instance, query;\n\n\tinstance = component.root;\n\n\tdo {\n\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery._remove( component );\n\t\t}\n\t} while ( instance = instance.parent );\n}","export default function Component$toString () {\n\treturn this.instance.fragment.toString();\n}\n","export default function Component$render () {\n\tvar instance = this.instance;\n\n\tinstance.render( this.parentFragment.getNode() );\n\n\tthis.rendered = true;\n\treturn instance.fragment.detach();\n}\n","export default function Component$rebind ( oldKeypath, newKeypath ) {\n\tvar query;\n\n\tthis.resolvers.forEach( rebind );\n\n\tfor ( let k in this.yielders ) {\n\t\tif ( this.yielders[k][0] ) {\n\t\t\trebind( this.yielders[k][0] );\n\t\t}\n\t}\n\n\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\tquery._makeDirty();\n\t}\n\n\tfunction rebind ( x ) {\n\t\tx.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import createInstance from 'virtualdom/items/Component/initialise/createInstance';\nimport propagateEvents from 'virtualdom/items/Component/initialise/propagateEvents';\nimport { COMPONENT } from 'config/types';\nimport updateLiveQueries from 'virtualdom/items/Component/initialise/updateLiveQueries';\nimport { warnIfDebug } from 'utils/log';\n\nexport default function Component$init ( options, Component ) {\n\tvar parentFragment, root;\n\n\tif ( !Component ) {\n\t\tthrow new Error( 'Component \"' + this.name + '\" not found' );\n\t}\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\troot = parentFragment.root;\n\n\tthis.root = root;\n\tthis.type = COMPONENT;\n\tthis.name = options.template.e;\n\tthis.index = options.index;\n\tthis.indexRefBindings = {};\n\tthis.yielders = {};\n\tthis.resolvers = [];\n\n\tcreateInstance( this, Component, options.template.a, options.template.f, options.template.p );\n\tpropagateEvents( this, options.template.v );\n\n\t// intro, outro and decorator directives have no effect\n\tif ( options.template.t0 || options.template.t1 || options.template.t2 || options.template.o ) {\n\t\twarnIfDebug( 'The \"intro\", \"outro\" and \"decorator\" directives have no effect on components', { ractive: this.instance });\n\t}\n\n\tupdateLiveQueries( this );\n}\n","export default function ( component ) {\n\tvar ancestor, query;\n\n\t// If there's a live query for this component type, add it\n\tancestor = component.root;\n\twhile ( ancestor ) {\n\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery.push( component.instance );\n\t\t}\n\n\t\tancestor = ancestor.parent;\n\t}\n}\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal } from 'utils/log';\n\n// TODO how should event arguments be handled? e.g.\n// <widget on-foo='bar:1,2,3'/>\n// The event 'bar' will be fired on the parent instance\n// when 'foo' fires on the child, but the 1,2,3 arguments\n// will be lost\n\nexport default function propagateEvents ( component, eventsDescriptor ) {\n\tvar eventName;\n\n\tfor ( eventName in eventsDescriptor ) {\n\t\tif ( eventsDescriptor.hasOwnProperty( eventName ) ) {\n\t\t\tpropagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );\n\t\t}\n\t}\n}\n\nfunction propagateEvent ( childInstance, parentInstance, eventName, proxyEventName ) {\n\tif ( typeof proxyEventName !== 'string' ) {\n\t\tfatal( 'Components currently only support simple events - you cannot include arguments. Sorry!' );\n\t}\n\n\tchildInstance.on( eventName, function () {\n\t\tvar event, args;\n\n\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t}\n\n\t\targs = Array.prototype.slice.call( arguments );\n\n\t\tfireEvent( parentInstance, proxyEventName, { event: event, args: args } );\n\n\t\t// cancel bubbling\n\t\treturn false;\n\t});\n}\n","import { INTERPOLATOR, YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport parseJSON from 'utils/parseJSON';\nimport initialise from 'Ractive/initialise';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\nimport ReferenceExpressionResolver from 'virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ComplexParameter from './ComplexParameter';\n\nexport default function ( component, Component, attributes, yieldTemplate, partials ) {\n\tvar instance, parentFragment, ractive, fragment, container, inlinePartials = {}, data = {}, mappings = {}, ready, resolvers = [];\n\n\tparentFragment = component.parentFragment;\n\tractive = component.root;\n\n\tpartials = partials || {};\n\textend( inlinePartials, partials );\n\n\t// Make contents available as a {{>content}} partial\n\tpartials.content = yieldTemplate || [];\n\n\t// set a default partial for yields with no name\n\tinlinePartials[''] = partials.content;\n\n\tif ( Component.defaults.el ) {\n\t\twarnIfDebug( 'The <%s/> component has a default `el` property; it has been disregarded', component.name );\n\t}\n\n\t// find container\n\tfragment = parentFragment;\n\twhile ( fragment ) {\n\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\tcontainer = fragment.owner.container;\n\t\t\tbreak;\n\t\t}\n\n\t\tfragment = fragment.parent;\n\t}\n\n\t// each attribute represents either a) data or b) a mapping\n\tif ( attributes ) {\n\t\tObject.keys( attributes ).forEach( key => {\n\t\t\tvar attribute = attributes[ key ], parsed, resolver;\n\n\t\t\tif ( typeof attribute === 'string' ) {\n\t\t\t\t// it's static data\n\t\t\t\tparsed = parseJSON( attribute );\n\t\t\t\tdata[ key ] = parsed ? parsed.value : attribute;\n\t\t\t}\n\n\t\t\telse if ( attribute === 0 ) {\n\t\t\t\t// it had no '=', so we'll call it true\n\t\t\t\tdata[ key ] = true;\n\t\t\t}\n\n\t\t\telse if ( isArray( attribute ) ) {\n\t\t\t\t// this represents dynamic data\n\t\t\t\tif ( isSingleInterpolator( attribute ) ) {\n\t\t\t\t\tmappings[ key ] = {\n\t\t\t\t\t\torigin: component.root.viewmodel,\n\t\t\t\t\t\tkeypath: undefined\n\t\t\t\t\t};\n\n\t\t\t\t\tresolver = createResolver( component, attribute[0], function ( keypath ) {\n\t\t\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.set( key, keypath.value ); // TODO use viewmodel?\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[ key ] = keypath.value;\n\n\t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n\t\t\t\t\t\t\t\tdelete mappings[ key ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.viewmodel.mappings[ key ].resolve( keypath );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// resolved immediately\n\t\t\t\t\t\t\t\tmappings[ key ].keypath = keypath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresolver = new ComplexParameter( component, attribute, function ( value ) {\n\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\tinstance.set( key, value ); // TODO use viewmodel?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tresolvers.push( resolver );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow new Error( 'erm wut' );\n\t\t\t}\n\t\t});\n\t}\n\n\tinstance = create( Component.prototype );\n\n\tinitialise( instance, {\n\t\tel: null,\n\t\tappend: true,\n\t\tdata,\n\t\tpartials,\n\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\tmodifyArrays: ractive.modifyArrays,\n\t\t// need to inherit runtime parent adaptors\n\t\tadapt: ractive.adapt\n\t}, {\n\t\tparent: ractive,\n\t\tcomponent,\n\t\tcontainer,\n\t\tmappings,\n\t\tinlinePartials,\n\t\tcssIds: parentFragment.cssIds\n\t});\n\n\tready = true;\n\tcomponent.resolvers = resolvers;\n\n\treturn instance;\n}\n\nfunction createResolver ( component, template, callback ) {\n\tvar resolver;\n\n\tif ( template.r ) {\n\t\tresolver = createReferenceResolver( component, template.r, callback );\n\t}\n\n\telse if ( template.x ) {\n\t\tresolver = new ExpressionResolver( component, component.parentFragment, template.x, callback );\n\t}\n\n\telse if ( template.rx ) {\n\t\tresolver = new ReferenceExpressionResolver( component, template.rx, callback );\n\t}\n\n\treturn resolver;\n}\n\nfunction isSingleInterpolator( template ){\n\treturn template.length === 1 && template[0].t === INTERPOLATOR;\n}\n","import runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nfunction ComplexParameter ( component, template, callback ) {\n\tthis.parentFragment = component.parentFragment;\n\tthis.callback = callback;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: template,\n\t\troot:     component.root,\n\t\towner:    this\n\t});\n\n\tthis.update();\n}\n\nexport default ComplexParameter;\n\nComplexParameter.prototype = {\n\tbubble: function () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\tthis.callback( this.fragment.getValue() );\n\t\tthis.dirty = false;\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t}\n};\n\n","import { fatal, logIfDebug, warnIfDebug, warnOnceIfDebug, welcome } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport { magic as magicSupported } from 'config/environment';\nimport { ensureArray } from 'utils/array';\nimport { findInViewHierarchy } from 'shared/registry';\nimport arrayAdaptor from 'Ractive/static/adaptors/array/index';\nimport magicAdaptor from 'Ractive/static/adaptors/magic';\nimport magicArrayAdaptor from 'Ractive/static/adaptors/magicArray';\nimport { getElement } from 'utils/dom';\nimport { create, defineProperty, extend } from 'utils/object';\nimport runloop from 'global/runloop';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport Fragment from 'virtualdom/Fragment';\nimport Viewmodel from 'viewmodel/Viewmodel';\nimport Hook from './prototype/shared/hooks/Hook';\nimport HookQueue from './prototype/shared/hooks/HookQueue';\nimport getComputationSignatures from './helpers/getComputationSignatures';\nimport Ractive from '../Ractive';\n\nlet constructHook = new Hook( 'construct' );\nlet configHook = new Hook( 'config' );\nlet initHook = new HookQueue( 'init' );\nlet uid = 0;\n\nlet registryNames = [\n\t'adaptors',\n\t'components',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nexport default initialiseRactiveInstance;\n\nfunction initialiseRactiveInstance ( ractive, userOptions = {}, options = {} ) {\n\tvar el, viewmodel;\n\n\tif ( Ractive.DEBUG ) {\n\t\twelcome();\n\t}\n\n\tinitialiseProperties( ractive, options );\n\n\t// TODO remove this, eventually\n\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\tconstructHook.fire( ractive, userOptions );\n\n\t// Add registries\n\tregistryNames.forEach( name => {\n\t\tractive[ name ] = extend( create( ractive.constructor[ name ] || null ), userOptions[ name ] );\n\t});\n\n\t// Create a viewmodel\n\tviewmodel = new Viewmodel({\n\t\tadapt: getAdaptors( ractive, ractive.adapt, userOptions ),\n\t\tdata: dataConfigurator.init( ractive.constructor, ractive, userOptions ),\n\t\tcomputed: getComputationSignatures( ractive, extend( create( ractive.constructor.prototype.computed ), userOptions.computed ) ),\n\t\tmappings: options.mappings,\n\t\tractive: ractive,\n\t\tonchange: () => runloop.addRactive( ractive )\n\t});\n\n\tractive.viewmodel = viewmodel;\n\n\t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n\tviewmodel.init();\n\n\t// init config from Parent and options\n\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\tconfigHook.fire( ractive );\n\tinitHook.begin( ractive );\n\n\t// // If this is a component with a function `data` property, call the function\n\t// // with `ractive` as context (unless the child was also a function)\n\t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n\t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n\t// }\n\n\n\t// Render virtual DOM\n\tif ( ractive.template ) {\n\t\tlet cssIds;\n\n\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n\t\t\tif ( ractive.cssId ) {\n\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t}\n\t\t}\n\n\t\tractive.fragment = new Fragment({\n\t\t\ttemplate: ractive.template,\n\t\t\troot: ractive,\n\t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n\t\t\tcssIds\n\t\t});\n\t}\n\n\tinitHook.end( ractive );\n\n\t// render automatically ( if `el` is specified )\n\tif ( el = getElement( ractive.el ) ) {\n\t\tlet promise = ractive.render( el, ractive.append );\n\n\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\tpromise.catch( err => {\n\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive });\n\t\t\t\terr.stack && logIfDebug( err.stack );\n\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction getAdaptors ( ractive, protoAdapt, userOptions ) {\n\tvar adapt, magic, modifyArrays;\n\n\tprotoAdapt = protoAdapt.map( lookup );\n\tadapt = ensureArray( userOptions.adapt ).map( lookup );\n\n\tadapt = combine( protoAdapt, adapt );\n\n\tmagic = 'magic' in userOptions ? userOptions.magic : ractive.magic;\n\tmodifyArrays = 'modifyArrays' in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n\tif ( magic ) {\n\t\tif ( !magicSupported ) {\n\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t}\n\n\t\tif ( modifyArrays ) {\n\t\t\tadapt.push( magicArrayAdaptor );\n\t\t}\n\n\t\tadapt.push( magicAdaptor );\n\t}\n\n\tif ( modifyArrays ) {\n\t\tadapt.push( arrayAdaptor );\n\t}\n\n\treturn adapt;\n\n\n\tfunction lookup ( adaptor ) {\n\t\tif ( typeof adaptor === 'string' ) {\n\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\tif ( !adaptor ) {\n\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t}\n\t\t}\n\n\t\treturn adaptor;\n\t}\n}\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}\n\nfunction initialiseProperties ( ractive, options ) {\n\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t// existed\n\tractive._guid = 'r-' + uid++;\n\n\t// events\n\tractive._subs = create( null );\n\n\t// storage for item configuration from instantiation to reset,\n\t// like dynamic functions or original values\n\tractive._config = {};\n\n\t// two-way bindings\n\tractive._twowayBindings = create( null );\n\n\t// animations (so we can stop any in progress at teardown)\n\tractive._animations = [];\n\n\t// nodes registry\n\tractive.nodes = {};\n\n\t// live queries\n\tractive._liveQueries = [];\n\tractive._liveComponentQueries = [];\n\n\t// bound data functions\n\tractive._boundFunctions = [];\n\n\t// observers\n\tractive._observers = [];\n\n\n\t// properties specific to inline components\n\tif ( options.component ) {\n\t\tractive.parent = options.parent;\n\t\tractive.container = options.container || null;\n\t\tractive.root = ractive.parent.root;\n\n\t\tractive.component = options.component;\n\t\toptions.component.instance = ractive;\n\n\t\t// for hackability, this could be an open option\n\t\t// for any ractive instance, but for now, just\n\t\t// for components and just for ractive...\n\t\tractive._inlinePartials = options.inlinePartials;\n\t} else {\n\t\tractive.root = ractive;\n\t\tractive.parent = ractive.container = null;\n\t}\n}\n\nfunction deprecateRactiveData () {\n\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n}\n","import { fatal } from 'utils/log';\n\nvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\nexport default function getComputationSignatures ( ractive, computed ) {\n\tvar signatures = {}, key;\n\n\tfor ( key in computed ) {\n\t\tsignatures[ key ] = getComputationSignature( ractive, key, computed[ key ] );\n\t}\n\n\treturn signatures;\n}\n\nfunction getComputationSignature ( ractive, key, signature ) {\n\tvar getter, setter;\n\n\tif ( typeof signature === 'function' ) {\n\t\tgetter = bind( signature, ractive );\n\t}\n\n\tif ( typeof signature === 'string' ) {\n\t\tgetter = createFunctionFromString( ractive, signature );\n\t}\n\n\tif ( typeof signature === 'object' ) {\n\t\tif ( typeof signature.get === 'string' ) {\n\t\t\tgetter = createFunctionFromString( ractive, signature.get );\n\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\tgetter = bind( signature.get, ractive );\n\t\t} else {\n\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t}\n\n\t\tif ( typeof signature.set === 'function' ) {\n\t\t\tsetter = bind( signature.set, ractive );\n\t\t}\n\t}\n\n\treturn { getter: getter, setter: setter };\n}\n\nfunction createFunctionFromString ( ractive, str ) {\n\tvar functionBody, hasThis, fn;\n\n\tfunctionBody = 'return (' + str.replace( pattern, ( match, keypath ) => {\n\t\thasThis = true;\n\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t}) + ');';\n\n\tif ( hasThis ) {\n\t\tfunctionBody = 'var __ractive = this; ' + functionBody;\n\t}\n\n\tfn = new Function( functionBody );\n\treturn hasThis ? fn.bind( ractive ) : fn;\n}\n\nfunction bind ( fn, context ) {\n\treturn /this/.test( fn.toString() ) ? fn.bind( context ) : fn;\n}","import Hook from './Hook';\n\nfunction HookQueue ( event ) {\n\tthis.hook = new Hook( event );\n\tthis.inProcess = {};\n\tthis.queue = {};\n}\n\nHookQueue.prototype = {\n\n\tconstructor: HookQueue,\n\n\tbegin: function ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t},\n\n\tend: function ( ractive ) {\n\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t}\n};\n\nfunction getChildQueue ( queue, ractive ) {\n\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n}\n\nfunction fire ( hookQueue, ractive ) {\n\n\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\thookQueue.hook.fire( ractive );\n\n\t// queue is \"live\" because components can end up being\n\t// added while hooks fire on parents that modify data values.\n\twhile ( childQueue.length ) {\n\t\tfire( hookQueue, childQueue.shift() );\n\t}\n\n\tdelete hookQueue.queue[ ractive._guid ];\n}\n\n\nexport default HookQueue;\n","import { fatal } from 'utils/log';\nimport { getKeypath } from 'shared/keypaths';\nimport { create } from 'utils/object';\nimport adapt from './prototype/adapt';\nimport applyChanges from './prototype/applyChanges';\nimport capture from './prototype/capture';\nimport clearCache from './prototype/clearCache';\nimport compute from './prototype/compute';\nimport get from './prototype/get';\nimport init from './prototype/init';\nimport map from './prototype/map';\nimport mark from './prototype/mark';\nimport merge from './prototype/merge';\nimport register from './prototype/register';\nimport release from './prototype/release';\nimport reset from './prototype/reset';\nimport set from './prototype/set';\nimport smartUpdate from './prototype/smartUpdate';\nimport teardown from './prototype/teardown';\nimport unregister from './prototype/unregister';\n\nvar Viewmodel = function ( options ) {\n\tvar { adapt, data, ractive, computed, mappings } = options,\n\t\tkey,\n\t\tmapping;\n\n\t// TODO is it possible to remove this reference?\n\tthis.ractive = ractive;\n\n\tthis.adaptors = adapt;\n\tthis.onchange = options.onchange;\n\n\tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n\tthis.cacheMap = create( null );\n\n\tthis.deps = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\tthis.depsMap = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\n\tthis.patternObservers = [];\n\n\tthis.specials = create( null );\n\n\tthis.wrapped = create( null );\n\tthis.computations = create( null );\n\n\tthis.captureGroups = [];\n\tthis.unresolvedImplicitDependencies = [];\n\n\tthis.changes = [];\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\tthis.data = data;\n\n\t// set up explicit mappings\n\tthis.mappings = create( null );\n\tfor ( key in mappings ) {\n\t\tthis.map( getKeypath( key ), mappings[ key ] );\n\t}\n\n\tif ( data ) {\n\t\t// if data exists locally, but is missing on the parent,\n\t\t// we transfer ownership to the parent\n\t\tfor ( key in data ) {\n\t\t\tif ( ( mapping = this.mappings[ key ] ) && mapping.getValue() === undefined ) {\n\t\t\t\tmapping.setValue( data[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( key in computed ) {\n\t\tif ( mappings && key in mappings ) {\n\t\t\tfatal( 'Cannot map to a computed property (\\'%s\\')', key );\n\t\t}\n\n\t\tthis.compute( getKeypath( key ), computed[ key ] );\n\t}\n\n\tthis.ready = true;\n};\n\nViewmodel.prototype = {\n\tadapt: adapt,\n\tapplyChanges: applyChanges,\n\tcapture: capture,\n\tclearCache: clearCache,\n\tcompute: compute,\n\tget: get,\n\tinit: init,\n\tmap: map,\n\tmark: mark,\n\tmerge: merge,\n\tregister: register,\n\trelease: release,\n\treset: reset,\n\tset: set,\n\tsmartUpdate: smartUpdate,\n\tteardown: teardown,\n\tunregister: unregister\n};\n\nexport default Viewmodel;\n","import { removeFromArray } from 'utils/array';\n\nexport default function Viewmodel$unregister ( keypath, dependant, group = 'default' ) {\n\tvar mapping, deps, index;\n\n\tif ( dependant.isStatic ) {\n\t\treturn;\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\treturn mapping.unregister( keypath, dependant, group );\n\t}\n\n\tdeps = this.deps[ group ][ keypath.str ];\n\tindex = deps.indexOf( dependant );\n\n\tif ( index === -1 ) {\n\t\tthrow new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );\n\t}\n\n\tdeps.splice( index, 1 );\n\n\tif ( keypath.isRoot ) {\n\t\treturn;\n\t}\n\n\tupdateDependantsMap( this, keypath, group );\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ];\n\n\t\tparent[ '_' + keypath.str ] -= 1;\n\n\t\tif ( !parent[ '_' + keypath.str ] ) {\n\t\t\t// remove from parent deps map\n\t\t\tremoveFromArray( parent, keypath );\n\t\t\tparent[ '_' + keypath.str ] = undefined;\n\t\t}\n\n\t\tkeypath = keypath.parent;\n\t}\n}\n","export default function Viewmodel$teardown () {\n\tvar unresolvedImplicitDependency;\n\n\t// Clear entire cache - this has the desired side-effect\n\t// of unwrapping adapted values (e.g. arrays)\n\tObject.keys( this.cache ).forEach( keypath => this.clearCache( keypath ) );\n\n\t// Teardown any failed lookups - we don't need them to resolve any more\n\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\tunresolvedImplicitDependency.teardown();\n\t}\n}\n","var implicitOption = { implicit: true }, noCascadeOption = { noCascade: true };\n\nexport default function Viewmodel$smartUpdate ( keypath, array, newIndices ) {\n\tvar dependants, oldLength, i;\n\n\toldLength = newIndices.length;\n\n\t// Indices that are being removed should be marked as dirty\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.mark( keypath.join( oldIndex ), noCascadeOption );\n\t\t}\n\t});\n\n\t// Update the model\n\t// TODO allow existing array to be updated in place, rather than replaced?\n\tthis.set( keypath, array, { silent: true } );\n\n\tif ( dependants = this.deps[ 'default' ][ keypath.str ] ) {\n\t\tdependants.filter( canShuffle ).forEach( d => d.shuffle( newIndices, array ) );\n\t}\n\n\tif ( oldLength !== array.length ) {\n\t\tthis.mark( keypath.join( 'length' ), implicitOption );\n\n\t\tfor ( i = newIndices.touchedFrom; i < array.length; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ) );\n\t\t}\n\n\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t// TODO is this still necessary, now that computations are lazy?\n\t\tfor ( i = array.length; i < oldLength; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ), noCascadeOption );\n\t\t}\n\t}\n}\n\nfunction canShuffle ( dependant ) {\n\treturn typeof dependant.shuffle === 'function';\n}\n","import { isEqual } from 'utils/is';\nimport createBranch from 'utils/createBranch';\n\nexport default function Viewmodel$set ( keypath, value, options = {} ) {\n\tvar mapping, computation, wrapper, keepExistingWrapper;\n\n\t// unless data is being set for data tracking purposes\n\tif ( !options.noMapping ) {\n\t\t// If this data belongs to a different viewmodel,\n\t\t// pass the change along\n\t\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\t\treturn mapping.set( keypath, value );\n\t\t}\n\t}\n\n\tcomputation = this.computations[ keypath.str ];\n\tif ( computation ) {\n\t\tif ( computation.setting ) {\n\t\t\t// let the other computation set() handle things...\n\t\t\treturn;\n\t\t}\n\t\tcomputation.set( value );\n\t\tvalue = computation.get();\n\t}\n\n\tif ( isEqual( this.cache[ keypath.str ], value ) ) {\n\t\treturn;\n\t}\n\n\twrapper = this.wrapped[ keypath.str ];\n\n\t// If we have a wrapper with a `reset()` method, we try and use it. If the\n\t// `reset()` method returns false, the wrapper should be torn down, and\n\t// (most likely) a new one should be created later\n\tif ( wrapper && wrapper.reset ) {\n\t\tkeepExistingWrapper = ( wrapper.reset( value ) !== false );\n\n\t\tif ( keepExistingWrapper ) {\n\t\t\tvalue = wrapper.get();\n\t\t}\n\t}\n\n\tif ( !computation && !keepExistingWrapper ) {\n\t\tresolveSet( this, keypath, value );\n\t}\n\n\tif ( !options.silent ) {\n\t\tthis.mark( keypath );\n\t} else {\n\t\t// We're setting a parent of the original target keypath (i.e.\n\t\t// creating a fresh branch) - we need to clear the cache, but\n\t\t// not mark it as a change\n\t\tthis.clearCache( keypath.str );\n\t}\n}\n\nfunction resolveSet ( viewmodel, keypath, value ) {\n\tvar wrapper, parentValue, wrapperSet, valueSet;\n\n\twrapperSet = function() {\n\t\tif ( wrapper.set ) {\n\t\t\twrapper.set( keypath.lastKey, value );\n\t\t} else {\n\t\t\tparentValue = wrapper.get();\n\t\t\tvalueSet();\n\t\t}\n\t};\n\n\tvalueSet = function(){\n\t\tif ( !parentValue ) {\n\t\t\tparentValue = createBranch( keypath.lastKey );\n\t\t\tviewmodel.set( keypath.parent, parentValue, { silent: true } );\n\t\t}\n\t\tparentValue[ keypath.lastKey ] = value;\n\t};\n\n\twrapper = viewmodel.wrapped[ keypath.parent.str ];\n\n\tif ( wrapper ) {\n\t\twrapperSet();\n\t} else {\n\t\tparentValue = viewmodel.get( keypath.parent );\n\n\t\t// may have been wrapped via the above .get()\n\t\t// call on viewmodel if this is first access via .set()!\n\t\tif( wrapper = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\t\twrapperSet();\n\t\t} else {\n\t\t\tvalueSet();\n\t\t}\n\t}\n}\n","export default function Viewmodel$reset ( data ) {\n\tthis.data = data;\n\tthis.clearCache( '' );\n}","export default function Viewmodel$release () {\n\treturn this.captureGroups.pop();\n}\n","export default function Viewmodel$register ( keypath, dependant, group = 'default' ) {\n\tvar mapping, depsByKeypath, deps;\n\n\tif ( dependant.isStatic ) {\n\t\treturn; // TODO we should never get here if a dependant is static...\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\tmapping.register( keypath, dependant, group );\n\t}\n\n\telse {\n\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\tdeps = depsByKeypath[ keypath.str ] || ( depsByKeypath[ keypath.str ] = [] );\n\n\t\tdeps.push( dependant );\n\n\t\tif ( !this.depsMap[ group ] ) {\n\t\t\tthis.depsMap[ group ] = {};\n\t\t}\n\n\t\tif ( !keypath.isRoot ) {\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t}\n\t}\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent, keypathStr;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ] || ( map[ keypath.parent.str ] = [] );\n\n\t\tkeypathStr = keypath.str;\n\n\t\t// TODO find an alternative to this nasty approach\n\t\tif ( parent[ '_' + keypathStr ] === undefined ) {\n\t\t\tparent[ '_' + keypathStr ] = 0;\n\t\t\tparent.push( keypath );\n\t\t}\n\n\t\tparent[ '_' + keypathStr ] += 1;\n\t\tkeypath = keypath.parent;\n\t}\n}\n","import { warnIfDebug } from 'utils/log';\nimport mapOldToNewIndex from './merge/mapOldToNewIndex';\n\nvar comparators = {};\n\nexport default function Viewmodel$merge ( keypath, currentArray, array, options ) {\n\tvar oldArray,\n\t\tnewArray,\n\t\tcomparator,\n\t\tnewIndices;\n\n\tthis.mark( keypath );\n\n\tif ( options && options.compare ) {\n\n\t\tcomparator = getComparatorFunction( options.compare );\n\n\t\ttry {\n\t\t\toldArray = currentArray.map( comparator );\n\t\t\tnewArray = array.map( comparator );\n\t\t} catch ( err ) {\n\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t// to do more DOM manipulation than we thought...\n\t\t\twarnIfDebug( 'merge(): \"%s\" comparison failed. Falling back to identity checking', keypath );\n\n\t\t\toldArray = currentArray;\n\t\t\tnewArray = array;\n\t\t}\n\n\t} else {\n\t\toldArray = currentArray;\n\t\tnewArray = array;\n\t}\n\n\t// find new indices for members of oldArray\n\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\n\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n}\n\nfunction stringify ( item ) {\n\treturn JSON.stringify( item );\n}\n\nfunction getComparatorFunction ( comparator ) {\n\t// If `compare` is `true`, we use JSON.stringify to compare\n\t// objects that are the same shape, but non-identical - i.e.\n\t// { foo: 'bar' } !== { foo: 'bar' }\n\tif ( comparator === true ) {\n\t\treturn stringify;\n\t}\n\n\tif ( typeof comparator === 'string' ) {\n\t\tif ( !comparators[ comparator ] ) {\n\t\t\tcomparators[ comparator ] = function ( item ) {\n\t\t\t\treturn item[ comparator ];\n\t\t\t};\n\t\t}\n\n\t\treturn comparators[ comparator ];\n\t}\n\n\tif ( typeof comparator === 'function' ) {\n\t\treturn comparator;\n\t}\n\n\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n}\n","export default function ( oldArray, newArray ) {\n\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n\tusedIndices = {};\n\tfirstUnusedIndex = 0;\n\n\tnewIndices = oldArray.map( function ( item, i ) {\n\t\tvar index, start, len;\n\n\t\tstart = firstUnusedIndex;\n\t\tlen = newArray.length;\n\n\t\tdo {\n\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\tif ( index === -1 ) {\n\t\t\t\tchanged = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstart = index + 1;\n\t\t} while ( usedIndices[ index ] && start < len );\n\n\t\t// keep track of the first unused index, so we don't search\n\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\tif ( index === firstUnusedIndex ) {\n\t\t\tfirstUnusedIndex += 1;\n\t\t}\n\n\t\tif ( index !== i ) {\n\t\t\tchanged = true;\n\t\t}\n\n\t\tusedIndices[ index ] = true;\n\t\treturn index;\n\t});\n\n\treturn newIndices;\n}\n","export default function Viewmodel$mark ( keypath, options ) {\n\tvar computation, keypathStr = keypath.str;\n\n\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t// should not be picked up by pattern observers\n\tif ( options ) {\n\t\tif ( options.implicit ) {\n\t\t\tthis.implicitChanges[ keypathStr ] = true;\n\t\t}\n\t\tif ( options.noCascade ) {\n\t\t\tthis.noCascade[ keypathStr ] = true;\n\t\t}\n\t}\n\n\tif ( computation = this.computations[ keypathStr ] ) {\n\t\tcomputation.invalidate();\n\t}\n\n\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\tthis.changes.push( keypath );\n\t}\n\n\t// pass on keepExistingWrapper, if we can\n\tlet keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n\tthis.clearCache( keypathStr, keepExistingWrapper );\n\n\tif ( this.ready ) {\n\t\tthis.onchange();\n\t}\n}\n","export default function Viewmodel$map ( key, options ) {\n\tvar mapping = this.mappings[ key.str ] = new Mapping( key, options );\n\tmapping.initViewmodel( this );\n\treturn mapping;\n}\n\nvar Mapping = function ( localKey, options ) {\n\tthis.localKey = localKey;\n\tthis.keypath = options.keypath;\n\tthis.origin = options.origin;\n\n\tthis.deps = [];\n\tthis.unresolved = [];\n\n\tthis.resolved = false;\n};\n\nMapping.prototype = {\n\tforceResolution () {\n\t\t// TODO warn, as per #1692?\n\t\tthis.keypath = this.localKey;\n\t\tthis.setup();\n\t},\n\n\tget ( keypath, options ) {\n\t\tif ( !this.resolved ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.map( keypath ), options );\n\t},\n\n\tgetValue () {\n\t\tif ( !this.keypath ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.keypath );\n\t},\n\n\tinitViewmodel ( viewmodel ) {\n\t\tthis.local = viewmodel;\n\t\tthis.setup();\n\t},\n\n\tmap ( keypath ) {\n    \t\tif( typeof this.keypath === undefined ) {\n    \t\t\treturn this.localKey;\n    \t\t}\n    \t\treturn keypath.replace( this.localKey, this.keypath );\n\t},\n\n\tregister ( keypath, dependant, group ) {\n\t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n\t\tif ( this.resolved ) {\n\t\t\tthis.origin.register( this.map( keypath ), dependant, group );\n\t\t}\n\t},\n\n\tresolve ( keypath ) {\n\t\tif ( this.keypath !== undefined ) {\n\t\t\tthis.unbind( true );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.setup();\n\t},\n\n\tset ( keypath, value ) {\n\t\tif ( !this.resolved ) {\n\t\t\tthis.forceResolution();\n\t\t}\n\n\t\tthis.origin.set( this.map( keypath ), value );\n\t},\n\n\tsetup () {\n\t\tif ( this.keypath === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\t// accumulated dependants can now be registered\n\t\tif ( this.deps.length ) {\n\t\t\tthis.deps.forEach( d => {\n\t\t\t\tvar keypath = this.map( d.keypath );\n\t\t\t\tthis.origin.register( keypath, d.dep, d.group );\n\n\t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n\t\t\t\tif ( d.dep.setValue ) {\n\t\t\t\t\td.dep.setValue( this.origin.get( keypath ) );\n\t\t\t\t} else if ( d.dep.invalidate ) {\n\t\t\t\t\td.dep.invalidate();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.origin.mark( this.keypath );\n\t\t}\n\t},\n\n\tsetValue ( value ) {\n\t\tif ( !this.keypath ) {\n\t\t\tthrow new Error( 'Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t}\n\n\t\tthis.origin.set( this.keypath, value );\n\t},\n\n\tunbind ( keepLocal ) {\n\t\tif ( !keepLocal ) {\n\t\t\tdelete this.local.mappings[ this.localKey ];\n\t\t}\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deps.forEach( d => {\n\t\t\tthis.origin.unregister( this.map( d.keypath ), d.dep, d.group );\n\t\t});\n\n\t\tif ( this.tracker ) {\n\t\t\tthis.origin.unregister( this.keypath, this.tracker );\n\t\t}\n\t},\n\n\tunregister ( keypath, dependant, group ) {\n\t\tvar deps, i;\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeps = this.deps;\n\t\ti = deps.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( deps[i].dep === dependant ) {\n\t\t\t\tdeps.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.origin.unregister( this.map( keypath ), dependant, group );\n\t}\n};\n","export default function Viewmodel$init () {\n\tvar key;\n\n\tfor ( key in this.computations ) {\n\t\tthis.computations[ key ].init( this );\n\t}\n}","import { lastItem } from 'utils/array';\nimport { hasOwn } from 'utils/object';\nimport FAILED_LOOKUP from './get/FAILED_LOOKUP';\n\nvar empty = {};\n\nexport default function Viewmodel$get ( keypath, options ) {\n\tvar cache = this.cache,\n\t\tvalue,\n\t\tcomputation,\n\t\twrapped,\n\t\tcaptureGroup,\n\t\tkeypathStr = keypath.str,\n\t\tkey;\n\n\toptions = options || empty;\n\n\t// capture the keypath, if we're inside a computation\n\tif ( options.capture && ( captureGroup = lastItem( this.captureGroups ) ) ) {\n\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\tcaptureGroup.push( keypath );\n\t\t}\n\t}\n\n\tif ( hasOwn.call( this.mappings, keypath.firstKey ) ) {\n\t\treturn this.mappings[ keypath.firstKey ].get( keypath, options );\n\t}\n\n\tif ( keypath.isSpecial ) {\n\t\treturn keypath.value;\n\t}\n\n\tif ( cache[ keypathStr ] === undefined ) {\n\n\t\t// Is this a computed property?\n\t\tif ( ( computation = this.computations[ keypathStr ] ) && !computation.bypass ) {\n\t\t\tvalue = computation.get();\n\t\t\tthis.adapt( keypathStr, value );\n\t\t}\n\n\t\t// Is this a wrapped property?\n\t\telse if ( wrapped = this.wrapped[ keypathStr ] ) {\n\t\t\tvalue = wrapped.value;\n\t\t}\n\n\t\t// Is it the root?\n\t\telse if ( keypath.isRoot ) {\n\t\t\tthis.adapt( '', this.data );\n\t\t\tvalue = this.data;\n\t\t}\n\n\t\t// No? Then we need to retrieve the value one key at a time\n\t\telse {\n\t\t\tvalue = retrieve( this, keypath );\n\t\t}\n\n\t\tcache[ keypathStr ] = value;\n\t} else {\n\t\tvalue = cache[ keypathStr ];\n\t}\n\n\tif ( !options.noUnwrap && ( wrapped = this.wrapped[ keypathStr ] ) ) {\n\t\tvalue = wrapped.get();\n\t}\n\n\tif ( keypath.isRoot && options.fullRootGet ) {\n\t\tfor ( key in this.mappings ) {\n\t\t\tvalue[ key ] = this.mappings[ key ].getValue();\n\t\t}\n\t}\n\n\treturn value === FAILED_LOOKUP ? void 0 : value;\n}\n\nfunction retrieve ( viewmodel, keypath ) {\n\n\tvar parentValue, cacheMap, value, wrapped;\n\n\tparentValue = viewmodel.get( keypath.parent );\n\n\tif ( wrapped = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\tparentValue = wrapped.get();\n\t}\n\n\tif ( parentValue === null || parentValue === undefined ) {\n\t\treturn;\n\t}\n\n\t// update cache map\n\tif ( !( cacheMap = viewmodel.cacheMap[ keypath.parent.str ] ) ) {\n\t\tviewmodel.cacheMap[ keypath.parent.str ] = [ keypath.str ];\n\t} else {\n\t\tif ( cacheMap.indexOf( keypath.str ) === -1 ) {\n\t\t\tcacheMap.push( keypath.str );\n\t\t}\n\t}\n\n\t// If this property doesn't exist, we return a sentinel value\n\t// so that we know to query parent scope (if such there be)\n\tif ( typeof parentValue === 'object' && !( keypath.lastKey in parentValue ) ) {\n\t\treturn viewmodel.cache[ keypath.str ] = FAILED_LOOKUP;\n\t}\n\n\tvalue = parentValue[ keypath.lastKey ];\n\n\t// Do we have an adaptor for this value?\n\tviewmodel.adapt( keypath.str, value, false );\n\n\t// Update cache\n\tviewmodel.cache[ keypath.str ] = value;\n\treturn value;\n}\n","import Computation from '../Computation/Computation';\n\nexport default function Viewmodel$compute ( key, signature ) {\n\tvar computation = new Computation( key, signature );\n\n\tif ( this.ready ) {\n\t\tcomputation.init( this );\n\t}\n\n\treturn ( this.computations[ key.str ] = computation );\n}\n","import runloop from 'global/runloop';\nimport { logIfDebug, warnIfDebug, warnOnce } from 'utils/log';\nimport { isEqual } from 'utils/is';\nimport UnresolvedDependency from './UnresolvedDependency';\n\nvar Computation = function ( key, signature ) {\n\tthis.key = key;\n\n\tthis.getter = signature.getter;\n\tthis.setter = signature.setter;\n\n\tthis.hardDeps = signature.deps || [];\n\tthis.softDeps = [];\n\tthis.unresolvedDeps = {};\n\n\tthis.depValues = {};\n\n\tthis._dirty = this._firstRun = true;\n};\n\nComputation.prototype = {\n\tconstructor: Computation,\n\n\tinit ( viewmodel ) {\n\t\tvar initial;\n\n\t\tthis.viewmodel = viewmodel;\n\t\tthis.bypass = true;\n\n\t\tinitial = viewmodel.get( this.key );\n\t\tviewmodel.clearCache( this.key.str );\n\n\t\tthis.bypass = false;\n\n\t\tif ( this.setter && initial !== undefined ) {\n\t\t\tthis.set( initial );\n\t\t}\n\n\t\tif ( this.hardDeps ) {\n\t\t\tthis.hardDeps.forEach( d => viewmodel.register( d, this, 'computed' ) );\n\t\t}\n\t},\n\n\tinvalidate () {\n\t\tthis._dirty = true;\n\t},\n\n\tget () {\n\t\tvar newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\n\t\tif ( this.getting ) {\n\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\tlet msg = `The ${this.key.str} computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by \\`array.sort(...)\\` - if that\\'s the case, clone the array first with \\`array.slice().sort(...)\\``;\n\t\t\twarnOnce( msg );\n\t\t\treturn this.value;\n\t\t}\n\n\t\tthis.getting = true;\n\n\t\tif ( this._dirty ) {\n\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t// other computed values\n\t\t\tif ( this._firstRun || ( !this.hardDeps.length && !this.softDeps.length ) ) {\n\t\t\t\tdependencyValuesChanged = true;\n\t\t\t} else {\n\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\tvar keypath, value, i;\n\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ti = deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = deps[i];\n\t\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\n\t\t\t\t\t\tif ( !isEqual( value, this.depValues[ keypath.str ] ) ) {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = value;\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\tthis.viewmodel.capture();\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.value = this.getter();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( 'Failed to compute \"%s\"', this.key.str );\n\t\t\t\t\tlogIfDebug( err.stack || err );\n\n\t\t\t\t\tthis.value = void 0;\n\t\t\t\t}\n\n\t\t\t\tnewDeps = this.viewmodel.release();\n\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\t\tdeps.forEach( keypath => {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = this.viewmodel.get( keypath );\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tthis.getting = this._firstRun = false;\n\t\treturn this.value;\n\t},\n\n\tset ( value ) {\n\t\tif ( this.setting ) {\n\t\t\tthis.value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.setter ) {\n\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t}\n\n\t\tthis.setter( value );\n\t},\n\n\tupdateDependencies ( newDeps ) {\n\t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n\t\toldDeps = this.softDeps;\n\n\t\t// remove dependencies that are no longer used\n\t\ti = oldDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = oldDeps[i];\n\n\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\tdependenciesChanged = true;\n\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t}\n\t\t}\n\n\t\t// create references for any new dependencies\n\t\ti = newDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = newDeps[i];\n\n\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\tdependenciesChanged = true;\n\n\t\t\t\t// if this keypath is currently unresolved, we need to mark\n\t\t\t\t// it as such. TODO this is a bit muddy...\n\t\t\t\tif ( isUnresolved( this.viewmodel, keypath ) && ( !this.unresolvedDeps[ keypath.str ] ) ) {\n\t\t\t\t\tunresolved = new UnresolvedDependency( this, keypath.str );\n\t\t\t\t\tnewDeps.splice( i, 1 );\n\n\t\t\t\t\tthis.unresolvedDeps[ keypath.str ] = unresolved;\n\t\t\t\t\trunloop.addUnresolved( unresolved );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dependenciesChanged ) {\n\t\t\tthis.softDeps = newDeps.slice();\n\t\t}\n\n\t\treturn dependenciesChanged;\n\t}\n};\n\nfunction isUnresolved( viewmodel, keypath ) {\n\tvar key = keypath.firstKey;\n\n\treturn !( key in viewmodel.data ) &&\n\t       !( key in viewmodel.computations ) &&\n\t       !( key in viewmodel.mappings );\n}\n\nexport default Computation;\n","var UnresolvedDependency = function ( computation, ref ) {\n\tthis.computation = computation;\n\tthis.viewmodel = computation.viewmodel;\n\tthis.ref = ref;\n\n\t// TODO this seems like a red flag!\n\tthis.root = this.viewmodel.ractive;\n\tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n};\n\nUnresolvedDependency.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.computation.softDeps.push( keypath );\n\t\tthis.computation.unresolvedDeps[ keypath.str ] = null;\n\t\tthis.viewmodel.register( keypath, this.computation, 'computed' );\n\t}\n};\n\nexport default UnresolvedDependency;","export default function Viewmodel$clearCache ( keypath, keepExistingWrapper ) {\n\tvar cacheMap, wrapper;\n\n\tif ( !keepExistingWrapper ) {\n\t\t// Is there a wrapped property at this keypath?\n\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t// Did we unwrap it?\n\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t// Is this right?\n\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache[ keypath ] = undefined;\n\n\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\twhile ( cacheMap.length ) {\n\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t}\n\t}\n}\n","export default function Viewmodel$capture () {\n\tthis.captureGroups.push([]);\n}\n","import getUpstreamChanges from '../helpers/getUpstreamChanges';\nimport notifyPatternObservers from './applyChanges/notifyPatternObservers';\n\nexport default function Viewmodel$applyChanges () {\n\tvar self = this,\n\t\tchanges,\n\t\tupstreamChanges,\n\t\thash = {},\n\t\tbindings;\n\n\tchanges = this.changes;\n\n\tif ( !changes.length ) {\n\t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n\t\treturn;\n\t}\n\n\tfunction invalidateComputation ( computation ) {\n\t\tvar key = computation.key;\n\n\t\tif ( computation.viewmodel === self ) {\n\t\t\tself.clearCache( key.str );\n\t\t\tcomputation.invalidate();\n\n\t\t\tchanges.push( key );\n\t\t\tcascade( key );\n\t\t} else {\n\t\t\tcomputation.viewmodel.mark( key );\n\t\t}\n\t}\n\n\tfunction cascade ( keypath ) {\n\t\tvar map, computations;\n\n\t\tif ( self.noCascade.hasOwnProperty( keypath.str ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( computations = self.deps.computed[ keypath.str ] ) {\n\t\t\tcomputations.forEach( invalidateComputation );\n\t\t}\n\n\t\tif ( map = self.depsMap.computed[ keypath.str ] ) {\n\t\t\tmap.forEach( cascade );\n\t\t}\n\t}\n\n\tchanges.slice().forEach( cascade );\n\n\tupstreamChanges = getUpstreamChanges( changes );\n\tupstreamChanges.forEach( keypath => {\n\t\tvar computations;\n\n\t\t// make sure we haven't already been down this particular keypath in this turn\n\t\tif ( changes.indexOf( keypath ) === -1 && ( computations = self.deps.computed[ keypath.str ] ) ) {\n\t\t\tcomputations.forEach( invalidateComputation );\n\t\t}\n\t});\n\n\tthis.changes = [];\n\n\t// Pattern observers are a weird special case\n\tif ( this.patternObservers.length ) {\n\t\tupstreamChanges.forEach( keypath => notifyPatternObservers( this, keypath, true ) );\n\t\tchanges.forEach( keypath => notifyPatternObservers( this, keypath ) );\n\t}\n\n\tif ( this.deps.observers ) {\n\t\tupstreamChanges.forEach( keypath => notifyUpstreamDependants( this, null, keypath, 'observers' ) );\n\t\tnotifyAllDependants( this, changes, 'observers' );\n\t}\n\n\tif ( this.deps['default'] ) {\n\t\tbindings = [];\n\t\tupstreamChanges.forEach( keypath => notifyUpstreamDependants( this, bindings, keypath, 'default' ) );\n\n\t\tif( bindings.length ) {\n\t\t\tnotifyBindings( this, bindings, changes );\n\t\t}\n\n\t\tnotifyAllDependants( this, changes, 'default' );\n\t}\n\n\t// Return a hash of keypaths to updated values\n\tchanges.forEach( keypath => {\n\t\thash[ keypath.str ] = this.get( keypath );\n\t});\n\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\treturn hash;\n}\n\nfunction notifyUpstreamDependants ( viewmodel, bindings, keypath, groupName ) {\n\tvar dependants, value;\n\n\tif ( dependants = findDependants( viewmodel, keypath, groupName ) ) {\n\t\tvalue = viewmodel.get( keypath );\n\n\t\tdependants.forEach( d => {\n\t\t\t// don't \"set\" the parent value, refine it\n\t\t\t// i.e. not data = value, but data[foo] = fooValue\n\t\t\tif( bindings && d.refineValue ) {\n\t\t\t\tbindings.push( d );\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.setValue( value );\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction notifyBindings ( viewmodel, bindings, changes ) {\n\n\tbindings.forEach( binding => {\n\t\tlet useSet = false, i = 0, length = changes.length, refinements = [];\n\n\t\twhile( i < length ) {\n\t\t\tlet keypath = changes[i];\n\n\t\t\tif ( keypath === binding.keypath ) {\n\t\t\t\tuseSet = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( keypath.slice(0, binding.keypath.length) === binding.keypath ) {\n\t\t\t\trefinements.push( keypath );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif ( useSet ) {\n\t\t\tbinding.setValue( viewmodel.get( binding.keypath ) );\n\t\t}\n\n\t\tif( refinements.length ) {\n\t\t\tbinding.refineValue( refinements );\n\t\t}\n\t});\n}\n\n\nfunction notifyAllDependants ( viewmodel, keypaths, groupName ) {\n\tvar queue = [];\n\n\taddKeypaths( keypaths );\n\tqueue.forEach( dispatch );\n\n\tfunction addKeypaths ( keypaths ) {\n\t\tkeypaths.forEach( addKeypath );\n\t\tkeypaths.forEach( cascade );\n\t}\n\n\tfunction addKeypath ( keypath ) {\n\t\tvar deps = findDependants( viewmodel, keypath, groupName );\n\n\t\tif ( deps ) {\n\t\t\tqueue.push({\n\t\t\t\tkeypath: keypath,\n\t\t\t\tdeps: deps\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction cascade ( keypath ) {\n\t\tvar childDeps;\n\n\t\tif ( childDeps = viewmodel.depsMap[ groupName ][ keypath.str ] ) {\n\t\t\taddKeypaths( childDeps );\n\t\t}\n\t}\n\n\tfunction dispatch ( set ) {\n\t\tvar value = viewmodel.get( set.keypath );\n\t\tset.deps.forEach( d => d.setValue( value ) );\n\t}\n}\n\nfunction findDependants ( viewmodel, keypath, groupName ) {\n\tvar group = viewmodel.deps[ groupName ];\n\treturn group ? group[ keypath.str ] : null;\n}\n","export default notifyPatternObservers;\n\nfunction notifyPatternObservers ( viewmodel, keypath, onlyDirect ) {\n\tvar potentialWildcardMatches;\n\n\tupdateMatchingPatternObservers( viewmodel, keypath );\n\n\tif ( onlyDirect ) {\n\t\treturn;\n\t}\n\n\tpotentialWildcardMatches = keypath.wildcardMatches();\n\tpotentialWildcardMatches.forEach( upstreamPattern => {\n\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t});\n}\n\n\nfunction cascade ( viewmodel, upstreamPattern, keypath ) {\n\tvar group, map, actualChildKeypath;\n\n\t// TODO should be one or the other\n\tupstreamPattern = ( upstreamPattern.str || upstreamPattern );\n\n\tgroup = viewmodel.depsMap.patternObservers;\n\tmap = group && group[ upstreamPattern ];\n\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\tmap.forEach( childKeypath => {\n\t\tactualChildKeypath = keypath.join( childKeypath.lastKey ); // 'foo.bar.baz'\n\n\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t});\n}\n\nfunction updateMatchingPatternObservers ( viewmodel, keypath ) {\n\tviewmodel.patternObservers.forEach( observer => {\n\t\tif ( observer.regex.test( keypath.str ) ) {\n\t\t\tobserver.update( keypath );\n\t\t}\n\t});\n}\n","import { addToArray } from 'utils/array';\nimport { rootKeypath } from 'shared/keypaths'; // TEMP\n\nexport default function getUpstreamChanges ( changes ) {\n\tvar upstreamChanges = [ rootKeypath ], i, keypath;\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tkeypath = changes[i].parent;\n\n\t\twhile ( keypath && !keypath.isRoot ) {\n\t\t\tif( changes.indexOf(keypath) === -1 ) {\n\t\t\t\taddToArray( upstreamChanges, keypath );\n\t\t\t}\n\t\t\tkeypath = keypath.parent;\n\t\t}\n\t}\n\n\treturn upstreamChanges;\n}\n","var prefixers = {};\n\nexport default function Viewmodel$adapt ( keypath, value ) {\n\tvar len, i, adaptor, wrapped;\n\n\tif ( !this.adaptors ) return;\n\n\t// Do we have an adaptor for this value?\n\tlen = this.adaptors.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tadaptor = this.adaptors[i];\n\n\t\tif ( adaptor.filter( value, keypath, this.ractive ) ) {\n\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( this.ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\twrapped.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nfunction prefixKeypath ( obj, prefix ) {\n\tvar prefixed = {}, key;\n\n\tif ( !prefix ) {\n\t\treturn obj;\n\t}\n\n\tprefix += '.';\n\n\tfor ( key in obj ) {\n\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn prefixed;\n}\n\nfunction getPrefixer ( rootKeypath ) {\n\tvar rootDot;\n\n\tif ( !prefixers[ rootKeypath ] ) {\n\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\tvar obj;\n\n\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t}\n\t\t};\n\t}\n\n\treturn prefixers[ rootKeypath ];\n}\n","import magicAdaptor from './magic';\nimport arrayAdaptor from './array/index';\n\nvar magicArrayAdaptor, MagicArrayWrapper;\n\nif ( magicAdaptor ) {\n\tmagicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tMagicArrayWrapper = function ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t};\n\n\tMagicArrayWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t},\n\t\treset: function ( value ) {\n\t\t\treturn this.magicWrapper.reset( value );\n\t\t}\n\t};\n}\n\nexport default magicArrayAdaptor;\n","import runloop from 'global/runloop';\nimport createBranch from 'utils/createBranch';\nimport { getKeypath } from 'shared/keypaths';\nimport { isArray } from 'utils/is';\n\nvar magicAdaptor, MagicWrapper;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tmagicAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\tvar parentWrapper, parentValue;\n\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tkeypath = getKeypath( keypath );\n\n\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t// we shouldn't wrap this property\n\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ keypath.parent.str ] ) && !parentWrapper.magic ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparentValue = ractive.viewmodel.get( keypath.parent );\n\n\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( keypath.lastKey ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) );\n\t\t},\n\t\twrap: function ( ractive, property, keypath ) {\n\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t}\n\t};\n\n\tMagicWrapper = function ( ractive, value, keypath ) {\n\t\tvar objKeypath, template, siblings;\n\n\t\tkeypath = getKeypath( keypath );\n\n\t\tthis.magic = true;\n\n\t\tthis.ractive = ractive;\n\t\tthis.keypath = keypath;\n\t\tthis.value = value;\n\n\t\tthis.prop = keypath.lastKey;\n\n\t\tobjKeypath = keypath.parent;\n\t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get( objKeypath );\n\n\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\n\t\t// Has this property already been wrapped?\n\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\tsiblings.push( this );\n\t\t\t}\n\n\t\t\treturn; // already wrapped\n\t\t}\n\n\t\t// No, it hasn't been wrapped\n\t\tcreateAccessors( this, value, template );\n\t};\n\n\tMagicWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\treset: function ( value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updating = true;\n\t\t\tthis.obj[ this.prop ] = value; // trigger set() accessor\n\t\t\trunloop.addRactive( this.ractive );\n\t\t\tthis.ractive.viewmodel.mark( this.keypath, { keepExistingWrapper: true } );\n\t\t\tthis.updating = false;\n\t\t\treturn true;\n\t\t},\n\t\tset: function ( key, value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\n\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tvar template, set, value, wrappers, index;\n\n\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t// so that it doesn't get torn down\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\tset = template && template.set;\n\n\t\t\tif ( !set ) {\n\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twrappers = set._ractiveWrappers;\n\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t}\n\n\t\t\t// Last one out, turn off the lights\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tvalue = this.obj[ this.prop ];\n\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t}\n\t\t}\n\t};\n} catch ( err ) {\n\tmagicAdaptor = false; // no magic in this browser\n}\n\nexport default magicAdaptor;\n\nfunction createAccessors ( originalWrapper, value, template ) {\n\n\tvar object, property, oldGet, oldSet, get, set;\n\n\tobject = originalWrapper.obj;\n\tproperty = originalWrapper.prop;\n\n\t// Is this template configurable?\n\tif ( template && !template.configurable ) {\n\t\t// Special case - array length\n\t\tif ( property === 'length' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t}\n\n\n\t// Time to wrap this property\n\tif ( template ) {\n\t\toldGet = template.get;\n\t\toldSet = template.set;\n\t}\n\n\tget = oldGet || function () {\n\t\treturn value;\n\t};\n\n\tset = function ( v ) {\n\t\tif ( oldSet ) {\n\t\t\toldSet( v );\n\t\t}\n\n\t\tvalue = oldGet ? oldGet() : v;\n\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t};\n\n\tfunction updateWrapper ( wrapper ) {\n\t\tvar keypath, ractive;\n\n\t\twrapper.value = value;\n\n\t\tif ( wrapper.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tractive = wrapper.ractive;\n\t\tkeypath = wrapper.keypath;\n\n\t\twrapper.updating = true;\n\t\trunloop.start( ractive );\n\n\t\tractive.viewmodel.mark( keypath );\n\n\t\trunloop.end();\n\t\twrapper.updating = false;\n\t}\n\n\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\tset._ractiveWrappers = [ originalWrapper ];\n\tObject.defineProperty( object, property, { get: get, set: set, enumerable: true, configurable: true });\n}\n","var numeric = /^\\s*[0-9]+\\s*$/;\n\nexport default function ( key ) {\n\treturn numeric.test( key ) ? [] : {};\n}\n","import { defineProperty } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport { getKeypath } from 'shared/keypaths';\nimport patch from './patch';\n\nvar arrayAdaptor,\n\n\t// helpers\n\tArrayWrapper,\n\terrorMessage;\n\narrayAdaptor = {\n\tfilter: function ( object ) {\n\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t// or the array didn't trigger the get() itself\n\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t},\n\twrap: function ( ractive, array, keypath ) {\n\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t}\n};\n\nArrayWrapper = function ( ractive, array, keypath ) {\n\tthis.root = ractive;\n\tthis.value = array;\n\tthis.keypath = getKeypath( keypath );\n\n\t// if this array hasn't already been ractified, ractify it\n\tif ( !array._ractive ) {\n\n\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\tdefineProperty( array, '_ractive', {\n\t\t\tvalue: {\n\t\t\t\twrappers: [],\n\t\t\t\tinstances: [],\n\t\t\t\tsetting: false\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tpatch( array );\n\t}\n\n\t// store the ractive instance, so we can handle transitions later\n\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\tarray._ractive.instances.push( ractive );\n\t}\n\n\tarray._ractive.instances[ ractive._guid ] += 1;\n\tarray._ractive.wrappers.push( this );\n};\n\nArrayWrapper.prototype = {\n\tget: function () {\n\t\treturn this.value;\n\t},\n\tteardown: function () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n};\n\nerrorMessage = 'Something went wrong in a rather interesting way';\nexport default arrayAdaptor;\n","import runloop from 'global/runloop';\nimport { defineProperty } from 'utils/object';\nimport getNewIndices from 'shared/getNewIndices';\nimport processWrapper from './processWrapper';\n\nvar patchedArrayProto = [],\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ],\n\ttestObj,\n\tpatchArrayMethods,\n\tunpatchArrayMethods;\n\nmutatorMethods.forEach( function ( methodName ) {\n\tvar method = function ( ...args ) {\n\t\tvar newIndices,\n\t\t\tresult,\n\t\t\twrapper,\n\t\t\ti;\n\n\t\tnewIndices = getNewIndices( this, methodName, args );\n\n\t\t// apply the underlying method\n\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t// trigger changes\n\t\trunloop.start();\n\n\t\tthis._ractive.setting = true;\n\t\ti = this._ractive.wrappers.length;\n\t\twhile ( i-- ) {\n\t\t\twrapper = this._ractive.wrappers[i];\n\n\t\t\trunloop.addRactive( wrapper.root );\n\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tthis._ractive.setting = false;\n\t\treturn result;\n\t};\n\n\tdefineProperty( patchedArrayProto, methodName, {\n\t\tvalue: method\n\t});\n});\n\n// can we use prototype chain injection?\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\ntestObj = {};\n\nif ( testObj.__proto__ ) {\n\t// yes, we can\n\tpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = patchedArrayProto;\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = Array.prototype;\n\t};\n}\n\nelse {\n\t// no, we can't\n\tpatchArrayMethods = function ( array ) {\n\t\tvar i, methodName;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tmethodName = mutatorMethods[i];\n\t\t\tdefineProperty( array, methodName, {\n\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tvar i;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t}\n\t};\n}\n\npatchArrayMethods.unpatch = unpatchArrayMethods;\nexport default patchArrayMethods;\n","export default function ( wrapper, array, methodName, newIndices ) {\n\tvar { root, keypath } = wrapper;\n\n\tif ( !!newIndices ) {\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t} else {\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\troot.viewmodel.mark( keypath );\n\t}\n}\n","export default function Component$firstNode () {\n\tif ( this.rendered ) {\n\t\treturn this.instance.fragment.firstNode();\n\t}\n\n\treturn null;\n}\n","export default function Component$findNextNode () {\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Component$findComponent ( selector ) {\n\tif ( !selector || ( selector === this.name ) ) {\n\t\treturn this.instance;\n\t}\n\n\tif ( this.instance.fragment ) {\n\t\treturn this.instance.fragment.findComponent( selector );\n\t}\n\n\treturn null;\n}\n","export default function Component$findAllComponents ( selector, query ) {\n\tquery._test( this, true );\n\n\tif ( this.instance.fragment ) {\n\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function Component$findAll ( selector, query ) {\n\treturn this.instance.fragment.findAll( selector, query );\n}\n","export default function Component$find ( selector ) {\n\treturn this.instance.fragment.find( selector );\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Component$detach () {\n\tvar detached = this.instance.fragment.detach();\n\tdetachHook.fire( this.instance );\n\treturn detached;\n}\n","import { noRegistryFunctionReturn } from 'config/errors';\nimport { warnIfDebug } from 'utils/log';\nimport { findInstance } from 'shared/registry';\n\n// finds the component constructor in the registry or view hierarchy registries\n\nexport default function getComponent ( ractive, name ) {\n\n\tvar Component, instance = findInstance( 'components', ractive, name );\n\n\tif ( instance ) {\n\t\tComponent = instance.components[ name ];\n\n\t\t// best test we have for not Ractive.extend\n\t\tif ( !Component._Parent ) {\n\t\t\t// function option, execute and store for reset\n\t\t\tlet fn = Component.bind( instance );\n\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\tComponent = fn();\n\n\t\t\tif ( !Component ) {\n\t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive });\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( typeof Component === 'string' ) {\n\t\t\t\t// allow string lookup\n\t\t\t\tComponent = getComponent ( ractive, Component );\n\t\t\t}\n\n\t\t\tComponent._fn = fn;\n\t\t\tinstance.components[ name ] = Component;\n\t\t}\n\t}\n\n\treturn Component;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { PARTIAL, TEXT } from 'config/types';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\nimport Mustache from '../shared/Mustache/_Mustache';\nimport rebind from '../shared/Mustache/rebind';\nimport unbind from '../shared/unbind';\nimport getPartialTemplate from './getPartialTemplate';\nimport applyIndent from './applyIndent';\n\nlet missingPartialMessage = 'Could not find template for partial \"%s\"';\n\nlet Partial = function ( options ) {\n\tvar parentFragment, template;\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\n\tthis.root = parentFragment.root;\n\tthis.type = PARTIAL;\n\tthis.index = options.index;\n\tthis.name = options.template.r;\n\tthis.rendered = false;\n\n\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n\tMustache.init( this, options );\n\n\t// If this didn't resolve, it most likely means we have a named partial\n\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t// whose name is the value of `foo`')\n\tif ( !this.keypath ) {\n\t\tif ( template = getPartialTemplate( this.root, this.name, parentFragment ) ) {\n\t\t\tunbind.call( this ); // prevent any further changes\n\t\t\tthis.isNamed = true;\n\t\t\tthis.setTemplate( template );\n\t\t} else {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name );\n\t\t}\n\t}\n};\n\nPartial.prototype = {\n\tbubble () {\n\t\tthis.parentFragment.bubble();\n\t},\n\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tfindNextNode () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t},\n\n\tgetPartialName () {\n\t\tif ( this.isNamed && this.name ) return this.name;\n\t\telse if ( this.value === undefined ) return this.name;\n\t\telse return this.value;\n\t},\n\n\tgetValue () {\n\t\treturn this.fragment.getValue();\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// named partials aren't bound, so don't rebind\n\t\tif ( !this.isNamed ) {\n\t\t\trebind.call( this, oldKeypath, newKeypath );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\trender () {\n\t\tthis.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\n\t\tthis.rendered = true;\n\t\treturn this.docFrag;\n\t},\n\n\tresolve: Mustache.resolve,\n\n\tsetValue ( value ) {\n\t\tvar template;\n\n\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t// nothing has changed, so no work to be done\n\t\t\treturn;\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\ttemplate = getPartialTemplate( this.root, '' + value, this.parentFragment );\n\t\t}\n\n\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t// and a partial. In those cases, this becomes a named partial\n\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name, this.parentFragment ) ) ) {\n\t\t\tunbind.call( this );\n\t\t\tthis.isNamed = true;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name, { ractive: this.root });\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.setTemplate( template || [] );\n\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tsetTemplate ( template ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t}\n\t\t}\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate,\n\t\t\troot: this.root,\n\t\t\towner: this,\n\t\t\tpElement: this.parentFragment.pElement\n\t\t});\n\n\t\tthis.fragmentToRender = this.fragment;\n\t},\n\n\ttoString ( toString ) {\n\t\tvar string, previousItem, lastLine, match;\n\n\t\tstring = this.fragment.toString( toString );\n\n\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\n\t\tif ( !previousItem || ( previousItem.type !== TEXT ) ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\n\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\treturn applyIndent( string, match[0] );\n\t\t}\n\n\t\treturn string;\n\t},\n\n\tunbind () {\n\t\tif ( !this.isNamed ) { // dynamic partial - need to unbind self\n\t\t\tunbind.call( this );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( this.rendered ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t}\n\t},\n\n\tupdate() {\n\t\tvar target, anchor;\n\n\t\tif ( this.fragmentToUnrender ) {\n\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\tthis.fragmentToUnrender = null;\n\t\t}\n\n\t\tif ( this.fragmentToRender ) {\n\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\tthis.fragmentToRender = null;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t}\n};\n\nexport default Partial;\n","export default function ( string, indent ) {\n\tvar indented;\n\n\tif ( !indent ) {\n\t\treturn string;\n\t}\n\n\tindented = string.split( '\\n' ).map( function ( line, notFirstLine ) {\n\t\treturn notFirstLine ? indent + line : line;\n\t}).join( '\\n' );\n\n\treturn indented;\n}\n","import { noRegistryFunctionReturn } from 'config/errors';\nimport { warnIfDebug } from 'utils/log';\nimport parser from 'Ractive/config/custom/template/parser';\nimport { findInstance } from 'shared/registry';\nimport deIndent from './deIndent';\n\nexport default function getPartialTemplate ( ractive, name, parentFragment ) {\n\tvar partial;\n\n\t// If the partial in instance or view heirarchy instances, great\n\tif ( partial = getPartialFromRegistry( ractive, name, parentFragment || {} ) ) {\n\t\treturn partial;\n\t}\n\n\t// Does it exist on the page as a script tag?\n\tpartial = parser.fromId( name, { noThrow: true } );\n\n\tif ( partial ) {\n\t\t// is this necessary?\n\t\tpartial = deIndent( partial );\n\n\t\t// parse and register to this ractive instance\n\t\tlet parsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\n\t\t// register (and return main partial if there are others in the template)\n\t\treturn ractive.partials[ name ] = parsed.t;\n\t}\n}\n\nfunction getPartialFromRegistry ( ractive, name, parentFragment ) {\n\tlet fn, partial = findParentPartial( name, parentFragment.owner );\n\n\t// if there was an instance up-hierarchy, cool\n\tif ( partial ) return partial;\n\n\t// find first instance in the ractive or view hierarchy that has this partial\n\tvar instance = findInstance( 'partials', ractive, name );\n\n\tif ( !instance ) { return; }\n\n\tpartial = instance.partials[ name ];\n\n\t// partial is a function?\n\tif ( typeof partial === 'function' ) {\n\t\tfn = partial.bind( instance );\n\t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n\t\tpartial = fn.call( ractive, parser );\n\t}\n\n\tif ( !partial && partial !== '' ) {\n\t\twarnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive });\n\t\treturn;\n\t}\n\n\t// If this was added manually to the registry,\n\t// but hasn't been parsed, parse it now\n\tif ( !parser.isParsed( partial ) ) {\n\n\t\t// use the parseOptions of the ractive instance on which it was found\n\t\tlet parsed = parser.parse( partial, parser.getParseOptions( instance ) );\n\n\t\t// Partials cannot contain nested partials!\n\t\t// TODO add a test for this\n\t\tif ( parsed.p ) {\n\t\t\twarnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive });\n\t\t}\n\n\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t// in the correct point in prototype chain on instance or constructor\n\t\tlet target = fn ? instance : findOwner( instance, name );\n\n\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\ttarget.partials[ name ] = partial = parsed.t;\n\t}\n\n\t// store for reset\n\tif ( fn ) {\n\t\tpartial._fn = fn;\n\t}\n\n\treturn partial.v ? partial.t : partial;\n}\n\nfunction findOwner ( ractive, key ) {\n\treturn ractive.partials.hasOwnProperty( key )\n\t\t? ractive\n\t\t: findConstructor( ractive.constructor, key);\n}\n\nfunction findConstructor ( constructor, key ) {\n\tif ( !constructor ) { return; }\n\treturn constructor.partials.hasOwnProperty( key )\n\t\t? constructor\n\t\t: findConstructor( constructor._Parent, key );\n}\n\nfunction findParentPartial( name, parent ) {\n\tif ( parent ) {\n\t\tif ( parent.template && parent.template.p && parent.template.p[name] ) {\n\t\t\treturn parent.template.p[name];\n\t\t} else if ( parent.parentFragment && parent.parentFragment.owner ) {\n\t\t\treturn findParentPartial( name, parent.parentFragment.owner );\n\t\t}\n\t}\n}\n","import { lastItem } from 'utils/array';\n\nvar empty = /^\\s*$/, leadingWhitespace = /^\\s*/;\n\nexport default function ( str ) {\n\tvar lines, firstLine, lastLine, minIndent;\n\n\tlines = str.split( '\\n' );\n\n\t// remove first and last line, if they only contain whitespace\n\tfirstLine = lines[0];\n\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\tlines.shift();\n\t}\n\n\tlastLine = lastItem( lines );\n\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\tlines.pop();\n\t}\n\n\tminIndent = lines.reduce( reducer, null );\n\n\tif ( minIndent ) {\n\t\tstr = lines.map( function ( line ) {\n\t\t\treturn line.replace( minIndent, '' );\n\t\t}).join( '\\n' );\n\t}\n\n\treturn str;\n}\n\nfunction reducer ( previous, line ) {\n\tvar lineIndent = leadingWhitespace.exec( line )[0];\n\n\tif ( previous === null || ( lineIndent.length < previous.length ) ) {\n\t\treturn lineIndent;\n\t}\n\n\treturn previous;\n}\n","import bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport getAttribute from './prototype/getAttribute';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Element = function ( options ) {\n\tthis.init( options );\n};\n\nElement.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetAttribute: getAttribute,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Element;\n","import runloop from 'global/runloop';\nimport Transition from '../Transition/_Transition';\nimport { unrender as unrenderForm } from '../special/form';\nimport { unrender } from 'shared/methodCallers';\n\nexport default function Element$unrender ( shouldDestroy ) {\n\tvar binding, bindings, transition;\n\n\tif ( transition = this.transition ) {\n\t\ttransition.complete();\n\t}\n\n\t// Detach as soon as we can\n\tif ( this.name === 'option' ) {\n\t\t// <option> elements detach immediately, so that\n\t\t// their parent <select> element syncs correctly, and\n\t\t// since option elements can't have transitions anyway\n\t\tthis.detach();\n\t} else if ( shouldDestroy ) {\n\t\trunloop.detachWhenReady( this );\n\t}\n\n\t// Children first. that way, any transitions on child elements will be\n\t// handled by the current transitionManager\n\tif ( this.fragment ) {\n\t\tthis.fragment.unrender( false );\n\t}\n\n\tif ( binding = this.binding ) {\n\t\tthis.binding.unrender();\n\n\t\tthis.node._ractive.binding = null;\n\t\tbindings = this.root._twowayBindings[ binding.keypath.str ];\n\t\tbindings.splice( bindings.indexOf( binding ), 1 );\n\t}\n\n\t// Remove event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( unrender );\n\t}\n\n\tif ( this.decorator ) {\n\t\trunloop.registerDecorator( this.decorator );\n\t}\n\n\t// trigger outro transition if necessary\n\tif ( this.root.transitionsEnabled && this.outro ) {\n\t\ttransition = new Transition( this, this.outro, false );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start() );\n\t}\n\n\t// Remove this node from any live queries\n\tif ( this.liveQueries ) {\n\t\tremoveFromLiveQueries( this );\n\t}\n\n\tif ( this.name === 'form' ) {\n\t\tunrenderForm( this );\n\t}\n}\n\nfunction removeFromLiveQueries ( element ) {\n\tvar query, selector, i;\n\n\ti = element.liveQueries.length;\n\twhile ( i-- ) {\n\t\tquery = element.liveQueries[i];\n\t\tselector = query.selector;\n\n\t\tquery._remove( element.node );\n\t}\n}\n","import { unbind as unbindOption } from 'virtualdom/items/Element/special/option';\nimport { unbind } from 'shared/methodCallers';\n\nexport default function Element$unbind () {\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.binding ) {\n\t\tthis.binding.unbind();\n\t}\n\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( unbind );\n\t}\n\n\t// Special case - <option>\n\tif ( this.name === 'option' ) {\n\t\tunbindOption( this );\n\t}\n\n\tthis.attributes.forEach( unbind );\n\tthis.conditionalAttributes.forEach( unbind );\n}\n","import { escapeHtml, voidElementNames } from 'utils/html';\nimport { isArray } from 'utils/is';\n\nexport default function () {\n\tvar str, escape;\n\n\tif ( this.template.y ) {\n\t\t// DOCTYPE declaration\n\t\treturn '<!DOCTYPE' + this.template.dd + '>';\n\t}\n\n\tstr = '<' + this.template.e;\n\n\tstr += this.attributes.map( stringifyAttribute ).join( '' )\n\t     + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\n\t// Special case - selected options\n\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\tstr += ' selected';\n\t}\n\n\t// Special case - two-way radio name bindings\n\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\tstr += ' checked';\n\t}\n\n\tstr += '>';\n\n\t// Special case - textarea\n\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t}\n\n\t// Special case - contenteditable\n\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t}\n\n\tif ( this.fragment ) {\n\t\tescape = ( this.name !== 'script' && this.name !== 'style' );\n\t\tstr += this.fragment.toString( escape );\n\t}\n\n\t// add a closing tag if this isn't a void element\n\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\tstr += '</' + this.template.e + '>';\n\t}\n\n\treturn str;\n}\n\nfunction optionIsSelected ( element ) {\n\tvar optionValue, selectValue, i;\n\n\toptionValue = element.getAttribute( 'value' );\n\n\tif ( optionValue === undefined || !element.select ) {\n\t\treturn false;\n\t}\n\n\tselectValue = element.select.getAttribute( 'value' );\n\n\tif ( selectValue == optionValue ) {\n\t\treturn true;\n\t}\n\n\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction inputIsCheckedRadio ( element ) {\n\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n\tattributes = element.attributes;\n\n\ttypeAttribute  = attributes.type;\n\tvalueAttribute = attributes.value;\n\tnameAttribute  = attributes.name;\n\n\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\treturn;\n\t}\n\n\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\treturn true;\n\t}\n}\n\nfunction stringifyAttribute ( attribute ) {\n\tvar str = attribute.toString();\n\treturn str ? ' ' + str : '';\n}\n","import { namespaces } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport { warnIfDebug } from 'utils/log';\nimport { create, defineProperty } from 'utils/object';\nimport { createElement } from 'utils/dom';\nimport noop from 'utils/noop';\nimport runloop from 'global/runloop';\nimport getInnerContext from 'shared/getInnerContext';\nimport { render as renderImage } from '../special/img';\nimport { render as renderForm } from '../special/form';\nimport Transition from '../Transition/_Transition';\n\nvar updateCss, updateScript;\n\nupdateCss = function () {\n\tvar node = this.node, content = this.fragment.toString( false );\n\n\t// IE8 has no styleSheet unless there's a type text/css\n\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\tnode.type = 'text/css';\n\t}\n\n\tif ( node.styleSheet ) {\n\t\tnode.styleSheet.cssText = content;\n\t} else {\n\n\t\twhile ( node.hasChildNodes() ) {\n\t\t\tnode.removeChild( node.firstChild );\n\t\t}\n\n\t\tnode.appendChild( document.createTextNode(content) );\n\t}\n};\n\nupdateScript = function () {\n\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\twarnIfDebug( 'Script tag was updated. This does not cause the code to be re-evaluated!', { ractive: this.root });\n\t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n\t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n\t\t// But this would be a terrible idea with unpredictable results, so let's not.\n\t}\n\n\tthis.node.text = this.fragment.toString( false );\n};\n\nexport default function Element$render () {\n\tvar root = this.root, namespace, node, transition;\n\n\tnamespace = getNamespace( this );\n\tnode = this.node = createElement( this.name, namespace );\n\n\t// Is this a top-level node of a component? If so, we may need to add\n\t// a data-ractive-css attribute, for CSS encapsulation\n\tif ( this.parentFragment.cssIds ) {\n\t\tthis.node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( x => `{${x}}` ).join( ' ' ) );\n\t}\n\n\t// Add _ractive property to the node - we use this object to store stuff\n\t// related to proxy events, two-way bindings etc\n\tdefineProperty( this.node, '_ractive', {\n\t\tvalue: {\n\t\t\tproxy: this,\n\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\tevents: create( null ),\n\t\t\troot: root\n\t\t}\n\t});\n\n\t// Render attributes\n\tthis.attributes.forEach( a => a.render( node ) );\n\tthis.conditionalAttributes.forEach( a => a.render( node ) );\n\n\t// Render children\n\tif ( this.fragment ) {\n\t\t// Special case - <script> element\n\t\tif ( this.name === 'script' ) {\n\t\t\tthis.bubble = updateScript;\n\t\t\tthis.node.text = this.fragment.toString( false ); // bypass warning initially\n\t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n\t\t}\n\n\t\t// Special case - <style> element\n\t\telse if ( this.name === 'style' ) {\n\t\t\tthis.bubble = updateCss;\n\t\t\tthis.bubble();\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\t// Special case - contenteditable\n\t\telse if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\telse {\n\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\t// deal with two-way bindings\n\tif ( this.binding ) {\n\t\tthis.binding.render();\n\t\tthis.node._ractive.binding = this.binding;\n\t}\n\n\t// Add proxy event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( h => h.render() );\n\t}\n\n\tif ( this.name === 'option' ) {\n\t\tprocessOption( this );\n\t}\n\n\t// Special cases\n\tif ( this.name === 'img' ) {\n\t\t// if this is an <img>, and we're in a crap browser, we may\n\t\t// need to prevent it from overriding width and height when\n\t\t// it loads the src\n\t\trenderImage( this );\n\t} else if ( this.name === 'form' ) {\n\t\t// forms need to keep track of their bindings, in case of reset\n\t\trenderForm( this );\n\t} else if ( this.name === 'input' || this.name === 'textarea' ) {\n\t\t// inputs and textareas should store their initial value as\n\t\t// `defaultValue` in case of reset\n\t\tthis.node.defaultValue = this.node.value;\n\t} else if ( this.name === 'option' ) {\n\t\t// similarly for option nodes\n\t\tthis.node.defaultSelected = this.node.selected;\n\t}\n\n\t// apply decorator(s)\n\tif ( this.decorator && this.decorator.fn ) {\n\t\trunloop.scheduleTask( () => {\n\t\t\tif ( !this.decorator.torndown ) {\n\t\t\t\tthis.decorator.init();\n\t\t\t}\n\t\t}, true );\n\t}\n\n\t// trigger intro transition\n\tif ( root.transitionsEnabled && this.intro ) {\n\t\ttransition = new Transition ( this, this.intro, true );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start(), true );\n\n\t\tthis.transition = transition;\n\t}\n\n\tif ( this.node.autofocus ) {\n\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\trunloop.scheduleTask( () => this.node.focus(), true );\n\t}\n\n\tupdateLiveQueries( this );\n\treturn this.node;\n}\n\nfunction getNamespace ( element ) {\n\tvar namespace, xmlns, parent;\n\n\t// Use specified namespace...\n\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\tnamespace = xmlns;\n\t}\n\n\t// ...or SVG namespace, if this is an <svg> element\n\telse if ( element.name === 'svg' ) {\n\t\tnamespace = namespaces.svg;\n\t}\n\n\telse if ( parent = element.parent ) {\n\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\tnamespace = namespaces.html;\n\t\t}\n\n\t\t// ...or inherit from the parent node\n\t\telse {\n\t\t\tnamespace = parent.node.namespaceURI;\n\t\t}\n\t}\n\n\telse {\n\t\tnamespace = element.root.el.namespaceURI;\n\t}\n\n\treturn namespace;\n}\n\nfunction processOption ( option ) {\n\tvar optionValue, selectValue, i;\n\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\tselectValue = option.select.getAttribute( 'value' );\n\tif ( selectValue === undefined ) {\n\t\treturn;\n\t}\n\n\toptionValue = option.getAttribute( 'value' );\n\n\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( optionValue == selectValue[i] ) {\n\t\t\t\toption.node.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toption.node.selected = ( optionValue == selectValue );\n\t}\n}\n\nfunction updateLiveQueries ( element ) {\n\tvar instance, liveQueries, i, selector, query;\n\n\t// Does this need to be added to any live queries?\n\tinstance = element.root;\n\n\tdo {\n\t\tliveQueries = instance._liveQueries;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tselector = liveQueries[i];\n\t\t\tquery = liveQueries[ '_' + selector ];\n\n\t\t\tif ( query._test( element ) ) {\n\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t}\n\t\t}\n\t} while ( instance = instance.parent );\n}\n","import init from './prototype/init';\nimport getStyle from './prototype/getStyle';\nimport setStyle from './prototype/setStyle';\nimport animateStyle from './prototype/animateStyle/_animateStyle';\nimport processParams from './prototype/processParams';\nimport start from './prototype/start';\n\nvar Transition = function ( owner, template, isIntro ) {\n\tthis.init( owner, template, isIntro );\n};\n\nTransition.prototype = {\n\tinit: init,\n\tstart: start,\n\tgetStyle: getStyle,\n\tsetStyle: setStyle,\n\tanimateStyle: animateStyle,\n\tprocessParams: processParams\n};\n\nexport default Transition;\n","export default function Transition$start () {\n\tvar node, originalStyle, completed;\n\n\tnode = this.node = this.element.node;\n\toriginalStyle = node.getAttribute( 'style' );\n\n\t// create t.complete() - we don't want this on the prototype,\n\t// because we don't want `this` silliness when passing it as\n\t// an argument\n\tthis.complete = noReset => {\n\t\tif ( completed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !noReset && this.isIntro ) {\n\t\t\tresetStyle( node, originalStyle);\n\t\t}\n\n\t\tnode._ractive.transition = null;\n\t\tthis._manager.remove( this );\n\n\t\tcompleted = true;\n\t};\n\n\t// If the transition function doesn't exist, abort\n\tif ( !this._fn ) {\n\t\tthis.complete();\n\t\treturn;\n\t}\n\n\tthis._fn.apply( this.root, [ this ].concat( this.params ) );\n}\n\nfunction resetStyle ( node, style ) {\n\tif ( style ) {\n\t\tnode.setAttribute( 'style', style );\n\t} else {\n\n\t\t// Next line is necessary, to remove empty style attribute!\n\t\t// See http://stackoverflow.com/a/7167553\n\t\tnode.getAttribute( 'style' );\n\t\tnode.removeAttribute( 'style' );\n\t}\n}\n","import { fillGaps } from 'utils/object';\n\nexport default function ( params, defaults ) {\n\tif ( typeof params === 'number' ) {\n\t\tparams = { duration: params };\n\t}\n\n\telse if ( typeof params === 'string' ) {\n\t\tif ( params === 'slow' ) {\n\t\t\tparams = { duration: 600 };\n\t\t} else if ( params === 'fast' ) {\n\t\t\tparams = { duration: 200 };\n\t\t} else {\n\t\t\tparams = { duration: 400 };\n\t\t}\n\t} else if ( !params ) {\n\t\tparams = {};\n\t}\n\n\treturn fillGaps( {}, params, defaults );\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isClient } from 'config/environment';\nimport legacy from 'legacy';\nimport prefix from 'virtualdom/items/Element/Transition/helpers/prefix';\nimport Promise from 'utils/Promise';\nimport createTransitions from './createTransitions';\nimport visibility from './visibility';\n\nvar animateStyle, getComputedStyle, resolved;\n\nif ( !isClient ) {\n\tanimateStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tanimateStyle = function ( style, value, options ) {\n\t\tvar to;\n\n\t\tif ( arguments.length === 4 ) {\n\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t}\n\n\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t// that way you'll never get CSS transitionend events\n\t\tif ( visibility.hidden ) {\n\t\t\tthis.setStyle( style, value );\n\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t}\n\n\t\tif ( typeof style === 'string' ) {\n\t\t\tto = {};\n\t\t\tto[ style ] = value;\n\t\t} else {\n\t\t\tto = style;\n\n\t\t\t// shuffle arguments\n\t\t\toptions = value;\n\t\t}\n\n\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t// callback function that gets called after the animation completes\n\n\t\t// TODO remove this check in a future version\n\t\tif ( !options ) {\n\t\t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\toptions = this;\n\t\t}\n\n\t\tvar promise = new Promise( resolve => {\n\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\tif ( !options.duration ) {\n\t\t\t\tthis.setStyle( to );\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get a list of the properties we're animating\n\t\t\tpropertyNames = Object.keys( to );\n\t\t\tchangedProperties = [];\n\n\t\t\t// Store the current styles\n\t\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\t\tfrom = {};\n\t\t\ti = propertyNames.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = propertyNames[i];\n\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\n\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\tcurrent = 0;\n\t\t\t\t}\n\n\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\tchangedProperties.push( prop );\n\n\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\tthis.node.style[ prefix( prop ) ] = current;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t// will never fire! So we complete early\n\t\t\tif ( !changedProperties.length ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTransitions( this, to, options, changedProperties, resolve );\n\t\t});\n\n\t\treturn promise;\n\t};\n}\n\nexport default animateStyle;\n","import { vendors } from 'config/environment';\n\nvar hidden, vendor, prefix, i, visibility;\n\nif ( typeof document !== 'undefined' ) {\n\thidden = 'hidden';\n\n\tvisibility = {};\n\n\tif ( hidden in document ) {\n\t\tprefix = '';\n\t} else {\n\t\ti = vendors.length;\n\t\twhile ( i-- ) {\n\t\t\tvendor = vendors[i];\n\t\t\thidden = vendor + 'Hidden';\n\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = vendor;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( prefix !== undefined ) {\n\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\n\t\t// initialise\n\t\tonChange();\n\t}\n\n\telse {\n        // gah, we're in an old browser\n        if ( 'onfocusout' in document ) {\n        \tdocument.addEventListener( 'focusout', onHide );\n        \tdocument.addEventListener( 'focusin', onShow );\n        }\n\n        else {\n        \twindow.addEventListener( 'pagehide', onHide );\n        \twindow.addEventListener( 'blur', onHide );\n\n        \twindow.addEventListener( 'pageshow', onShow );\n        \twindow.addEventListener( 'focus', onShow );\n        }\n\n        visibility.hidden = false; // until proven otherwise. Not ideal but hey\n    }\n}\n\nfunction onChange () {\n\tvisibility.hidden = document[ hidden ];\n}\n\nfunction onHide () {\n\tvisibility.hidden = true;\n}\n\nfunction onShow () {\n\tvisibility.hidden = false;\n}\n\nexport default visibility;\n","import { isClient } from 'config/environment';\nimport { warnIfDebug } from 'utils/log';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\nimport interpolate from 'shared/interpolate';\nimport Ticker from 'shared/Ticker';\nimport prefix from '../../helpers/prefix';\nimport unprefix from '../../helpers/unprefix';\nimport hyphenate from '../../helpers/hyphenate';\n\nvar createTransitions,\n\ttestStyle,\n\tTRANSITION,\n\tTRANSITIONEND,\n\tCSS_TRANSITIONS_ENABLED,\n\tTRANSITION_DURATION,\n\tTRANSITION_PROPERTY,\n\tTRANSITION_TIMING_FUNCTION,\n\tcanUseCssTransitions = {},\n\tcannotUseCssTransitions = {};\n\nif ( !isClient ) {\n\tcreateTransitions = null;\n} else {\n\ttestStyle = createElement( 'div' ).style;\n\n\t// determine some facts about our environment\n\t(function() {\n\t\tif ( testStyle.transition !== undefined ) {\n\t\t\tTRANSITION = 'transition';\n\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\tTRANSITION = 'webkitTransition';\n\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else {\n\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t}\n\t}());\n\n\tif ( TRANSITION ) {\n\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t}\n\n\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t// TODO use a fastdom-style mechanism?\n\t\tsetTimeout( function () {\n\n\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n\t\t\tcheckComplete = function () {\n\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t// which properties\n\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\tt.node.style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n\t\t\ttransitionEndHandler = function ( event ) {\n\t\t\t\tvar index;\n\n\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t// still transitioning...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\tsetTimeout( function () {\n\t\t\t\tvar i = changedProperties.length, hash, originalValue, index, propertiesToTransitionInJs = [], prop, suffix;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\thash = hashPrefix + prop;\n\n\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\n\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\n\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t// javascript transitions\n\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\tvar prop, i;\n\n\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t}\n\n\n\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}, 0 );\n\t\t}, options.delay || 0 );\n\t};\n}\n\nexport default createTransitions;\n","import { vendors } from 'config/environment';\n\nvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\nexport default function ( str ) {\n\tvar hyphenated;\n\n\tif ( !str ) {\n\t\treturn ''; // edge case\n\t}\n\n\tif ( vendorPattern.test( str ) ) {\n\t\tstr = '-' + str;\n\t}\n\n\thyphenated = str.replace( /[A-Z]/g, function ( match ) {\n\t\treturn '-' + match.toLowerCase();\n\t});\n\n\treturn hyphenated;\n}\n","import { vendors } from 'config/environment';\n\nvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\nexport default function ( prop ) {\n\treturn prop.replace( unprefixPattern, '' );\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport getTime from 'utils/getTime';\nimport animations from 'shared/animations';\n\n// TODO what happens if a transition is aborted?\n// TODO use this with Animation to dedupe some code?\n\nvar Ticker = function ( options ) {\n\tvar easing;\n\n\tthis.duration = options.duration;\n\tthis.step = options.step;\n\tthis.complete = options.complete;\n\n\t// easing\n\tif ( typeof options.easing === 'string' ) {\n\t\teasing = options.root.easing[ options.easing ];\n\n\t\tif ( !easing ) {\n\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t\t\teasing = linear;\n\t\t}\n\t} else if ( typeof options.easing === 'function' ) {\n\t\teasing = options.easing;\n\t} else {\n\t\teasing = linear;\n\t}\n\n\tthis.easing = easing;\n\n\tthis.start = getTime();\n\tthis.end = this.start + this.duration;\n\n\tthis.running = true;\n\tanimations.add( this );\n};\n\nTicker.prototype = {\n\ttick: function ( now ) {\n\t\tvar elapsed, eased;\n\n\t\tif ( !this.running ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( now > this.end ) {\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( 1 );\n\t\t\t}\n\n\t\t\tif ( this.complete ) {\n\t\t\t\tthis.complete( 1 );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\telapsed = now - this.start;\n\t\teased = this.easing( elapsed / this.duration );\n\n\t\tif ( this.step ) {\n\t\t\tthis.step( eased );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tstop: function () {\n\t\tif ( this.abort ) {\n\t\t\tthis.abort();\n\t\t}\n\n\t\tthis.running = false;\n\t}\n};\n\nexport default Ticker;\nfunction linear ( t ) { return t; }\n","import prefix from '../helpers/prefix';\n\nexport default function ( style, value ) {\n\tvar prop;\n\n\tif ( typeof style === 'string' ) {\n\t\tthis.node.style[ prefix( style ) ] = value;\n\t}\n\n\telse {\n\t\tfor ( prop in style ) {\n\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n}\n","import legacy from 'legacy';\nimport { isClient } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport prefix from '../helpers/prefix';\n\nvar getStyle, getComputedStyle;\n\nif ( !isClient ) {\n\tgetStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tgetStyle = function ( props ) {\n\t\tvar computedStyle, styles, i, prop, value;\n\n\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\tif ( typeof props === 'string' ) {\n\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( !isArray( props ) ) {\n\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t}\n\n\t\tstyles = {};\n\n\t\ti = props.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = props[i];\n\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tstyles[ prop ] = value;\n\t\t}\n\n\t\treturn styles;\n\t};\n}\n\nexport default getStyle;\n","import { isClient, vendors } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\n\nvar prefix, prefixCache, testStyle;\n\nif ( !isClient ) {\n\tprefix = null;\n} else {\n\tprefixCache = {};\n\ttestStyle = createElement( 'div' ).style;\n\n\tprefix = function ( prop ) {\n\t\tvar i, vendor, capped;\n\n\t\tprop = camelCase( prop );\n\n\t\tif ( !prefixCache[ prop ] ) {\n\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// test vendors...\n\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[i];\n\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn prefixCache[ prop ];\n\t};\n}\n\nexport default prefix;\n","export default function ( hyphenatedStr ) {\n\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\treturn $1.toUpperCase();\n\t});\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nexport default function Transition$init ( element, template, isIntro ) {\n\tvar ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\tthis.isIntro = isIntro;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no transition\n\t\t\treturn;\n\t\t}\n\t}\n\n\tthis.name = name;\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t// 'dependency thrashing'?\n\t\tfragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = fragment.getArgsList();\n\t\tfragment.unbind();\n\t}\n\n\tthis._fn = findInViewHierarchy( 'transitions', ractive, name );\n\n\tif ( !this._fn ) {\n\t\twarnOnceIfDebug( missingPlugin( name, 'transition' ), { ractive: this.root });\n\t}\n}\n","import runloop from 'global/runloop';\n\nexport function render ( element ) {\n\telement.node.addEventListener( 'reset', handleReset, false);\n}\n\nexport function unrender ( element ) {\n\telement.node.removeEventListener( 'reset', handleReset, false);\n}\n\nfunction handleReset () {\n\tvar element = this._ractive.proxy;\n\n\trunloop.start();\n\telement.formBindings.forEach( updateModel );\n\trunloop.end();\n}\n\nfunction updateModel ( binding ) {\n\tbinding.root.viewmodel.set( binding.keypath, binding.resetValue );\n}","export function render ( img ) {\n\tvar loadHandler;\n\n\t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n\t// from overriding width and height when it loads the src\n\tif ( img.attributes.width || img.attributes.height ) {\n\t\timg.node.addEventListener( 'load', loadHandler = function () {\n\t\t\tvar width = img.getAttribute( 'width' ),\n\t\t\t\theight = img.getAttribute( 'height' );\n\n\t\t\tif ( width !== undefined ) {\n\t\t\t\timg.node.setAttribute('width', width);\n\t\t\t}\n\n\t\t\tif ( height !== undefined ) {\n\t\t\t\timg.node.setAttribute('height', height);\n\t\t\t}\n\n\t\t\timg.node.removeEventListener( 'load', loadHandler, false );\n\t\t}, false );\n\t}\n}\n","import { assignNewKeypath } from 'shared/keypaths';\n\nexport default function Element$rebind ( oldKeypath, newKeypath ) {\n\tvar i, storage, liveQueries, ractive;\n\n\tif ( this.attributes ) {\n\t\tthis.attributes.forEach( rebind );\n\t}\n\n\tif ( this.conditionalAttributes ) {\n\t\tthis.conditionalAttributes.forEach( rebind );\n\t}\n\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( rebind );\n\t}\n\n\tif ( this.decorator ) {\n\t\trebind( this.decorator );\n\t}\n\n\t// rebind children\n\tif ( this.fragment ) {\n\t\trebind( this.fragment );\n\t}\n\n\t// Update live queries, if necessary\n\tif ( liveQueries = this.liveQueries ) {\n\t\tractive = this.root;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tliveQueries[i]._makeDirty();\n\t\t}\n\t}\n\n\tif ( this.node && ( storage = this.node._ractive ) ) {\n\n\t\t// adjust keypath if needed\n\t\tassignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { ELEMENT } from 'config/types';\nimport processBindingAttributes from './init/processBindingAttributes';\nimport createAttributes from './init/createAttributes';\nimport createConditionalAttributes from './init/createConditionalAttributes';\nimport createTwowayBinding from './init/createTwowayBinding';\nimport createEventHandlers from './init/createEventHandlers';\nimport enforceCase from '../shared/enforceCase';\nimport Decorator from '../Decorator/_Decorator';\nimport { bubble as bubbleSelect } from '../special/select';\nimport { init as initOption } from '../special/option';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Element$init ( options ) {\n\tvar parentFragment,\n\t\ttemplate,\n\t\tractive,\n\t\tbinding,\n\t\tbindings,\n\t\ttwoway,\n\t\tbindingAttrs;\n\n\tthis.type = ELEMENT;\n\n\t// stuff we'll need later\n\tparentFragment = this.parentFragment = options.parentFragment;\n\ttemplate = this.template = options.template;\n\n\tthis.parent = options.pElement || parentFragment.pElement;\n\n\tthis.root = ractive = parentFragment.root;\n\tthis.index = options.index;\n\tthis.key = options.key;\n\n\tthis.name = enforceCase( template.e );\n\n\t// Special case - <option> elements\n\tif ( this.name === 'option' ) {\n\t\tinitOption( this, template );\n\t}\n\n\t// Special case - <select> elements\n\tif ( this.name === 'select' ) {\n\t\tthis.options = [];\n\t\tthis.bubble = bubbleSelect; // TODO this is a kludge\n\t}\n\n\t// Special case - <form> elements\n\tif ( this.name === 'form' ) {\n\t\tthis.formBindings = [];\n\t}\n\n\t// handle binding attributes first (twoway, lazy)\n\tbindingAttrs = processBindingAttributes( this, template );\n\n\t// create attributes\n\tthis.attributes = createAttributes( this, template.a );\n\tthis.conditionalAttributes = createConditionalAttributes( this, template.m );\n\n\t// append children, if there are any\n\tif ( template.f ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.f,\n\t\t\troot:     ractive,\n\t\t\towner:    this,\n\t\t\tpElement: this,\n\t\t\tcssIds: null\n\t\t});\n\t}\n\n\t// the element setting should override the ractive setting\n\ttwoway = ractive.twoway;\n\tif ( bindingAttrs.twoway === false ) twoway = false;\n\telse if ( bindingAttrs.twoway === true ) twoway = true;\n\n\tthis.twoway = twoway;\n\tthis.lazy = bindingAttrs.lazy;\n\n\t// create twoway binding\n\tif ( twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {\n\t\tthis.binding = binding;\n\n\t\t// register this with the root, so that we can do ractive.updateModel()\n\t\tbindings = this.root._twowayBindings[ binding.keypath.str ] || ( this.root._twowayBindings[ binding.keypath.str ] = [] );\n\t\tbindings.push( binding );\n\t}\n\n\t// create event proxies\n\tif ( template.v ) {\n\t\tthis.eventHandlers = createEventHandlers( this, template.v );\n\t}\n\n\t// create decorator\n\tif ( template.o ) {\n\t\tthis.decorator = new Decorator( this, template.o );\n\t}\n\n\t// create transitions\n\tthis.intro = template.t0 || template.t1;\n\tthis.outro = template.t0 || template.t2;\n}\n","import { removeFromArray } from 'utils/array';\n\nexport function init ( option, template ) {\n\toption.select = findParentSelect( option.parent );\n\n\t// we might be inside a <datalist> element\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\toption.select.options.push( option );\n\n\t// If the value attribute is missing, use the element's content\n\tif ( !template.a ) {\n\t\ttemplate.a = {};\n\t}\n\n\t// ...as long as it isn't disabled\n\tif ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {\n\t\ttemplate.a.value = template.f;\n\t}\n\n\t// If there is a `selected` attribute, but the <select>\n\t// already has a value, delete it\n\tif ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {\n\t\tdelete template.a.selected;\n\t}\n}\n\nexport function unbind ( option ) {\n\tif ( option.select ) {\n\t\tremoveFromArray( option.select.options, option );\n\t}\n}\n\nfunction findParentSelect ( element ) {\n\tif ( !element ) { return; }\n\n\tdo {\n\t\tif ( element.name === 'select' ) {\n\t\t\treturn element;\n\t\t}\n\t} while ( element = element.parent );\n}\n","import { toArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nexport function bubble () {\n\tif ( !this.dirty ) {\n\t\tthis.dirty = true;\n\n\t\trunloop.scheduleTask( () => {\n\t\t\tsync( this );\n\t\t\tthis.dirty = false;\n\t\t});\n\t}\n\n\tthis.parentFragment.bubble(); // default behaviour\n}\n\nfunction sync ( selectElement ) {\n\tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n\tselectNode = selectElement.node;\n\n\tif ( !selectNode ) {\n\t\treturn;\n\t}\n\n\toptions = toArray( selectNode.options );\n\n\tselectValue = selectElement.getAttribute( 'value' );\n\tisMultiple = selectElement.getAttribute( 'multiple' );\n\n\t// If the <select> has a specified value, that should override\n\t// these options\n\tif ( selectValue !== undefined ) {\n\t\toptions.forEach( o => {\n\t\t\tvar optionValue, shouldSelect;\n\n\t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\tshouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\n\t\t\tif ( shouldSelect ) {\n\t\t\t\toptionWasSelected = true;\n\t\t\t}\n\n\t\t\to.selected = shouldSelect;\n\t\t});\n\n\t\tif ( !optionWasSelected ) {\n\t\t\tif ( options[0] ) {\n\t\t\t\toptions[0].selected = true;\n\t\t\t}\n\n\t\t\tif ( selectElement.binding ) {\n\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Otherwise the value should be initialised according to which\n\t// <option> element is selected, if twoway binding is in effect\n\telse if ( selectElement.binding ) {\n\t\tselectElement.binding.forceUpdate();\n\t}\n}\n\nfunction valueContains ( selectValue, optionValue ) {\n\tvar i = selectValue.length;\n\twhile ( i-- ) {\n\t\tif ( selectValue[i] == optionValue ) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","import { fatal } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar Decorator = function ( element, template ) {\n\tvar self = this, ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no decorator\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = this.fragment.getArgsList();\n\n\t\tthis.fragment.bubble = function () {\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tself.params = this.getArgsList();\n\n\t\t\tif ( self.ready ) {\n\t\t\t\tself.update();\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.fn = findInViewHierarchy( 'decorators', ractive, name );\n\n\tif ( !this.fn ) {\n\t\tfatal( missingPlugin( name, 'decorator' ) );\n\t}\n};\n\nDecorator.prototype = {\n\tinit: function () {\n\t\tvar node, result, args;\n\n\t\tnode = this.element.node;\n\n\t\tif ( this.params ) {\n\t\t\targs = [ node ].concat( this.params );\n\t\t\tresult = this.fn.apply( this.root, args );\n\t\t} else {\n\t\t\tresult = this.fn.call( this.root, node );\n\t\t}\n\n\t\tif ( !result || !result.teardown ) {\n\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t}\n\n\t\t// TODO does this make sense?\n\t\tthis.actual = result;\n\t\tthis.ready = true;\n\t},\n\n\tupdate: function () {\n\t\tif ( this.actual.update ) {\n\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t}\n\n\t\telse {\n\t\t\tthis.actual.teardown( true );\n\t\t\tthis.init();\n\t\t}\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tteardown: function ( updating ) {\n\t\tthis.torndown = true;\n\t\tif ( this.ready ) {\n\t\t\tthis.actual.teardown();\n\t\t}\n\n\t\tif ( !updating && this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t}\n};\n\nexport default Decorator;\n","import EventHandler from '../../EventHandler/_EventHandler';\n\nexport default function ( element, template ) {\n\tvar i, name, names, handler, result = [];\n\n\tfor ( name in template ) {\n\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\tnames = name.split( '-' );\n\t\t\ti = names.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\thandler = new EventHandler( element, names[i], template[ name ] );\n\t\t\t\tresult.push( handler );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n","import bubble from './prototype/bubble';\nimport fire from './prototype/fire';\nimport getAction from './prototype/getAction';\nimport init from './prototype/init';\nimport listen from './prototype/listen';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport resolve from './prototype/resolve';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar EventHandler = function ( element, name, template ) {\n\tthis.init( element, name, template );\n};\n\nEventHandler.prototype = {\n\tbubble: bubble,\n\tfire: fire,\n\tgetAction: getAction,\n\tinit: init,\n\tlisten: listen,\n\trebind: rebind,\n\trender: render,\n\tresolve: resolve,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default EventHandler;\n","import genericHandler from '../shared/genericHandler';\n\nexport default function EventHandler$unrender () {\n\n\tif ( this.custom ) {\n\t\tthis.custom.teardown();\n\t}\n\n\telse {\n\t\tthis.node.removeEventListener( this.name, genericHandler, false );\n\t}\n\n\tthis.hasListener = false;\n\n}\n","import { unbind } from 'shared/methodCallers';\n\nexport default function EventHandler$unbind () {\n\tif ( this.method ) {\n\t\tthis.refResolvers.forEach( unbind );\n\t\treturn;\n\t}\n\n\t// Tear down dynamic name\n\tif ( typeof this.action !== 'string' ) {\n\t\tthis.action.unbind();\n\t}\n\n\t// Tear down dynamic parameters\n\tif ( this.dynamicParams ) {\n\t\tthis.dynamicParams.unbind();\n\t}\n}\n","export default function EventHandler$resolve ( index, keypath ) {\n\tthis.keypaths[ index ] = keypath;\n}\n","export default function EventHandler$render () {\n\tthis.node = this.element.node;\n\t// store this on the node itself, so it can be retrieved by a\n\t// universal handler\n\tthis.node._ractive.events[ this.name ] = this;\n\n\tif ( this.method || this.getAction() ) {\n\t\tthis.listen();\n\t}\n}\n","export default function EventHandler$rebind ( oldKeypath, newKeypath ) {\n\tvar fragment;\n\tif ( this.method ) {\n\t\tfragment = this.element.parentFragment;\n\t\tthis.refResolvers.forEach( rebind );\n\n\t\treturn;\n\t}\n\n\tif ( typeof this.action !== 'string' ) {\n\t\trebind( this.action );\n\t}\n\n\tif ( this.dynamicParams ) {\n\t\trebind( this.dynamicParams );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing && thing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isJsdom } from 'config/environment';\nimport { missingPlugin } from 'config/errors';\nimport genericHandler from '../shared/genericHandler';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar customHandlers = {},\n\ttouchEvents = {\n\t\ttouchstart: true,\n\t\ttouchmove: true,\n\t\ttouchend: true,\n\t\ttouchcancel: true,\n\t\t//not w3c, but supported in some browsers\n\t\ttouchleave: true\n\t};\n\nexport default function EventHandler$listen () {\n\tvar definition, name = this.name;\n\n\tif ( this.invalid ) { return; }\n\n\tif ( definition = findInViewHierarchy( 'events', this.root, name ) ) {\n\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t} else {\n\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) && !isJsdom ) {\n\n\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\twarnOnceIfDebug( missingPlugin( name, 'event' ), { node: this.node });\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.addEventListener( name, genericHandler, false );\n\t}\n\n\tthis.hasListener = true;\n}\n\nfunction getCustomHandler ( name ) {\n\tif ( !customHandlers[ name ] ) {\n\t\tcustomHandlers[ name ] = function ( event ) {\n\t\t\tvar storage = event.node._ractive;\n\n\t\t\tevent.index = storage.index;\n\t\t\tevent.keypath = storage.keypath.str;\n\t\t\tevent.context = storage.root.viewmodel.get( storage.keypath );\n\n\t\t\tstorage.events[ name ].fire( event );\n\t\t};\n\t}\n\n\treturn customHandlers[ name ];\n}\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function genericHandler ( event ) {\n\tvar storage, handler, indices, index = {};\n\n\tstorage = this._ractive;\n\thandler = storage.events[ event.type ];\n\n\tif ( indices = findIndexRefs( handler.element.parentFragment ) ) {\n\t\tindex = findIndexRefs.resolve( indices );\n\t}\n\n\thandler.fire({\n\t\tnode: this,\n\t\toriginal: event,\n\t\tindex: index,\n\t\tkeypath: storage.keypath.str,\n\t\tcontext: storage.root.viewmodel.get( storage.keypath )\n\t});\n}\n","import getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport Fragment from 'virtualdom/Fragment';\nimport eventStack from 'Ractive/prototype/shared/eventStack';\nimport fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal } from 'utils/log';\n\nvar eventPattern = /^event(?:\\.(.+))?/;\n\nexport default function EventHandler$init ( element, name, template ) {\n\tvar action, refs, ractive;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\tthis.name = name;\n\n\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\tfatal( 'Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid', element.name, name );\n\t\tthis.invalid = true;\n\t}\n\n\tif ( template.m ) {\n\t\trefs = template.a.r;\n\n\t\t// This is a method call\n\t\tthis.method = template.m;\n\t\tthis.keypaths = [];\n\t\tthis.fn = getFunctionFromString( template.a.s, refs.length );\n\n\t\tthis.parentFragment = element.parentFragment;\n\t\tractive = this.root;\n\n\t\t// Create resolvers for each reference\n\t\tthis.refResolvers = [];\n\t\trefs.forEach(( ref, i ) => {\n\t\t\tlet match;\n\n\t\t\t// special case - the `event` object\n\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\tthis.keypaths[i] = {\n\t\t\t\t\teventObject: true,\n\t\t\t\t\trefinements: match[1] ? match[1].split( '.' ) : []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.refResolvers.push( createReferenceResolver( this, ref, keypath => this.resolve( i, keypath ) ) );\n\t\t\t}\n\t\t});\n\n\t\tthis.fire = fireMethodCall;\n\t}\n\n\telse {\n\t\t// Get action ('foo' in 'on-click='foo')\n\t\taction = template.n || template;\n\t\tif ( typeof action !== 'string' ) {\n\t\t\taction = new Fragment({\n\t\t\t\ttemplate: action,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tthis.action = action;\n\n\t\t// Get parameters\n\t\tif ( template.d ) {\n\t\t\tthis.dynamicParams = new Fragment({\n\t\t\t\ttemplate: template.d,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this.element\n\t\t\t});\n\n\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t} else if ( template.a ) {\n\t\t\tthis.params = template.a;\n\t\t\tthis.fire = fireEventWithParams;\n\t\t}\n\t}\n}\n\n\nfunction fireMethodCall ( event ) {\n\tvar ractive, values, args;\n\n\tractive = this.root;\n\n\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t}\n\n\tvalues = this.keypaths.map( function ( keypath ) {\n\t\tvar value, len, i;\n\n\t\tif ( keypath === undefined ) {\n\t\t\t// not yet resolved\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// TODO the refinements stuff would be better handled at parse time\n\t\tif ( keypath.eventObject ) {\n\t\t\tvalue = event;\n\n\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvalue = value[ keypath.refinements[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t}\n\n\t\treturn value;\n\t});\n\n\teventStack.enqueue( ractive, event );\n\n\targs = this.fn.apply( null, values );\n\tractive[ this.method ].apply( ractive, args );\n\n\teventStack.dequeue( ractive );\n}\n\nfunction fireEventWithParams ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event, args: this.params } );\n}\n\nfunction fireEventWithDynamicParams ( event ) {\n\tvar args = this.dynamicParams.getArgsList();\n\n\t// need to strip [] from ends if a string!\n\tif ( typeof args === 'string' ) {\n\t\targs = args.substr( 1, args.length - 2 );\n\t}\n\n\tfireEvent( this.root, this.getAction(), { event: event, args: args } );\n}\n","export default function EventHandler$getAction () {\n\treturn this.action.toString().trim();\n}\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\n\n// This function may be overwritten, if the event directive\n// includes parameters\nexport default function EventHandler$fire ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event } );\n}\n","export default function EventHandler$bubble () {\n\tvar hasAction = this.getAction();\n\n\tif( hasAction && !this.hasListener ) {\n\t\tthis.listen();\n\t}\n\telse if ( !hasAction && this.hasListener ) {\n\t\tthis.unrender();\n\t}\n}\n","import { warnIfDebug } from 'utils/log';\nimport ContentEditableBinding from '../../Binding/ContentEditableBinding';\nimport RadioBinding from '../../Binding/RadioBinding';\nimport RadioNameBinding from '../../Binding/RadioNameBinding';\nimport CheckboxNameBinding from '../../Binding/CheckboxNameBinding';\nimport CheckboxBinding from '../../Binding/CheckboxBinding';\nimport SelectBinding from '../../Binding/SelectBinding';\nimport MultipleSelectBinding from '../../Binding/MultipleSelectBinding';\nimport FileListBinding from '../../Binding/FileListBinding';\nimport NumericBinding from '../../Binding/NumericBinding';\nimport GenericBinding from '../../Binding/GenericBinding';\n\nexport default function createTwowayBinding ( element ) {\n\tvar attributes = element.attributes, type, Binding, bindName, bindChecked, binding;\n\n\t// if this is a late binding, and there's already one, it\n\t// needs to be torn down\n\tif ( element.binding ) {\n\t\telement.binding.teardown();\n\t\telement.binding = null;\n\t}\n\n\t// contenteditable\n\tif (\n\t\t// if the contenteditable attribute is true or is bindable and may thus become true\n\t\t( element.getAttribute( 'contenteditable' ) || ( !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) )\n\t\t// and this element also has a value attribute to bind\n\t\t&& isBindable( attributes.value )\n\t) {\n\t\tBinding = ContentEditableBinding;\n\t}\n\n\t// <input>\n\telse if ( element.name === 'input' ) {\n\t\ttype = element.getAttribute( 'type' );\n\n\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\tbindName = isBindable( attributes.name );\n\t\t\tbindChecked = isBindable( attributes.checked );\n\n\t\t\t// we can either bind the name attribute, or the checked attribute - not both\n\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\twarnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });\n\t\t\t}\n\n\t\t\tif ( bindName ) {\n\t\t\t\tBinding = ( type === 'radio' ? RadioNameBinding : CheckboxNameBinding );\n\t\t\t}\n\n\t\t\telse if ( bindChecked ) {\n\t\t\t\tBinding = ( type === 'radio' ? RadioBinding : CheckboxBinding );\n\t\t\t}\n\t\t}\n\n\t\telse if ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\tBinding = FileListBinding;\n\t\t}\n\n\t\telse if ( isBindable( attributes.value ) ) {\n\t\t\tBinding = ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n\t\t}\n\t}\n\n\t// <select>\n\telse if ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\tBinding = ( element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding );\n\t}\n\n\t// <textarea>\n\telse if ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\tBinding = GenericBinding;\n\t}\n\n\tif ( Binding && ( binding = new Binding( element ) ) && binding.keypath ) {\n\t\treturn binding;\n\t}\n}\n\nfunction isBindable ( attribute ) {\n\treturn attribute && attribute.isBindable;\n}\n","import GenericBinding from './GenericBinding';\n\nexport default GenericBinding.extend({\n\tgetInitialValue: () => undefined,\n\n\tgetValue: function () {\n\t\tvar value = parseFloat( this.element.node.value );\n\t\treturn isNaN( value ) ? undefined : value;\n\t}\n});\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar FileListBinding = Binding.extend({\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.files;\n\t}\n});\n\nexport default FileListBinding;\n","import runloop from 'global/runloop';\nimport { arrayContentsMatch } from 'utils/array';\nimport SelectBinding from './SelectBinding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar MultipleSelectBinding = SelectBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.options\n\t\t\t.filter( option => option.getAttribute( 'selected' ) )\n\t\t\t.map( option => option.getAttribute( 'value' ) );\n\t},\n\n\trender: function () {\n\t\tvar valueFromModel;\n\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\n\t\tif ( valueFromModel === undefined ) {\n\t\t\t// get value from DOM, if possible\n\t\t\tthis.handleChange();\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tsetValue: function () {\n\t\tthrow new Error( 'TODO not implemented yet' );\n\t},\n\n\tgetValue: function () {\n\t\tvar selectedValues, options, i, len, option, optionValue;\n\n\t\tselectedValues = [];\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i=0; i<len; i+=1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( option.selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\tselectedValues.push( optionValue );\n\t\t\t}\n\t\t}\n\n\t\treturn selectedValues;\n\t},\n\n\thandleChange: function () {\n\t\tvar attribute, previousValue, value;\n\n\t\tattribute = this.attribute;\n\t\tpreviousValue = attribute.value;\n\n\t\tvalue = this.getValue();\n\n\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t},\n\n\tupdateModel: function () {\n\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t}\n\t}\n});\n\nexport default MultipleSelectBinding;\n","import runloop from 'global/runloop';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar SelectBinding = Binding.extend({\n\tgetInitialValue: function () {\n\t\tvar options = this.element.options, len, i, value, optionWasSelected;\n\n\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\ti = len = options.length;\n\n\t\tif ( !len ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// take the final selected option...\n\t\twhile ( i-- ) {\n\t\t\tif ( options[i].getAttribute( 'selected' ) ) {\n\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\toptionWasSelected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// or the first non-disabled option, if none are selected\n\t\tif ( !optionWasSelected ) {\n\t\t\twhile ( ++i < len ) {\n\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t// other more expensive work\n\t\tif ( value !== undefined ) {\n\t\t\tthis.element.attributes.value.value = value;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\t// TODO this method is an anomaly... is it necessary?\n\tsetValue: function ( value ) {\n\t\tthis.root.viewmodel.set( this.keypath, value );\n\t},\n\n\tgetValue: function () {\n\t\tvar options, i, len, option, optionValue;\n\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( options[i].selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\treturn optionValue;\n\t\t\t}\n\t\t}\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t}\n});\n\nexport default SelectBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxBinding = Binding.extend({\n\tname: 'checked',\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t}\n});\n\nexport default CheckboxBinding;\n","import { isArray } from 'utils/is';\nimport { arrayContains, removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxNameBinding = Binding.extend({\n\tname: 'name',\n\n\tgetInitialValue: function () {\n\t\t// This only gets called once per group (of inputs that\n\t\t// share a name), because it only gets called if there\n\t\t// isn't an initial value. By the same token, we can make\n\t\t// a note of that fact that there was no initial value,\n\t\t// and populate it using any `checked` attributes that\n\t\t// exist (which users should avoid, but which we should\n\t\t// support anyway to avoid breaking expectations)\n\t\tthis.noInitialValue = true;\n\t\treturn [];\n\t},\n\n\tinit: function () {\n\t\tvar existingValue, bindingValue;\n\n\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n\t\t// Each input has a reference to an array containing it and its\n\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t// the status of all inputs within the group\n\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tif ( this.noInitialValue ) {\n\t\t\tthis.siblings.noInitialValue = true;\n\t\t}\n\n\t\t// If no initial value was set, and this input is checked, we\n\t\t// update the model\n\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\t\texistingValue.push( bindingValue );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, existingValue, bindingValue;\n\n\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\tif ( isArray( existingValue ) ) {\n\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t} else {\n\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t}\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.isChecked;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t// in case of IE emergency, bind to click event as well\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tchanged: function () {\n\t\tvar wasChecked = !!this.isChecked;\n\t\tthis.isChecked = this.element.node.checked;\n\t\treturn this.isChecked === wasChecked;\n\t},\n\n\thandleChange: function () {\n\t\tthis.isChecked = this.element.node.checked;\n\t\tBinding.prototype.handleChange.call( this );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t}\n});\n\nfunction isChecked ( binding ) {\n\treturn binding.isChecked;\n}\n\nfunction getValue ( binding ) {\n\treturn binding.element.getAttribute( 'value' );\n}\n\nexport default CheckboxNameBinding;\n","import { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport getSiblings from './shared/getSiblings';\n\nvar RadioNameBinding = Binding.extend({\n\tname: 'name',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n\t},\n\n\tgetInitialValue: function () {\n\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\treturn this.element.getAttribute( 'value' );\n\t\t}\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\tvar node = this.element.node;\n\t\treturn node._ractive ? node._ractive.value : node.value;\n\t},\n\n\thandleChange: function () {\n\t\t// If this <input> is the one that's checked, then the value of its\n\t\t// `name` keypath gets set to its value\n\t\tif ( this.element.node.checked ) {\n\t\t\tBinding.prototype.handleChange.call( this );\n\t\t}\n\t},\n\n\trebound: function ( oldKeypath, newKeypath ) {\n\t\tvar node;\n\n\t\tBinding.prototype.rebound.call( this, oldKeypath, newKeypath );\n\n\t\tif ( node = this.element.node ) {\n\t\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioNameBinding;\n","import runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar RadioBinding = Binding.extend({\n\tname: 'checked',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\tthis.siblings.push( this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\n\t\tthis.siblings.forEach( binding => {\n\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t});\n\n\t\trunloop.end();\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioBinding;\n","var sets = {};\n\nexport default function getSiblings ( id, group, keypath ) {\n\tvar hash = id + group + keypath;\n\treturn sets[ hash ] || ( sets[ hash ] = [] );\n}\n","import GenericBinding from './GenericBinding';\n\nvar ContentEditableBinding = GenericBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.innerHTML;\n\t}\n});\n\nexport default ContentEditableBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport { isNumeric } from 'utils/is';\n\nvar GenericBinding;\n\nGenericBinding = Binding.extend({\n\tgetInitialValue: () => '',\n\n\tgetValue: function () {\n\t\treturn this.element.node.value;\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, lazy, timeout = false;\n\t\tthis.rendered = true;\n\n\t\t// any lazy setting for this element overrides the root\n\t\t// if the value is a number, it's a timeout\n\t\tlazy = this.root.lazy;\n\t\tif ( this.element.lazy === true ) {\n\t\t\tlazy = true;\n\t\t} else if ( this.element.lazy === false ) {\n\t\t\tlazy = false;\n\t\t} else if ( isNumeric( this.element.lazy ) ) {\n\t\t\tlazy = false;\n\t\t\ttimeout = +this.element.lazy;\n\t\t} else if ( isNumeric( ( lazy || '' ) ) ) {\n\t\t\ttimeout = +lazy;\n\t\t\tlazy = false;\n\n\t\t\t// make sure the timeout is available to the handler\n\t\t\tthis.element.lazy = timeout;\n\t\t}\n\n\t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( !lazy ) {\n\t\t\tnode.addEventListener( 'input', this.handler, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\t\tthis.rendered = false;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t}\n});\n\nexport default GenericBinding;\n\n\nfunction handleBlur () {\n\tvar value;\n\n\thandleDomEvent.call( this );\n\n\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath );\n\tthis.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay () {\n\tvar binding = this._ractive.binding, el = this;\n\n\tif ( !!binding._timeout ) clearTimeout( binding._timeout );\n\n\tbinding._timeout = setTimeout( () => {\n\t\tif ( binding.rendered ) handleDomEvent.call( el );\n\t\tbinding._timeout = undefined;\n\t}, binding.element.lazy );\n}\n","// This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\nexport default function handleChange () {\n\tthis._ractive.binding.handleChange();\n}\n","import runloop from 'global/runloop';\nimport { warnIfDebug, warnOnceIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { removeFromArray } from 'utils/array';\n\nvar Binding = function ( element ) {\n\tvar interpolator, keypath, value, parentForm;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.attribute = element.attributes[ this.name || 'value' ];\n\n\tinterpolator = this.attribute.interpolator;\n\tinterpolator.twowayBinding = this;\n\n\tif ( keypath = interpolator.keypath ) {\n\t\tif ( keypath.str.slice( -1 ) === '}' ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with expressions (`%s` on <%s>)', interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with %s', interpolator.resolver.ref, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\t}\n\n\telse {\n\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t//\n\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t// assumption. That assumption is that the input in question should\n\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t// and not `foo.bar`.\n\t\t//\n\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\tlet ref = interpolator.template.r ? `'${interpolator.template.r}' reference` : 'expression';\n\t\twarnIfDebug( 'The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity', ref, { ractive: this.root });\n\t\tinterpolator.resolver.forceResolution();\n\t\tkeypath = interpolator.keypath;\n\t}\n\n\tthis.attribute.isTwoway = true;\n\tthis.keypath = keypath;\n\n\t// initialise value, if it's undefined\n\tvalue = this.root.viewmodel.get( keypath );\n\n\tif ( value === undefined && this.getInitialValue ) {\n\t\tvalue = this.getInitialValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t}\n\t}\n\n\tif ( parentForm = findParentForm( element ) ) {\n\t\tthis.resetValue = value;\n\t\tparentForm.formBindings.push( this );\n\t}\n};\n\nBinding.prototype = {\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\t\tthis.attribute.locked = true;\n\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\trunloop.end();\n\t},\n\n\trebound: function () {\n\t\tvar bindings, oldKeypath, newKeypath;\n\n\t\toldKeypath = this.keypath;\n\t\tnewKeypath = this.attribute.interpolator.keypath;\n\n\t\t// The attribute this binding is linked to has already done the work\n\t\tif ( oldKeypath === newKeypath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath.str ], this );\n\n\t\tthis.keypath = newKeypath;\n\n\t\tbindings = this.root._twowayBindings[ newKeypath.str ] || ( this.root._twowayBindings[ newKeypath.str ] = [] );\n\t\tbindings.push( this );\n\t},\n\n\tunbind: function () {\n\t\t// this is called when the element is unbound.\n\t\t// Specialised bindings can override it\n\t}\n};\n\nBinding.extend = function ( properties ) {\n\tvar Parent = this, SpecialisedBinding;\n\n\tSpecialisedBinding = function ( element ) {\n\t\tBinding.call( this, element );\n\n\t\tif ( this.init ) {\n\t\t\tthis.init();\n\t\t}\n\t};\n\n\tSpecialisedBinding.prototype = create( Parent.prototype );\n\textend( SpecialisedBinding.prototype, properties );\n\n\tSpecialisedBinding.extend = Binding.extend;\n\n\treturn SpecialisedBinding;\n};\n\nexport default Binding;\n\nfunction findParentForm ( element ) {\n\twhile ( element = element.parent ) {\n\t\tif ( element.name === 'form' ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n","import ConditionalAttribute from '../../ConditionalAttribute/_ConditionalAttribute';\n\nexport default function ( element, attributes ) {\n\tif ( !attributes ) {\n\t\treturn [];\n\t}\n\n\treturn attributes.map( a => {\n\t\treturn new ConditionalAttribute( element, a );\n\t});\n}\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport { toArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\n\nvar div;\n\nif ( typeof document !== 'undefined' ) {\n\tdiv = createElement( 'div' );\n}\n\nvar ConditionalAttribute = function ( element, template ) {\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\n\tthis.attributes = [];\n\n\tthis.fragment = new Fragment({\n\t\troot: element.root,\n\t\towner: this,\n\t\ttemplate: [ template ]\n\t});\n};\n\nConditionalAttribute.prototype = {\n\tbubble: function () {\n\t\tif ( this.node ) {\n\t\t\tthis.update();\n\t\t}\n\n\t\tthis.element.bubble();\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\trender: function ( node ) {\n\t\tthis.node = node;\n\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n\t\tthis.update();\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tupdate: function () {\n\t\tvar str, attrs;\n\n\t\tstr = this.fragment.toString();\n\t\tattrs = parseAttributes( str, this.isSvg );\n\n\t\t// any attributes that previously existed but no longer do\n\t\t// must be removed\n\t\tthis.attributes.filter( a => notIn( attrs, a ) ).forEach( a => {\n\t\t\tthis.node.removeAttribute( a.name );\n\t\t});\n\n\t\tattrs.forEach( a => {\n\t\t\tthis.node.setAttribute( a.name, a.value );\n\t\t});\n\n\t\tthis.attributes = attrs;\n\t},\n\n\ttoString: function () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default ConditionalAttribute;\n\n\nfunction parseAttributes ( str, isSvg ) {\n\tvar tag = isSvg ? 'svg' : 'div';\n\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\n\treturn toArray( div.childNodes[0].attributes );\n}\n\nfunction notIn ( haystack, needle ) {\n\tvar i = haystack.length;\n\n\twhile ( i-- ) {\n\t\tif ( haystack[i].name === needle.name ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","import Attribute from '../../Attribute/_Attribute';\n\nexport default function ( element, attributes ) {\n\tvar name, attribute, result = [];\n\n\tfor ( name in attributes ) {\n\t\t// skip binding attributes\n\t\tif ( name === 'twoway' || name === 'lazy') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\tattribute = new Attribute({\n\t\t\t\telement: element,\n\t\t\t\tname:    name,\n\t\t\t\tvalue:   attributes[ name ],\n\t\t\t\troot:    element.root\n\t\t\t});\n\n\t\t\tresult[ name ] = attribute;\n\n\t\t\tif ( name !== 'value' ) {\n\t\t\t\tresult.push( attribute );\n\t\t\t}\n\t\t}\n\t}\n\n\t// value attribute goes last. This is because it\n\t// may get clamped on render otherwise, e.g. in\n\t// `<input type='range' value='999' min='0' max='1000'>`\n\t// since default max is 100\n\tif ( attribute = result.value ) {\n\t\tresult.push( attribute );\n\t}\n\n\treturn result;\n}\n","import bubble from './prototype/bubble';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport update from './prototype/update';\n\nvar Attribute = function ( options ) {\n\tthis.init( options );\n};\n\nAttribute.prototype = {\n\tbubble: bubble,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tupdate: update\n};\n\nexport default Attribute;\n","import { namespaces } from 'config/environment';\nimport noop from 'utils/noop';\n\nimport updateSelectValue from './update/updateSelectValue';\nimport updateMultipleSelectValue from './update/updateMultipleSelectValue';\nimport updateRadioName from './update/updateRadioName';\nimport updateRadioValue from './update/updateRadioValue';\nimport updateCheckboxName from './update/updateCheckboxName';\nimport updateClassName from './update/updateClassName';\nimport updateIdAttribute from './update/updateIdAttribute';\nimport updateIEStyleAttribute from './update/updateIEStyleAttribute';\nimport updateContentEditableValue from './update/updateContentEditableValue';\nimport updateValue from './update/updateValue';\nimport updateBoolean from './update/updateBoolean';\nimport updateEverythingElse from './update/updateEverythingElse';\n\n// There are a few special cases when it comes to updating attributes. For this reason,\n// the prototype .update() method points to this method, which waits until the\n// attribute has finished initialising, then replaces the prototype method with a more\n// suitable one. That way, we save ourselves doing a bunch of tests on each call\nexport default function Attribute$update () {\n\tvar { name, element, node } = this, type, updateMethod;\n\n\tif ( name === 'id' ) {\n\t\tupdateMethod = updateIdAttribute;\n\t}\n\n\telse if ( name === 'value' ) {\n\t\t// special case - selects\n\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\tupdateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t}\n\n\t\telse if ( element.name === 'textarea' ) {\n\t\t\tupdateMethod = updateValue;\n\t\t}\n\n\t\t// special case - contenteditable\n\t\telse if ( element.getAttribute( 'contenteditable' ) != null ) {\n\t\t\tupdateMethod = updateContentEditableValue;\n\t\t}\n\n\t\t// special case - <input>\n\t\telse if ( element.name === 'input' ) {\n\t\t\ttype = element.getAttribute( 'type' );\n\n\t\t\t// type='file' value='{{fileList}}'>\n\t\t\tif ( type === 'file' ) {\n\t\t\t\tupdateMethod = noop; // read-only\n\t\t\t}\n\n\t\t\t// type='radio' name='{{twoway}}'\n\t\t\telse if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {\n\t\t\t\tupdateMethod = updateRadioValue;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tupdateMethod = updateValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n\telse if ( this.isTwoway && name === 'name' ) {\n\t\tif ( node.type === 'radio' ) {\n\t\t\tupdateMethod = updateRadioName;\n\t\t}\n\n\t\telse if ( node.type === 'checkbox' ) {\n\t\t\tupdateMethod = updateCheckboxName;\n\t\t}\n\t}\n\n\t// special case - style attributes in Internet Exploder\n\telse if ( name === 'style' && node.style.setAttribute ) {\n\t\tupdateMethod = updateIEStyleAttribute;\n\t}\n\n\t// special case - class names. IE fucks things up, again\n\telse if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {\n\t\tupdateMethod = updateClassName;\n\t}\n\n\telse if ( this.useProperty ) {\n\t\tupdateMethod = updateBoolean;\n\t}\n\n\tif ( !updateMethod ) {\n\t\tupdateMethod = updateEverythingElse;\n\t}\n\n\tthis.update = updateMethod;\n\tthis.update();\n}\n","export default function Attribute$updateEverythingElse () {\n\tvar { node, namespace, name, value, fragment } = this;\n\n\tif ( namespace ) {\n\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t}\n\n\telse if ( !this.isBoolean ) {\n\t\tif ( value == null ) {\n\t\t\tnode.removeAttribute( name );\n\t\t} else {\n\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t}\n\t}\n\n\t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n\telse {\n\t\tif ( value ) {\n\t\t\tnode.setAttribute( name, '' );\n\t\t} else {\n\t\t\tnode.removeAttribute( name );\n\t\t}\n\t}\n}\n","export default function Attribute$updateBooleanAttribute () {\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tthis.node[ this.propertyName ] = this.value;\n\t}\n}\n","export default function Attribute$updateValue () {\n\tvar { node, value } = this;\n\n\t// store actual value, so it doesn't get coerced to a string\n\tnode._ractive.value = value;\n\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tnode.value = ( value == undefined ? '' : value );\n\t}\n}\n","export default function Attribute$updateContentEditableValue () {\n\tvar value = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tif ( !this.locked ) {\n\t\tthis.node.innerHTML = value;\n\t}\n}\n","export default function Attribute$updateIEStyleAttribute () {\n\tvar node, value;\n\n\tnode = this.node;\n\tvalue = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tnode.style.setAttribute( 'cssText', value );\n}\n","export default function Attribute$updateIdAttribute () {\n\tvar { node, value } = this;\n\n\tthis.root.nodes[ value ] = node;\n\tnode.id = value;\n}\n","import { safeToStringValue } from 'utils/dom';\nexport default function Attribute$updateClassName () {\n\tthis.node.className = safeToStringValue( this.value );\n}\n","import { isArray } from 'utils/is';\n\nexport default function Attribute$updateCheckboxName () {\n\tvar { element, node, value } = this, { binding } = element, valueAttribute, i;\n\n\tvalueAttribute = element.getAttribute( 'value' );\n\n\tif ( !isArray( value ) ) {\n\t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n\t} else {\n\t\ti = value.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( valueAttribute == value[i] ) {\n\t\t\t\tbinding.isChecked = node.checked = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbinding.isChecked = node.checked = false;\n\t}\n}\n","import runloop from 'global/runloop';\n\nexport default function Attribute$updateRadioValue () {\n\tvar wasChecked, node = this.node, binding, bindings, i;\n\n\twasChecked = node.checked;\n\n\tnode.value = this.element.getAttribute( 'value' );\n\tnode.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );\n\n\t// This is a special case - if the input was checked, and the value\n\t// changed so that it's no longer checked, the twoway binding is\n\t// most likely out of date. To fix it we have to jump through some\n\t// hoops... this is a little kludgy but it works\n\tif ( wasChecked && !node.checked && this.element.binding ) {\n\t\tbindings = this.element.binding.siblings;\n\n\t\tif ( i = bindings.length ) {\n\t\t\twhile ( i-- ) {\n\t\t\t\tbinding = bindings[i];\n\n\t\t\t\tif ( !binding.element.node ) {\n\t\t\t\t\t// this is the initial render, siblings are still rendering!\n\t\t\t\t\t// we'll come back later...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( binding.element.node.checked ) {\n\t\t\t\t\trunloop.addRactive( binding.root );\n\t\t\t\t\treturn binding.handleChange();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.root.viewmodel.set( binding.keypath, undefined );\n\t\t}\n\t}\n}\n","export default function Attribute$updateRadioName () {\n\tvar { node, value } = this;\n\tnode.checked = ( value == node._ractive.value );\n}\n","import { arrayContains } from 'utils/array';\nimport { isArray } from 'utils/is';\n\nexport default function Attribute$updateMultipleSelect () {\n\tvar value = this.value, options, i, option, optionValue;\n\n\tif ( !isArray( value ) ) {\n\t\tvalue = [ value ];\n\t}\n\n\toptions = this.node.options;\n\ti = options.length;\n\n\twhile ( i-- ) {\n\t\toption = options[i];\n\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\t\toption.selected = arrayContains( value, optionValue );\n\t}\n}\n","export default function Attribute$updateSelect () {\n\tvar value = this.value, options, option, optionValue, i;\n\n\tif ( !this.locked ) {\n\t\tthis.node._ractive.value = value;\n\n\t\toptions = this.node.options;\n\t\ti = options.length;\n\n\t\twhile ( i-- ) {\n\t\t\toption = options[i];\n\t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\toption.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we're still here, it means the new value didn't match any of the options...\n\t// TODO figure out what to do in this situation\n}\n","export default function Attribute$unbind () {\n\t// ignore non-dynamic attributes\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.name === 'id' ) {\n\t\tdelete this.root.nodes[ this.value ];\n\t}\n}\n","export default function Attribute$toString () {\n\tvar { name, namespacePrefix, value, interpolator, fragment } = this;\n\n\t// Special case - select and textarea values (should not be stringified)\n\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\treturn;\n\t}\n\n\t// Special case - content editable\n\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\treturn;\n\t}\n\n\t// Special case - radio names\n\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\treturn 'name={{' + ( interpolator.keypath.str || interpolator.ref ) + '}}';\n\t}\n\n\t// Boolean attributes\n\tif ( this.isBoolean ) {\n\t\treturn value ? name : '';\n\t}\n\n\tif ( fragment ) {\n\t\t// special case - this catches undefined/null values (#1211)\n\t\tif ( fragment.items.length === 1 && fragment.items[0].value == null ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvalue = fragment.toString();\n\t}\n\n\tif ( namespacePrefix ) {\n\t\tname = namespacePrefix + ':' + name;\n\t}\n\n\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n}\n\nfunction escape ( value ) {\n\treturn value\n\t\t.replace( /&/g, '&amp;' )\n\t\t.replace( /\"/g, '&quot;' )\n\t\t.replace( /'/g, '&#39;' );\n}\n","import { namespaces } from 'config/environment';\n\n// the property name equivalents for element attributes, where they differ\n// from the lowercased attribute name\nvar propertyNames = {\n\t'accept-charset': 'acceptCharset',\n\t'accesskey': 'accessKey',\n\t'bgcolor': 'bgColor',\n\t'class': 'className',\n\t'codebase': 'codeBase',\n\t'colspan': 'colSpan',\n\t'contenteditable': 'contentEditable',\n\t'datetime': 'dateTime',\n\t'dirname': 'dirName',\n\t'for': 'htmlFor',\n\t'http-equiv': 'httpEquiv',\n\t'ismap': 'isMap',\n\t'maxlength': 'maxLength',\n\t'novalidate': 'noValidate',\n\t'pubdate': 'pubDate',\n\t'readonly': 'readOnly',\n\t'rowspan': 'rowSpan',\n\t'tabindex': 'tabIndex',\n\t'usemap': 'useMap'\n};\n\nexport default function Attribute$render ( node ) {\n\tvar propertyName;\n\n\tthis.node = node;\n\n\t// should we use direct property access, or setAttribute?\n\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\n\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\tthis.propertyName = propertyName;\n\t\t}\n\n\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\tif ( this.isBoolean || this.isTwoway ) {\n\t\t\tthis.useProperty = true;\n\t\t}\n\n\t\tif ( propertyName === 'value' ) {\n\t\t\tnode._ractive.value = this.value;\n\t\t}\n\t}\n\n\tthis.rendered = true;\n\tthis.update();\n}\n","export default function Attribute$rebind ( oldKeypath, newKeypath ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { ATTRIBUTE } from 'config/types';\nimport { booleanAttributes } from 'utils/html';\nimport determineNameAndNamespace from '../helpers/determineNameAndNamespace';\nimport getInterpolator from '../helpers/getInterpolator';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Attribute$init ( options ) {\n\tthis.type = ATTRIBUTE;\n\tthis.element = options.element;\n\tthis.root = options.root;\n\n\tdetermineNameAndNamespace( this, options.name );\n\tthis.isBoolean = booleanAttributes.test( this.name );\n\n\t// if it's an empty attribute, or just a straight key-value pair, with no\n\t// mustache shenanigans, set the attribute accordingly and go home\n\tif ( !options.value || typeof options.value === 'string' ) {\n\t\tthis.value = this.isBoolean ? true : options.value || '';\n\t\treturn;\n\t}\n\n\t// otherwise we need to do some work\n\n\t// share parentFragment with parent element\n\tthis.parentFragment = this.element.parentFragment;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: options.value,\n\t\troot:     this.root,\n\t\towner:    this\n\t});\n\n\t// TODO can we use this.fragment.toString() in some cases? It's quicker\n\tthis.value = this.fragment.getValue();\n\n\t// Store a reference to this attribute's interpolator, if its fragment\n\t// takes the form `{{foo}}`. This is necessary for two-way binding and\n\t// for correctly rendering HTML later\n\tthis.interpolator = getInterpolator( this );\n\tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n\t// mark as ready\n\tthis.ready = true;\n}\n","import { INTERPOLATOR } from 'config/types';\n\nexport default function getInterpolator ( attribute ) {\n\tvar items = attribute.fragment.items;\n\n\tif ( items.length !== 1 ) {\n\t\treturn;\n\t}\n\n\tif ( items[0].type === INTERPOLATOR ) {\n\t\treturn items[0];\n\t}\n}\n","import { namespaces } from 'config/environment';\nimport enforceCase from 'virtualdom/items/Element/shared/enforceCase';\n\nexport default function ( attribute, name ) {\n\tvar colonIndex, namespacePrefix;\n\n\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\tcolonIndex = name.indexOf( ':' );\n\tif ( colonIndex !== -1 ) {\n\n\t\t// looks like we are, yes...\n\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\n\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t// that only valid namespaces will be used)\n\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\tname = name.substring( colonIndex + 1 );\n\n\t\t\tattribute.name = enforceCase( name );\n\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\tattribute.namespacePrefix = namespacePrefix;\n\n\t\t\tif ( !attribute.namespace ) {\n\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// SVG attribute names are case sensitive\n\tattribute.name = ( attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name );\n}\n","var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\nsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\nsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\ncreateMap = function ( items ) {\n\tvar map = {}, i = items.length;\n\twhile ( i-- ) {\n\t\tmap[ items[i].toLowerCase() ] = items[i];\n\t}\n\treturn map;\n};\n\nmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\nexport default function ( elementName ) {\n\tvar lowerCaseElementName = elementName.toLowerCase();\n\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n}\n","import runloop from 'global/runloop';\nimport { isEqual } from 'utils/is';\n\nexport default function Attribute$bubble () {\n\tvar value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n\t// TODO this can register the attribute multiple times (see render test\n\t// 'Attribute with nested mustaches')\n\tif ( !isEqual( value, this.value ) ) {\n\n\t\t// Need to clear old id from ractive.nodes\n\t\tif ( this.name === 'id' && this.value ) {\n\t\t\tdelete this.root.nodes[ this.value ];\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tif ( this.name === 'value' && this.node ) {\n\t\t\t// We need to store the value on the DOM like this so we\n\t\t\t// can retrieve it later without it being coerced to a string\n\t\t\tthis.node._ractive.value = value;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n}\n","var truthy = /^true|on|yes|1$/i;\nvar isNumeric = /^[0-9]+$/;\n\nexport default function( element, template ) {\n\tvar val, attrs, attributes;\n\n\tattributes = template.a || {};\n\tattrs = {};\n\n\t// attributes that are present but don't have a value (=)\n\t// will be set to the number 0, which we condider to be true\n\t// the string '0', however is false\n\n\tval = attributes.twoway;\n\tif ( val !== undefined ) {\n\t\tattrs.twoway = val === 0 || truthy.test( val );\n\t}\n\n\tval = attributes.lazy;\n\tif ( val !== undefined ) {\n\t\t// check for timeout value\n\t\tif ( val !== 0 && isNumeric.test( val ) ) {\n\t\t\tattrs.lazy = parseInt( val );\n\t\t} else {\n\t\t\tattrs.lazy = val === 0 || truthy.test( val );\n\t\t}\n\t}\n\n\treturn attrs;\n}\n","export default function Element$getAttribute ( name ) {\n\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\treturn;\n\t}\n\n\treturn this.attributes[ name ].value;\n}\n","export default function Element$firstNode () {\n\treturn this.node;\n}\n","export default function Element$findNextNode () {\n\treturn null;\n}\n","export default function ( selector ) {\n\tif ( this.fragment ) {\n\t\treturn this.fragment.findComponent( selector );\n\t}\n}\n","export default function ( selector, query ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function ( selector, query ) {\n\t// Add this node to the query, if applicable, and register the\n\t// query on this element\n\tif ( query._test( this, true ) && query.live ) {\n\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t}\n\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAll( selector, query );\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function ( selector ) {\n\tif ( !this.node ) {\n\t\t// this element hasn't been rendered yet\n\t\treturn null;\n\t}\n\n\tif ( matches( this.node, selector ) ) {\n\t\treturn this.node;\n\t}\n\n\tif ( this.fragment && this.fragment.find ) {\n\t\treturn this.fragment.find( selector );\n\t}\n}\n","export default function Element$detach () {\n\tvar node = this.node, parentNode;\n\n\tif ( node ) {\n\t\t// need to check for parent node - DOM may have been altered\n\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\tif ( parentNode = node.parentNode ) {\n\t\t\tparentNode.removeChild( node );\n\t\t}\n\n\t\treturn node;\n\t}\n}\n","export default function () {\n\tthis.parentFragment.bubble();\n}\n","import { TRIPLE } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport firstNode from './prototype/firstNode';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nimport unbind from '../shared/unbind';\n\nvar Triple = function ( options ) {\n\tthis.type = TRIPLE;\n\tMustache.init( this, options );\n};\n\nTriple.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfirstNode: firstNode,\n\tgetValue: Mustache.getValue,\n\trebind: Mustache.rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Triple;\n","import insertHtml from 'virtualdom/items/Triple/helpers/insertHtml';\nimport updateSelect from 'virtualdom/items/Triple/helpers/updateSelect';\n\nexport default function Triple$update () {\n\tvar node, parentNode;\n\n\tif ( !this.rendered ) {\n\t\treturn;\n\t}\n\n\t// Remove existing nodes\n\twhile ( this.nodes && this.nodes.length ) {\n\t\tnode = this.nodes.pop();\n\t\tnode.parentNode.removeChild( node );\n\t}\n\n\t// Insert new nodes\n\tparentNode = this.parentFragment.getNode();\n\n\tthis.nodes = insertHtml( this.value, parentNode, this.docFrag );\n\tparentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\n\n\t// Special case - we're inserting the contents of a <select>\n\tupdateSelect( this.pElement );\n}\n","import { detachNode } from 'utils/dom';\n\nexport default function Triple$unrender ( shouldDestroy ) {\n\tif ( this.rendered && shouldDestroy ) {\n\t\tthis.nodes.forEach( detachNode );\n\t\tthis.rendered = false;\n\t}\n\n\t// TODO update live queries\n}\n","import { decodeCharacterReferences } from 'utils/html';\n\nexport default function Triple$toString () {\n\treturn ( this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '' );\n}\n","import runloop from 'global/runloop';\n\nexport default function Triple$setValue ( value ) {\n\tvar wrapper;\n\n\t// TODO is there a better way to approach this?\n\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) {\n\t\tvalue = wrapper.get();\n\t}\n\n\tif ( value !== this.value ) {\n\t\tthis.value = value;\n\t\tthis.parentFragment.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n}\n","import insertHtml from 'virtualdom/items/Triple/helpers/insertHtml';\nimport updateSelect from 'virtualdom/items/Triple/helpers/updateSelect';\n\nexport default function Triple$render () {\n\tif ( this.rendered ) {\n\t\tthrow new Error( 'Attempted to render an item that was already rendered' );\n\t}\n\n\tthis.docFrag = document.createDocumentFragment();\n\tthis.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );\n\n\t// Special case - we're inserting the contents of a <select>\n\tupdateSelect( this.pElement );\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","import { toArray } from 'utils/array';\n\nexport default function updateSelect ( parentElement ) {\n\tvar selectedOptions, option, value;\n\n\tif ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {\n\t\treturn;\n\t}\n\n\tselectedOptions = toArray( parentElement.node.options ).filter( isSelected );\n\n\t// If one of them had a `selected` attribute, we need to sync\n\t// the model to the view\n\tif ( parentElement.getAttribute( 'multiple' ) ) {\n\t\tvalue = selectedOptions.map( o => o.value );\n\t} else if ( option = selectedOptions[0] ) {\n\t\tvalue = option.value;\n\t}\n\n\tif ( value !== undefined ) {\n\t\tparentElement.binding.setValue( value );\n\t}\n\n\tparentElement.bubble();\n}\n\nfunction isSelected ( option ) {\n\treturn option.selected;\n}\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\n\nvar elementCache = {}, ieBug, ieBlacklist;\n\ntry {\n\tcreateElement( 'table' ).innerHTML = 'foo';\n} catch ( err ) {\n\tieBug = true;\n\n\tieBlacklist = {\n\t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t};\n}\n\nexport default function ( html, node, docFrag ) {\n\tvar container, nodes = [], wrapper, selectedOption, child, i;\n\n\t// render 0 and false\n\tif ( html != null && html !== '' ) {\n\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t\t\tcontainer = container.querySelector( '.x' );\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\telse if ( node.namespaceURI === namespaces.svg ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\tcontainer = container.querySelector( '.x' );\n\t\t}\n\n\t\telse {\n\t\t\tcontainer = element( node.tagName );\n\t\t\tcontainer.innerHTML = html;\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\twhile ( child = container.firstChild ) {\n\t\t\tnodes.push( child );\n\t\t\tdocFrag.appendChild( child );\n\t\t}\n\n\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t// temporary container <select> causes the remaining ones to\n\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t// amaze me. You really do\n\t\t// ...and now Chrome too\n\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\ti = nodes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( nodes[i] !== selectedOption ) {\n\t\t\t\t\tnodes[i].selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes;\n}\n\nfunction element ( tagName ) {\n\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n}\n","export default function Triple$firstNode () {\n\tif ( this.rendered && this.nodes[0] ) {\n\t\treturn this.nodes[0];\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","import { matches } from 'utils/dom';\n\nexport default function Triple$findAll ( selector, queryResult ) {\n\tvar i, len, node, queryAllResult, numNodes, j;\n\n\tlen = this.nodes.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tnode = this.nodes[i];\n\n\t\tif ( node.nodeType !== 1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( matches( node, selector ) ) {\n\t\t\tqueryResult.push( node );\n\t\t}\n\n\t\tif ( queryAllResult = node.querySelectorAll( selector ) ) {\n\t\t\tnumNodes = queryAllResult.length;\n\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\tqueryResult.push( queryAllResult[j] );\n\t\t\t}\n\t\t}\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function Triple$find ( selector ) {\n\tvar i, len, node, queryResult;\n\n\tlen = this.nodes.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tnode = this.nodes[i];\n\n\t\tif ( node.nodeType !== 1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( matches( node, selector ) ) {\n\t\t\treturn node;\n\t\t}\n\n\t\tif ( queryResult = node.querySelector( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Triple$detach () {\n\tvar len, i;\n\n\tif ( this.docFrag ) {\n\t\tlen = this.nodes.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.docFrag.appendChild( this.nodes[i] );\n\t\t}\n\n\t\treturn this.docFrag;\n\t}\n}\n","import { SECTION, SECTION_UNLESS } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport shuffle from './prototype/shuffle';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nvar Section = function ( options ) {\n\tthis.type = SECTION;\n\tthis.subtype = this.currentSubtype = options.template.n;\n\tthis.inverted = this.subtype === SECTION_UNLESS;\n\n\n\tthis.pElement = options.pElement;\n\n\tthis.fragments = [];\n\tthis.fragmentsToCreate = [];\n\tthis.fragmentsToRender = [];\n\tthis.fragmentsToUnrender = [];\n\n\tif ( options.template.i ) {\n\t\tthis.indexRefs = options.template.i.split(',').map( ( k, i ) => {\n\t\t\treturn { n: k, t: i === 0 ? 'k' : 'i' };\n\t\t});\n\t}\n\n\tthis.renderedFragments = [];\n\n\tthis.length = 0; // number of times this section is rendered\n\n\tMustache.init( this, options );\n};\n\nSection.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetIndexRef: function( name ) {\n\t\tif ( this.indexRefs ) {\n\t\t\tlet i = this.indexRefs.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tlet ref = this.indexRefs[i];\n\t\t\t\tif ( ref.n === name ) {\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetValue: Mustache.getValue,\n\tshuffle: shuffle,\n\trebind: rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Section;\n","export default function Section$update () {\n\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n\t// `this.renderedFragments` is in the order of the previous render.\n\t// If fragments have shuffled about, this allows us to quickly\n\t// reinsert them in the correct place\n\trenderedFragments = this.renderedFragments;\n\n\t// Remove fragments that have been marked for destruction\n\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\tfragment.unrender( true );\n\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t}\n\n\t// Render new fragments (but don't insert them yet)\n\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\tfragment.render();\n\t}\n\n\tif ( this.rendered ) {\n\t\ttarget = this.parentFragment.getNode();\n\t}\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tfragment = this.fragments[i];\n\t\trenderIndex = renderedFragments.indexOf( fragment, i ); // search from current index - it's guaranteed to be the same or higher\n\n\t\tif ( renderIndex === i ) {\n\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis.docFrag.appendChild( fragment.detach() );\n\n\t\t// update renderedFragments\n\t\tif ( renderIndex !== -1 ) {\n\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t}\n\t\trenderedFragments.splice( i, 0, fragment );\n\t}\n\n\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\tanchor = this.parentFragment.findNextNode( this );\n\t\ttarget.insertBefore( this.docFrag, anchor );\n\t}\n\n\t// Save the rendering order for next time\n\tthis.renderedFragments = this.fragments.slice();\n}\n","export default function Section$unrender ( shouldDestroy ) {\n\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\tthis.renderedFragments = [];\n\tthis.rendered = false;\n}\n\nfunction unrenderAndDestroy ( fragment ) {\n\tfragment.unrender( true );\n}\n\nfunction unrender ( fragment ) {\n\tfragment.unrender( false );\n}\n","import { removeFromArray } from 'utils/array';\nimport { unbind as unbindFragment } from 'shared/methodCallers';\nimport unbind from '../../shared/unbind';\n\nexport default function Section$unbind () {\n\tthis.fragments.forEach( unbindFragment );\n\tthis.fragmentsToRender.forEach( f => removeFromArray( this.fragments, f ) );\n\tthis.fragmentsToRender = [];\n\tunbind.call( this );\n\n\tthis.length = 0;\n\tthis.unbound = true;\n}\n","export default function Section$toString ( escape ) {\n\tvar str, i, len;\n\n\tstr = '';\n\n\ti = 0;\n\tlen = this.length;\n\n\tfor ( i=0; i<len; i+=1 ) {\n\t\tstr += this.fragments[i].toString( escape );\n\t}\n\n\treturn str;\n}\n","import { SECTION_EACH, SECTION_IF, SECTION_UNLESS, SECTION_WITH, SECTION_IF_WITH } from 'config/types';\nimport { isArrayLike, isObject } from 'utils/is';\nimport { unbind } from 'shared/methodCallers';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Section$setValue ( value ) {\n\tvar wrapper, fragmentOptions;\n\n\tif ( this.updating ) {\n\t\t// If a child of this section causes a re-evaluation - for example, an\n\t\t// expression refers to a function that mutates the array that this\n\t\t// section depends on - we'll end up with a double rendering bug (see\n\t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n\t\treturn;\n\t}\n\n\tthis.updating = true;\n\n\t// with sections, we need to get the fake value if we have a wrapped object\n\tif ( this.keypath && ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) ) {\n\t\tvalue = wrapper.get();\n\t}\n\n\t// If any fragments are awaiting creation after a splice,\n\t// this is the place to do it\n\tif ( this.fragmentsToCreate.length ) {\n\t\tfragmentOptions = {\n\t\t\ttemplate: this.template.f || [],\n\t\t\troot:     this.root,\n\t\t\tpElement: this.pElement,\n\t\t\towner:    this\n\t\t};\n\n\t\tthis.fragmentsToCreate.forEach( index => {\n\t\t\tvar fragment;\n\n\t\t\tfragmentOptions.context = this.keypath.join( index );\n\t\t\tfragmentOptions.index = index;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\tthis.fragmentsToRender.push( this.fragments[ index ] = fragment );\n\t\t});\n\n\t\tthis.fragmentsToCreate.length = 0;\n\t}\n\n\telse if ( reevaluateSection( this, value ) ) {\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n\n\tthis.value = value;\n\tthis.updating = false;\n}\n\nfunction changeCurrentSubtype ( section, value, obj ) {\n\tif ( value === SECTION_EACH ) {\n\t\t// make sure ref type is up to date for key or value indices\n\t\tif ( section.indexRefs && section.indexRefs[0] ) {\n\t\t\tlet ref = section.indexRefs[0];\n\n\t\t\t// when switching flavors, make sure the section gets updated\n\t\t\tif ( ( obj && ref.t === 'i' ) || ( !obj && ref.t === 'k' ) ) {\n\t\t\t\t// if switching from object to list, unbind all of the old fragments\n\t\t\t\tif ( !obj ) {\n\t\t\t\t\tsection.length = 0;\n\t\t\t\t  section.fragmentsToUnrender = section.fragments.slice( 0 );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( f => f.unbind() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tref.t = obj ? 'k' : 'i';\n\t\t}\n\t}\n\n\tsection.currentSubtype = value;\n}\n\nfunction reevaluateSection ( section, value ) {\n\tvar fragmentOptions = {\n\t\ttemplate: section.template.f || [],\n\t\troot:     section.root,\n\t\tpElement: section.parentFragment.pElement,\n\t\towner:    section\n\t};\n\n\tsection.hasContext = true;\n\n\t// If we already know the section type, great\n\t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n\t// and avoid doing this each time?\n\tif ( section.subtype ) {\n\t\tswitch ( section.subtype ) {\n\t\t\tcase SECTION_IF:\n\t\t\tsection.hasContext = false;\n\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\n\t\t\tcase SECTION_UNLESS:\n\t\t\tsection.hasContext = false;\n\t\t\treturn reevaluateConditionalSection( section, value, true, fragmentOptions );\n\n\t\t\tcase SECTION_WITH:\n\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\n\t\t\tcase SECTION_IF_WITH:\n\t\t\treturn reevaluateConditionalContextSection( section, value, fragmentOptions );\n\n\t\t\tcase SECTION_EACH:\n\t\t\tif ( isObject( value ) ) {\n\t\t\t\tchangeCurrentSubtype( section, section.subtype, true );\n\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t}\n\n\t\t\t// Fallthrough - if it's a conditional or an array we need to continue\n\t\t}\n\t}\n\n\t// Otherwise we need to work out what sort of section we're dealing with\n\tsection.ordered = !!isArrayLike( value );\n\n\t// Ordered list section\n\tif ( section.ordered ) {\n\t\tchangeCurrentSubtype( section, SECTION_EACH, false );\n\t\treturn reevaluateListSection( section, value, fragmentOptions );\n\t}\n\n\t// Unordered list, or context\n\tif ( isObject( value ) || typeof value === 'function' ) {\n\t\t// Index reference indicates section should be treated as a list\n\t\tif ( section.template.i ) {\n\t\t\tchangeCurrentSubtype( section, SECTION_EACH, true );\n\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t}\n\n\t\t// Otherwise, object provides context for contents\n\t\tchangeCurrentSubtype( section, SECTION_WITH, false );\n\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t}\n\n\t// Conditional section\n\tchangeCurrentSubtype( section, SECTION_IF, false );\n\tsection.hasContext = false;\n\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n}\n\nfunction reevaluateListSection ( section, value, fragmentOptions ) {\n\tvar i, length, fragment;\n\n\tlength = value.length;\n\n\tif ( length === section.length ) {\n\t\t// Nothing to do\n\t\treturn false;\n\t}\n\n\t// if the array is shorter than it was previously, remove items\n\tif ( length < section.length ) {\n\t\tsection.fragmentsToUnrender = section.fragments.splice( length, section.length - length );\n\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t}\n\n\t// otherwise...\n\telse {\n\t\tif ( length > section.length ) {\n\t\t\t// add any new ones\n\t\t\tfor ( i = section.length; i < length; i += 1 ) {\n\t\t\t\t// append list item to context stack\n\t\t\t\tfragmentOptions.context = section.keypath.join( i );\n\t\t\t\tfragmentOptions.index = i;\n\n\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\tsection.fragmentsToRender.push( section.fragments[i] = fragment );\n\t\t\t}\n\t\t}\n\t}\n\n\tsection.length = length;\n\treturn true;\n}\n\nfunction reevaluateListObjectSection ( section, value, fragmentOptions ) {\n\tvar id, i, hasKey, fragment, changed, deps;\n\n\thasKey = section.hasKey || ( section.hasKey = {} );\n\n\t// remove any fragments that should no longer exist\n\ti = section.fragments.length;\n\twhile ( i-- ) {\n\t\tfragment = section.fragments[i];\n\n\t\tif ( !( fragment.key in value ) ) {\n\t\t\tchanged = true;\n\n\t\t\tfragment.unbind();\n\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\tsection.fragments.splice( i, 1 );\n\n\t\t\thasKey[ fragment.key ] = false;\n\t\t}\n\t}\n\n\t// notify any dependents about changed indices\n\ti = section.fragments.length;\n\twhile ( i-- ) {\n\t\tfragment = section.fragments[i];\n\n\t\tif ( fragment.index !== i ){\n\t\t\tfragment.index = i;\n\t\t\tif ( deps = fragment.registeredIndexRefs ) {\n\t\t\t\tdeps.forEach( blindRebind );\n\t\t\t}\n\t\t}\n\t}\n\n\t// add any that haven't been created yet\n\ti = section.fragments.length;\n\tfor ( id in value ) {\n\t\tif ( !hasKey[ id ] ) {\n\t\t\tchanged = true;\n\n\t\t\tfragmentOptions.context = section.keypath.join( id );\n\t\t\tfragmentOptions.key = id;\n\t\t\tfragmentOptions.index = i++;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\n\t\t\tsection.fragmentsToRender.push( fragment );\n\t\t\tsection.fragments.push( fragment );\n\t\t\thasKey[ id ] = true;\n\t\t}\n\t}\n\n\tsection.length = section.fragments.length;\n\treturn changed;\n}\n\nfunction reevaluateConditionalContextSection ( section, value, fragmentOptions ) {\n\tif ( value ) {\n\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t} else {\n\t\treturn removeSectionFragments( section );\n\t}\n}\n\nfunction reevaluateContextSection ( section, fragmentOptions ) {\n\tvar fragment;\n\n\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n\t// (if it is already rendered, then any children dependent on the context stack\n\t// will update themselves without any prompting)\n\tif ( !section.length ) {\n\t\t// append this section to the context stack\n\t\tfragmentOptions.context = section.keypath;\n\t\tfragmentOptions.index = 0;\n\n\t\tfragment = new Fragment( fragmentOptions );\n\n\t\tsection.fragmentsToRender.push( section.fragments[0] = fragment );\n\t\tsection.length = 1;\n\n\t\treturn true;\n\t}\n}\n\nfunction reevaluateConditionalSection ( section, value, inverted, fragmentOptions ) {\n\tvar doRender, emptyArray, emptyObject, fragment, name;\n\n\temptyArray = ( isArrayLike( value ) && value.length === 0 );\n\temptyObject = false;\n\tif( !isArrayLike( value ) && isObject( value ) ) {\n\t\temptyObject = true;\n\t\tfor( name in value ) {\n\t\t\temptyObject = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( inverted ) {\n\t\tdoRender = emptyArray || emptyObject || !value;\n\t} else {\n\t\tdoRender = value && !emptyArray && !emptyObject;\n\t}\n\n\tif ( doRender ) {\n\t\tif ( !section.length ) {\n\t\t\t// no change to context stack\n\t\t\tfragmentOptions.index = 0;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\tsection.fragmentsToRender.push( section.fragments[0] = fragment );\n\t\t\tsection.length = 1;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( section.length > 1 ) {\n\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 1 );\n\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\telse {\n\t\treturn removeSectionFragments( section );\n\t}\n}\n\nfunction removeSectionFragments ( section ) {\n\tif ( section.length ) {\n\t\tsection.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );\n\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\tsection.length = section.fragmentsToRender.length = 0;\n\t\treturn true;\n\t}\n}\n\nfunction isRendered ( fragment ) {\n\treturn fragment.rendered;\n}\n\nfunction blindRebind ( dep ) {\n\t// the keypath doesn't actually matter here as it won't have changed\n\tdep.rebind( '', '' );\n}\n","export default function Section$render () {\n\tthis.docFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( f => this.docFrag.appendChild( f.render() ) );\n\n\tthis.renderedFragments = this.fragments.slice();\n\tthis.fragmentsToRender = [];\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","import Mustache from '../../shared/Mustache/_Mustache';\n\nexport default function( oldKeypath, newKeypath ) {\n\tMustache.rebind.call( this, oldKeypath, newKeypath );\n}\n","import { SECTION_EACH } from 'config/types';\nimport runloop from 'global/runloop';\n\nexport default function Section$shuffle ( newIndices ) {\n\tvar parentFragment,\n\t\tfirstChange,\n\t\ti,\n\t\tnewLength,\n\t\treboundFragments,\n\t\tfragmentOptions,\n\t\tfragment;\n\n\t// short circuit any double-updates, and ensure that this isn't applied to\n\t// non-list sections\n\tif ( this.shuffling || this.unbound || ( this.currentSubtype !== SECTION_EACH ) ) {\n\t\treturn;\n\t}\n\n\tthis.shuffling = true;\n\trunloop.scheduleTask( () => this.shuffling = false );\n\n\tparentFragment = this.parentFragment;\n\n\treboundFragments = [];\n\n\t// TODO: need to update this\n\t// first, rebind existing fragments\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tvar fragment, by, oldKeypath, newKeypath, deps;\n\n\t\tif ( newIndex === oldIndex ) {\n\t\t\treboundFragments[ newIndex ] = this.fragments[ oldIndex ];\n\t\t\treturn;\n\t\t}\n\n\t\tfragment = this.fragments[ oldIndex ];\n\n\t\tif ( firstChange === undefined ) {\n\t\t\tfirstChange = oldIndex;\n\t\t}\n\n\t\t// does this fragment need to be torn down?\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.fragmentsToUnrender.push( fragment );\n\t\t\tfragment.unbind();\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, it needs to be rebound to a new index\n\t\tby = newIndex - oldIndex;\n\t\toldKeypath = this.keypath.join( oldIndex );\n\t\tnewKeypath = this.keypath.join( newIndex );\n\n\t\tfragment.index = newIndex;\n\n\t\t// notify any registered index refs directly\n\t\tif ( deps = fragment.registeredIndexRefs ) {\n\t\t\tdeps.forEach( blindRebind );\n\t\t}\n\n\t\tfragment.rebind( oldKeypath, newKeypath );\n\t\treboundFragments[ newIndex ] = fragment;\n\t});\n\n\tnewLength = this.root.viewmodel.get( this.keypath ).length;\n\n\t// If nothing changed with the existing fragments, then we start adding\n\t// new fragments at the end...\n\tif ( firstChange === undefined ) {\n\t\t// ...unless there are no new fragments to add\n\t\tif ( this.length === newLength ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfirstChange = thi