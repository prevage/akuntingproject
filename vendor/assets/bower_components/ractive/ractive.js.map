{"version":3,"file":"ractive.js","sources":["../src/Ractive.js","../src/Ractive/static/getNodeInfo.js","../src/extend/_extend.js","../src/extend/unwrapExtended.js","../src/utils/wrapMethod.js","../src/Ractive/prototype.js","../src/Ractive/prototype/updateModel.js","../src/Ractive/prototype/update.js","../src/Ractive/prototype/unshift.js","../src/Ractive/prototype/unrender.js","../src/Ractive/prototype/toHTML.js","../src/Ractive/prototype/toggle.js","../src/Ractive/prototype/teardown.js","../src/Ractive/prototype/subtract.js","../src/Ractive/prototype/splice.js","../src/Ractive/prototype/sort.js","../src/Ractive/prototype/shift.js","../src/Ractive/prototype/set.js","../src/Ractive/prototype/reverse.js","../src/Ractive/prototype/resetTemplate.js","../src/Ractive/prototype/resetPartial.js","../src/Ractive/prototype/reset.js","../src/virtualdom/Fragment.js","../src/virtualdom/Fragment/prototype/unrender.js","../src/virtualdom/Fragment/prototype/unbind.js","../src/virtualdom/Fragment/prototype/toString.js","../src/virtualdom/Fragment/prototype/render.js","../src/virtualdom/Fragment/prototype/rebind.js","../src/virtualdom/Fragment/prototype/init.js","../src/virtualdom/items/Doctype.js","../src/virtualdom/items/Yielder.js","../src/virtualdom/items/Comment.js","../src/virtualdom/items/Component/_Component.js","../src/virtualdom/items/Component/prototype/unrender.js","../src/virtualdom/items/Component/prototype/unbind.js","../src/virtualdom/items/Component/prototype/toString.js","../src/virtualdom/items/Component/prototype/render.js","../src/virtualdom/items/Component/prototype/rebind.js","../src/virtualdom/items/Component/prototype/init.js","../src/virtualdom/items/Component/initialise/updateLiveQueries.js","../src/virtualdom/items/Component/initialise/propagateEvents.js","../src/virtualdom/items/Component/initialise/createInstance.js","../src/virtualdom/items/Component/initialise/ComplexParameter.js","../src/Ractive/initialise.js","../src/Ractive/helpers/getComputationSignatures.js","../src/Ractive/prototype/shared/hooks/HookQueue.js","../src/viewmodel/Viewmodel.js","../src/viewmodel/prototype/unregister.js","../src/viewmodel/prototype/teardown.js","../src/viewmodel/prototype/smartUpdate.js","../src/viewmodel/prototype/set.js","../src/viewmodel/prototype/reset.js","../src/viewmodel/prototype/release.js","../src/viewmodel/prototype/register.js","../src/viewmodel/prototype/merge.js","../src/viewmodel/prototype/merge/mapOldToNewIndex.js","../src/viewmodel/prototype/mark.js","../src/viewmodel/prototype/map.js","../src/viewmodel/prototype/init.js","../src/viewmodel/prototype/get.js","../src/viewmodel/prototype/compute.js","../src/viewmodel/Computation/Computation.js","../src/viewmodel/Computation/UnresolvedDependency.js","../src/viewmodel/prototype/clearCache.js","../src/viewmodel/prototype/capture.js","../src/viewmodel/prototype/applyChanges.js","../src/viewmodel/prototype/applyChanges/notifyPatternObservers.js","../src/viewmodel/helpers/getUpstreamChanges.js","../src/viewmodel/prototype/adapt.js","../src/Ractive/static/adaptors/magicArray.js","../src/Ractive/static/adaptors/magic.js","../src/utils/createBranch.js","../src/Ractive/static/adaptors/array/index.js","../src/Ractive/static/adaptors/array/patch.js","../src/Ractive/static/adaptors/array/processWrapper.js","../src/virtualdom/items/Component/prototype/firstNode.js","../src/virtualdom/items/Component/prototype/findNextNode.js","../src/virtualdom/items/Component/prototype/findComponent.js","../src/virtualdom/items/Component/prototype/findAllComponents.js","../src/virtualdom/items/Component/prototype/findAll.js","../src/virtualdom/items/Component/prototype/find.js","../src/virtualdom/items/Component/prototype/detach.js","../src/virtualdom/items/Component/getComponent.js","../src/virtualdom/items/Partial/_Partial.js","../src/virtualdom/items/Partial/applyIndent.js","../src/virtualdom/items/Partial/getPartialTemplate.js","../src/virtualdom/items/Partial/deIndent.js","../src/virtualdom/items/Element/_Element.js","../src/virtualdom/items/Element/prototype/unrender.js","../src/virtualdom/items/Element/prototype/unbind.js","../src/virtualdom/items/Element/prototype/toString.js","../src/virtualdom/items/Element/prototype/render.js","../src/virtualdom/items/Element/Transition/_Transition.js","../src/virtualdom/items/Element/Transition/prototype/start.js","../src/virtualdom/items/Element/Transition/prototype/processParams.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js","../src/virtualdom/items/Element/Transition/helpers/hyphenate.js","../src/virtualdom/items/Element/Transition/helpers/unprefix.js","../src/shared/Ticker.js","../src/virtualdom/items/Element/Transition/prototype/setStyle.js","../src/virtualdom/items/Element/Transition/prototype/getStyle.js","../src/virtualdom/items/Element/Transition/helpers/prefix.js","../src/utils/camelCase.js","../src/virtualdom/items/Element/Transition/prototype/init.js","../src/virtualdom/items/Element/special/form.js","../src/virtualdom/items/Element/special/img.js","../src/virtualdom/items/Element/prototype/rebind.js","../src/virtualdom/items/Element/prototype/init.js","../src/virtualdom/items/Element/special/option.js","../src/virtualdom/items/Element/special/select.js","../src/virtualdom/items/Element/Decorator/_Decorator.js","../src/virtualdom/items/Element/prototype/init/createEventHandlers.js","../src/virtualdom/items/Element/EventHandler/_EventHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/unrender.js","../src/virtualdom/items/Element/EventHandler/prototype/unbind.js","../src/virtualdom/items/Element/EventHandler/prototype/resolve.js","../src/virtualdom/items/Element/EventHandler/prototype/render.js","../src/virtualdom/items/Element/EventHandler/prototype/rebind.js","../src/virtualdom/items/Element/EventHandler/prototype/listen.js","../src/virtualdom/items/Element/EventHandler/shared/genericHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/init.js","../src/virtualdom/items/Element/EventHandler/prototype/getAction.js","../src/virtualdom/items/Element/EventHandler/prototype/fire.js","../src/virtualdom/items/Element/EventHandler/prototype/bubble.js","../src/virtualdom/items/Element/prototype/init/createTwowayBinding.js","../src/virtualdom/items/Element/Binding/NumericBinding.js","../src/virtualdom/items/Element/Binding/FileListBinding.js","../src/virtualdom/items/Element/Binding/MultipleSelectBinding.js","../src/virtualdom/items/Element/Binding/SelectBinding.js","../src/virtualdom/items/Element/Binding/CheckboxBinding.js","../src/virtualdom/items/Element/Binding/CheckboxNameBinding.js","../src/virtualdom/items/Element/Binding/RadioNameBinding.js","../src/virtualdom/items/Element/Binding/RadioBinding.js","../src/virtualdom/items/Element/Binding/shared/getSiblings.js","../src/virtualdom/items/Element/Binding/ContentEditableBinding.js","../src/virtualdom/items/Element/Binding/GenericBinding.js","../src/virtualdom/items/Element/Binding/shared/handleDomEvent.js","../src/virtualdom/items/Element/Binding/Binding.js","../src/virtualdom/items/Element/prototype/init/createConditionalAttributes.js","../src/virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js","../src/virtualdom/items/Element/prototype/init/createAttributes.js","../src/virtualdom/items/Element/Attribute/_Attribute.js","../src/virtualdom/items/Element/Attribute/prototype/update.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateClassName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/unbind.js","../src/virtualdom/items/Element/Attribute/prototype/toString.js","../src/virtualdom/items/Element/Attribute/prototype/render.js","../src/virtualdom/items/Element/Attribute/prototype/rebind.js","../src/virtualdom/items/Element/Attribute/prototype/init.js","../src/virtualdom/items/Element/Attribute/helpers/getInterpolator.js","../src/virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js","../src/virtualdom/items/Element/shared/enforceCase.js","../src/virtualdom/items/Element/Attribute/prototype/bubble.js","../src/virtualdom/items/Element/prototype/init/processBindingAttributes.js","../src/virtualdom/items/Element/prototype/getAttribute.js","../src/virtualdom/items/Element/prototype/firstNode.js","../src/virtualdom/items/Element/prototype/findNextNode.js","../src/virtualdom/items/Element/prototype/findComponent.js","../src/virtualdom/items/Element/prototype/findAllComponents.js","../src/virtualdom/items/Element/prototype/findAll.js","../src/virtualdom/items/Element/prototype/find.js","../src/virtualdom/items/Element/prototype/detach.js","../src/virtualdom/items/Element/prototype/bubble.js","../src/virtualdom/items/Triple/_Triple.js","../src/virtualdom/items/Triple/prototype/update.js","../src/virtualdom/items/Triple/prototype/unrender.js","../src/virtualdom/items/Triple/prototype/toString.js","../src/virtualdom/items/Triple/prototype/setValue.js","../src/virtualdom/items/Triple/prototype/render.js","../src/virtualdom/items/Triple/helpers/updateSelect.js","../src/virtualdom/items/Triple/helpers/insertHtml.js","../src/virtualdom/items/Triple/prototype/firstNode.js","../src/virtualdom/items/Triple/prototype/findAll.js","../src/virtualdom/items/Triple/prototype/find.js","../src/virtualdom/items/Triple/prototype/detach.js","../src/virtualdom/items/Section/_Section.js","../src/virtualdom/items/Section/prototype/update.js","../src/virtualdom/items/Section/prototype/unrender.js","../src/virtualdom/items/Section/prototype/unbind.js","../src/virtualdom/items/Section/prototype/toString.js","../src/virtualdom/items/Section/prototype/setValue.js","../src/virtualdom/items/Section/prototype/render.js","../src/virtualdom/items/Section/prototype/rebind.js","../src/virtualdom/items/Section/prototype/shuffle.js","../src/virtualdom/items/Section/prototype/firstNode.js","../src/virtualdom/items/Section/prototype/findNextNode.js","../src/virtualdom/items/Section/prototype/findComponent.js","../src/virtualdom/items/Section/prototype/findAllComponents.js","../src/virtualdom/items/Section/prototype/findAll.js","../src/virtualdom/items/Section/prototype/find.js","../src/virtualdom/items/Section/prototype/detach.js","../src/virtualdom/items/Section/prototype/bubble.js","../src/virtualdom/items/Interpolator.js","../src/virtualdom/items/shared/Mustache/_Mustache.js","../src/virtualdom/items/shared/Mustache/rebind.js","../src/virtualdom/items/shared/Mustache/resolve.js","../src/virtualdom/items/shared/Mustache/initialise.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js","../src/virtualdom/items/shared/Resolvers/ExpressionResolver.js","../src/shared/getFunctionFromString.js","../src/virtualdom/items/shared/Resolvers/createReferenceResolver.js","../src/virtualdom/items/shared/Resolvers/findIndexRefs.js","../src/virtualdom/items/shared/Resolvers/IndexResolver.js","../src/virtualdom/items/shared/Resolvers/SpecialResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceResolver.js","../src/virtualdom/items/shared/Mustache/getValue.js","../src/virtualdom/items/shared/unbind.js","../src/virtualdom/items/Text.js","../src/virtualdom/items/shared/detach.js","../src/virtualdom/Fragment/prototype/getValue.js","../src/virtualdom/Fragment/prototype/getNode.js","../src/virtualdom/Fragment/prototype/getArgsList.js","../src/virtualdom/Fragment/prototype/shared/processItems.js","../src/virtualdom/Fragment/prototype/firstNode.js","../src/virtualdom/Fragment/prototype/findNextNode.js","../src/virtualdom/Fragment/prototype/findComponent.js","../src/virtualdom/Fragment/prototype/findAllComponents.js","../src/virtualdom/Fragment/prototype/findAll.js","../src/virtualdom/Fragment/prototype/find.js","../src/virtualdom/Fragment/prototype/detach.js","../src/virtualdom/Fragment/prototype/bubble.js","../src/Ractive/config/config.js","../src/Ractive/config/deprecate.js","../src/Ractive/config/wrapPrototypeMethod.js","../src/Ractive/config/registries.js","../src/Ractive/config/custom/template/template.js","../src/Ractive/config/custom/template/parser.js","../src/parse/_parse.js","../src/parse/converters/readTemplate.js","../src/parse/converters/readPartialDefinitionSection.js","../src/parse/converters/readPartialDefinitionComment.js","../src/utils/escapeRegExp.js","../src/parse/converters/readText.js","../src/parse/converters/readElement.js","../src/parse/converters/element/processDirective.js","../src/utils/parseJSON.js","../src/parse/converters/element/readAttribute.js","../src/parse/converters/utils/getLowestIndex.js","../src/parse/converters/element/readClosingTag.js","../src/parse/utils/cleanup.js","../src/parse/utils/trimWhitespace.js","../src/parse/utils/stripStandalones.js","../src/utils/html.js","../src/parse/converters/readHtmlComment.js","../src/parse/converters/mustache/readSection.js","../src/parse/converters/mustache/handlebarsBlockCodes.js","../src/parse/converters/mustache/section/readElseIf.js","../src/parse/converters/mustache/section/readElse.js","../src/parse/converters/mustache/section/readClosing.js","../src/parse/converters/mustache/readYielder.js","../src/parse/converters/mustache/readInterpolator.js","../src/parse/converters/readExpressionOrReference.js","../src/parse/converters/mustache/readMustacheComment.js","../src/parse/converters/mustache/readPartial.js","../src/parse/converters/mustache/readUnescaped.js","../src/parse/converters/mustache/readTriple.js","../src/parse/utils/refineExpression.js","../src/parse/utils/flattenExpression.js","../src/parse/converters/readExpression.js","../src/parse/converters/expressions/readConditional.js","../src/parse/converters/expressions/readLogicalOr.js","../src/parse/converters/expressions/readTypeof.js","../src/parse/converters/expressions/readMemberOrInvocation.js","../src/parse/converters/expressions/shared/readRefinement.js","../src/parse/converters/expressions/readPrimary.js","../src/parse/converters/expressions/primary/readBracketedExpression.js","../src/parse/converters/expressions/primary/readReference.js","../src/parse/converters/expressions/primary/readLiteral.js","../src/parse/converters/expressions/primary/literal/readArrayLiteral.js","../src/parse/converters/expressions/shared/readExpressionList.js","../src/parse/converters/expressions/primary/literal/readObjectLiteral.js","../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePairs.js","../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePair.js","../src/parse/converters/expressions/shared/readKey.js","../src/parse/converters/expressions/shared/patterns.js","../src/parse/converters/expressions/primary/literal/readStringLiteral.js","../src/parse/converters/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js","../src/parse/converters/expressions/primary/literal/readBooleanLiteral.js","../src/parse/converters/expressions/primary/literal/readNumberLiteral.js","../src/parse/converters/expressions/shared/errors.js","../src/parse/converters/readMustache.js","../src/parse/converters/expressions/primary/literal/readRegexpLiteral.js","../src/parse/converters/mustache/readDelimiterChange.js","../src/config/types.js","../src/parse/Parser.js","../src/Ractive/config/custom/data.js","../src/Ractive/config/custom/css/css.js","../src/Ractive/config/custom/css/transform.js","../src/Ractive/config/custom/adapt.js","../src/Ractive/prototype/render.js","../src/global/css.js","../src/Ractive/prototype/push.js","../src/Ractive/prototype/pop.js","../src/Ractive/prototype/shared/makeArrayMethod.js","../src/shared/getNewIndices.js","../src/Ractive/prototype/once.js","../src/Ractive/prototype/on.js","../src/Ractive/prototype/off.js","../src/Ractive/prototype/shared/notEmptyString.js","../src/Ractive/prototype/shared/trim.js","../src/Ractive/prototype/observeOnce.js","../src/Ractive/prototype/observe.js","../src/Ractive/prototype/observe/getObserverFacade.js","../src/Ractive/prototype/observe/PatternObserver.js","../src/Ractive/prototype/observe/getPattern.js","../src/Ractive/prototype/observe/Observer.js","../src/Ractive/prototype/merge.js","../src/Ractive/prototype/insert.js","../src/Ractive/prototype/get.js","../src/Ractive/prototype/fire.js","../src/Ractive/prototype/shared/fireEvent.js","../src/Ractive/prototype/shared/eventStack.js","../src/Ractive/prototype/findParent.js","../src/Ractive/prototype/findContainer.js","../src/Ractive/prototype/findComponent.js","../src/Ractive/prototype/findAllComponents.js","../src/Ractive/prototype/findAll.js","../src/Ractive/prototype/shared/makeQuery/_makeQuery.js","../src/Ractive/prototype/shared/makeQuery/remove.js","../src/Ractive/prototype/shared/makeQuery/dirty.js","../src/Ractive/prototype/shared/makeQuery/sort.js","../src/Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js","../src/Ractive/prototype/shared/makeQuery/sortByItemPosition.js","../src/Ractive/prototype/shared/makeQuery/cancel.js","../src/Ractive/prototype/shared/makeQuery/test.js","../src/Ractive/prototype/find.js","../src/Ractive/prototype/detach.js","../src/Ractive/prototype/animate.js","../src/Ractive/prototype/animate/Animation.js","../src/shared/animations.js","../src/global/runloop.js","../src/global/TransitionManager.js","../src/shared/methodCallers.js","../src/shared/resolveRef.js","../src/shared/getInnerContext.js","../src/utils/Promise.js","../src/utils/array.js","../src/Ractive/prototype/shared/hooks/Hook.js","../src/utils/getTime.js","../src/utils/requestAnimationFrame.js","../src/Ractive/prototype/add.js","../src/Ractive/prototype/shared/add.js","../src/shared/keypaths.js","../src/utils/getPotentialWildcardMatches.js","../src/Ractive/static/interpolators.js","../src/shared/interpolate.js","../src/shared/registry.js","../src/config/errors.js","../src/utils/log.js","../src/utils/noop.js","../src/utils/is.js","../src/utils/object.js","../src/legacy.js","../src/utils/dom.js","../src/config/environment.js","../src/Ractive/static/easing.js","../src/Ractive/config/defaults.js","../src/config/template.js"],"sourcesContent":["import defaults from 'Ractive/config/defaults';\nimport easing from 'Ractive/static/easing';\nimport interpolators from 'Ractive/static/interpolators';\nimport { magic, svg } from 'config/environment';\nimport { defineProperties, extend as extendObj } from 'utils/object';\nimport proto from 'Ractive/prototype';\nimport Promise from 'utils/Promise';\nimport extend from 'extend/_extend';\nimport parse from 'parse/_parse';\nimport getNodeInfo from 'Ractive/static/getNodeInfo';\nimport initialise from 'Ractive/initialise';\n\nvar Ractive, properties;\n\n// Main Ractive required object\nRactive = function ( options ) {\n\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\tinitialise( this, options );\n};\n\n\n// Ractive properties\nproperties = {\n\n\t// debug flag\n\tDEBUG:          { writable: true, value: true },\n\tDEBUG_PROMISES: { writable: true, value: true },\n\n\t// static methods:\n\textend:         { value: extend },\n\tgetNodeInfo:    { value: getNodeInfo },\n\tparse:          { value: parse },\n\n\t// Namespaced constructors\n\tPromise:        { value: Promise },\n\n\t// support\n\tsvg:            { value: svg },\n\tmagic:          { value: magic },\n\n\t// version\n\tVERSION:        { value: '<@version@>' },\n\n\t// Plugins\n\tadaptors:       { writable: true, value: {} },\n\tcomponents:     { writable: true, value: {} },\n\tdecorators:     { writable: true, value: {} },\n\teasing:         { writable: true, value: easing },\n\tevents:         { writable: true, value: {} },\n\tinterpolators:  { writable: true, value: interpolators },\n\tpartials:       { writable: true, value: {} },\n\ttransitions:    { writable: true, value: {} }\n};\n\n\n// Ractive properties\ndefineProperties( Ractive, properties );\n\nRactive.prototype = extendObj( proto, defaults );\n\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as defaults\nRactive.defaults = Ractive.prototype;\n\n// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n// older browsers, these are made available via a shim - here, we do a quick\n// pre-flight check to make sure that either a) we're not in a shit browser,\n// or b) we're using a Ractive-legacy.js build\nvar FUNCTION = 'function';\n\nif (\n\ttypeof Date.now !== FUNCTION                 ||\n\ttypeof String.prototype.trim !== FUNCTION    ||\n\ttypeof Object.keys !== FUNCTION              ||\n\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\ttypeof Array.prototype.map !== FUNCTION      ||\n\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t( typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION )\n) {\n\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n}\n\nexport default Ractive;\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function( node ) {\n\tvar info = {}, priv, indices;\n\n\tif ( !node || !( priv = node._ractive ) ) {\n\t\treturn info;\n\t}\n\n\tinfo.ractive = priv.root;\n\tinfo.keypath = priv.keypath.str;\n\tinfo.index = {};\n\n\t// find all index references and resolve them\n\tif ( indices = findIndexRefs( priv.proxy.parentFragment ) ) {\n\t\tinfo.index = findIndexRefs.resolve( indices );\n\t}\n\n\treturn info;\n}\n","import { create, defineProperties, extend as extendObj } from 'utils/object';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport initialise from 'Ractive/initialise';\nimport Ractive from 'Ractive';\nimport unwrapExtended from './unwrapExtended';\n\nexport default extend;\n\nfunction extend ( ...options ) {\n\tif( !options.length ) {\n\t\treturn extendOne( this );\n\t} else {\n\t\treturn options.reduce( extendOne, this );\n\t}\n}\n\nfunction extendOne ( Parent, options = {} ) {\n\tvar Child, proto;\n\n\t// if we're extending with another Ractive instance...\n\t//\n\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t//   var Spiderman = Human.extend( Spider );\n\t//\n\t// ...inherit prototype methods and default options as well\n\tif ( options.prototype instanceof Ractive ) {\n\t\toptions = unwrapExtended( options );\n\t}\n\n\tChild = function ( options ) {\n\t\tif ( !( this instanceof Child ) ) return new Child( options );\n\t\tinitialise( this, options );\n\t};\n\n\tproto = create( Parent.prototype );\n\tproto.constructor = Child;\n\n\t// Static properties\n\tdefineProperties( Child, {\n\t\t// alias prototype as defaults\n\t\tdefaults: { value: proto },\n\n\t\t// extendable\n\t\textend: { value: extend, writable: true, configurable: true },\n\n\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t_Parent: { value: Parent }\n\t});\n\n\t// extend configuration\n\tconfig.extend( Parent, proto, options );\n\n\tdataConfigurator.extend( Parent, proto, options );\n\n\tif ( options.computed ) {\n\t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t}\n\n\tChild.prototype = proto;\n\n\treturn Child;\n}\n","import wrap from 'utils/wrapMethod';\nimport registries from 'Ractive/config/registries';\nimport Ractive from 'Ractive';\n\nexport default function unwrap ( Child ) {\n\tlet options = {};\n\n\twhile ( Child ) {\n\t\taddRegistries( Child, options );\n\t\taddOtherOptions( Child, options );\n\n\t\tif ( Child._Parent !== Ractive ) {\n\t\t\tChild = Child._Parent;\n\t\t} else {\n\t\t\tChild = false;\n\t\t}\n\t}\n\n\treturn options;\n}\n\nfunction addRegistries ( Child, options ) {\n\tregistries.forEach( r => {\n\t\taddRegistry(\n\t\t\tr.useDefaults ? Child.prototype : Child,\n\t\t\toptions, r.name );\n\t});\n}\n\nfunction addRegistry ( target, options, name ) {\n\tvar registry, keys = Object.keys( target[ name ] );\n\n\tif ( !keys.length ) { return; }\n\n\tif ( !( registry = options[ name ] ) ) {\n\t\tregistry = options[ name ] = {};\n\t}\n\n\tkeys\n\t\t.filter( key => !( key in registry ) )\n\t\t.forEach( key => registry[ key ] = target[ name ][ key ] );\n}\n\nfunction addOtherOptions ( Child, options ) {\n\tObject.keys( Child.prototype ).forEach( key => {\n\t\tif ( key === 'computed' ) { return; }\n\n\t\tvar value = Child.prototype[ key ];\n\n\t\tif ( !( key in options ) ) {\n\t\t\toptions[ key ] = value._method ? value._method : value;\n\t\t}\n\n\t\t// is it a wrapped function?\n\t\telse if ( typeof options[ key ] === 'function'\n\t\t\t\t&& typeof value === 'function'\n\t\t\t\t&& options[ key ]._method ) {\n\n\t\t\tlet result, needsSuper = value._method;\n\n\t\t\tif ( needsSuper ) { value = value._method; }\n\n\t\t\t// rewrap bound directly to parent fn\n\t\t\tresult = wrap( options[ key ]._method, value );\n\n\t\t\tif ( needsSuper ) { result._method = result; }\n\n\t\t\toptions[ key ] = result;\n\t\t}\n\t});\n}","export default function ( method, superMethod, force ) {\n\n\tif ( force || needsSuper( method, superMethod ) )  {\n\n\t\treturn function () {\n\n\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n\t\t\tthis._super = superMethod;\n\n\t\t\tresult = method.apply( this, arguments );\n\n\t\t\tif ( hasSuper ) {\n\t\t\t\tthis._super = _super;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\telse {\n\t\treturn method;\n\t}\n}\n\nfunction needsSuper ( method, superMethod ) {\n\treturn typeof superMethod === 'function' && /_super/.test( method );\n}\n","import add from 'Ractive/prototype/add';\nimport animate from 'Ractive/prototype/animate';\nimport detach from 'Ractive/prototype/detach';\nimport find from 'Ractive/prototype/find';\nimport findAll from 'Ractive/prototype/findAll';\nimport findAllComponents from 'Ractive/prototype/findAllComponents';\nimport findComponent from 'Ractive/prototype/findComponent';\nimport findContainer from 'Ractive/prototype/findContainer';\nimport findParent from 'Ractive/prototype/findParent';\nimport fire from 'Ractive/prototype/fire';\nimport get from 'Ractive/prototype/get';\nimport insert from 'Ractive/prototype/insert';\nimport merge from 'Ractive/prototype/merge';\nimport observe from 'Ractive/prototype/observe';\nimport observeOnce from 'Ractive/prototype/observeOnce';\nimport off from 'Ractive/prototype/off';\nimport on from 'Ractive/prototype/on';\nimport once from 'Ractive/prototype/once';\nimport pop from 'Ractive/prototype/pop';\nimport push from 'Ractive/prototype/push';\nimport render from 'Ractive/prototype/render';\nimport reset from 'Ractive/prototype/reset';\nimport resetPartial from 'Ractive/prototype/resetPartial';\nimport resetTemplate from 'Ractive/prototype/resetTemplate';\nimport reverse from 'Ractive/prototype/reverse';\nimport set from 'Ractive/prototype/set';\nimport shift from 'Ractive/prototype/shift';\nimport sort from 'Ractive/prototype/sort';\nimport splice from 'Ractive/prototype/splice';\nimport subtract from 'Ractive/prototype/subtract';\nimport teardown from 'Ractive/prototype/teardown';\nimport toggle from 'Ractive/prototype/toggle';\nimport toHTML from 'Ractive/prototype/toHTML';\nimport unrender from 'Ractive/prototype/unrender';\nimport unshift from 'Ractive/prototype/unshift';\nimport update from 'Ractive/prototype/update';\nimport updateModel from 'Ractive/prototype/updateModel';\n\nexport default {\n\tadd: add,\n\tanimate: animate,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindContainer: findContainer,\n\tfindParent: findParent,\n\tfire: fire,\n\tget: get,\n\tinsert: insert,\n\tmerge: merge,\n\tobserve: observe,\n\tobserveOnce: observeOnce,\n\toff: off,\n\ton: on,\n\tonce: once,\n\tpop: pop,\n\tpush: push,\n\trender: render,\n\treset: reset,\n\tresetPartial: resetPartial,\n\tresetTemplate: resetTemplate,\n\treverse: reverse,\n\tset: set,\n\tshift: shift,\n\tsort: sort,\n\tsplice: splice,\n\tsubtract: subtract,\n\tteardown: teardown,\n\ttoggle: toggle,\n\ttoHTML: toHTML,\n\ttoHtml: toHTML,\n\tunrender: unrender,\n\tunshift: unshift,\n\tupdate: update,\n\tupdateModel: updateModel\n};\n","import { arrayContentsMatch } from 'utils/array';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\n\nexport default function Ractive$updateModel ( keypath, cascade ) {\n\tvar values, key, bindings;\n\n\tif ( typeof keypath === 'string' && !cascade ) {\n\t\tbindings = this._twowayBindings[ keypath ];\n\t} else {\n\t\tbindings = [];\n\n\t\tfor ( key in this._twowayBindings ) {\n\t\t\tif ( !keypath || getKeypath( key ).equalsOrStartsWith( keypath ) ) { // TODO is this right?\n\t\t\t\tbindings.push.apply( bindings, this._twowayBindings[ key ]);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalues = consolidate( this, bindings );\n\treturn this.set( values );\n}\n\nfunction consolidate ( ractive, bindings ) {\n\tvar values = {}, checkboxGroups = [];\n\n\tbindings.forEach( b => {\n\t\tvar oldValue, newValue;\n\n\t\t// special case - radio name bindings\n\t\tif ( b.radioName && !b.element.node.checked ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - checkbox name bindings come in groups, so\n\t\t// we want to get the value once at most\n\t\tif ( b.checkboxName ) {\n\t\t\tif ( !checkboxGroups[ b.keypath.str ] && !b.changed() ) {\n\t\t\t\tcheckboxGroups.push( b.keypath );\n\t\t\t\tcheckboxGroups[ b.keypath.str ] = b;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\toldValue = b.attribute.value;\n\t\tnewValue = b.getValue();\n\n\t\tif ( arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !isEqual( oldValue, newValue ) ) {\n\t\t\tvalues[ b.keypath.str ] = newValue;\n\t\t}\n\t});\n\n\t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n\tif ( checkboxGroups.length ) {\n\t\tcheckboxGroups.forEach( keypath => {\n\t\t\tvar binding, oldValue, newValue;\n\n\t\t\tbinding = checkboxGroups[ keypath.str ]; // one to represent the entire group\n\t\t\toldValue = binding.attribute.value;\n\t\t\tnewValue = binding.getValue();\n\n\t\t\tif ( !arrayContentsMatch( oldValue, newValue ) ) {\n\t\t\t\tvalues[ keypath.str ] = newValue;\n\t\t\t}\n\t\t});\n\t}\n\n\treturn values;\n}\n","import Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { getKeypath, rootKeypath } from 'shared/keypaths';\n\nvar updateHook = new Hook( 'update' );\n\nexport default function Ractive$update ( keypath ) {\n\tvar promise;\n\n\tkeypath = getKeypath( keypath ) || rootKeypath;\n\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.mark( keypath );\n\trunloop.end();\n\n\tupdateHook.fire( this, keypath );\n\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'unshift' );\n","import Hook from './shared/hooks/Hook';\nimport { warnIfDebug } from 'utils/log';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nvar unrenderHook = new Hook( 'unrender' );\n\nexport default function Ractive$unrender () {\n\tvar promise, shouldDestroy;\n\n\tif ( !this.fragment.rendered ) {\n\t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\treturn Promise.resolve();\n\t}\n\n\tpromise = runloop.start( this, true );\n\n\t// If this is a component, and the component isn't marked for destruction,\n\t// don't detach nodes from the DOM unnecessarily\n\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n\t// Cancel any animations in progress\n\twhile ( this._animations[0] ) {\n\t\tthis._animations[0].stop(); // it will remove itself from the index\n\t}\n\n\tthis.fragment.unrender( shouldDestroy );\n\n\tremoveFromArray( this.el.__ractive_instances__, this );\n\n\tunrenderHook.fire( this );\n\n\trunloop.end();\n\treturn promise;\n}\n","export default function Ractive$toHTML () {\n\treturn this.fragment.toString( true );\n}\n","import { badArguments } from 'config/errors';\nimport { getKeypath, getMatchingKeypaths, normalise } from 'shared/keypaths';\n\nexport default function Ractive$toggle ( keypath ) {\n\tif ( typeof keypath !== 'string' ) {\n\t\tthrow new TypeError( badArguments );\n\t}\n\n\tlet changes;\n\n\tif ( /\\*/.test( keypath ) ) {\n\t\tchanges = {};\n\n\t\tgetMatchingKeypaths( this, getKeypath( normalise( keypath ) ) ).forEach( keypath => {\n\t\t\tchanges[ keypath.str ] = !this.viewmodel.get( keypath );\n\t\t});\n\n\t\treturn this.set( changes );\n\t}\n\n\treturn this.set( keypath, !this.get( keypath ) );\n}\n","import Hook from './shared/hooks/Hook';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport { cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nexport default function Ractive$teardown () {\n\tvar promise;\n\n\tthis.fragment.unbind();\n\tthis.viewmodel.teardown();\n\n\tthis._observers.forEach( cancel );\n\n\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\n\tthis.shouldDestroy = true;\n\tpromise = ( this.fragment.rendered ? this.unrender() : Promise.resolve() );\n\n\tteardownHook.fire( this );\n\n\tthis._boundFunctions.forEach( deleteFunctionCopy );\n\n\treturn promise;\n}\n\nfunction deleteFunctionCopy ( bound ) {\n\tdelete bound.fn[ bound.prop ];\n}","import add from './shared/add';\n\nexport default function Ractive$subtract ( keypath, d ) {\n\treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'splice' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'sort' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'shift' );\n","import { isObject } from 'utils/is';\nimport { getMatchingKeypaths, getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\n\nexport default function Ractive$set ( keypath, value ) {\n\tvar map, promise;\n\n\tpromise = runloop.start( this, true );\n\n\t// Set multiple keypaths in one go\n\tif ( isObject( keypath ) ) {\n\t\tmap = keypath;\n\n\t\tfor ( keypath in map ) {\n\t\t\tif ( map.hasOwnProperty( keypath) ) {\n\t\t\t\tvalue = map[ keypath ];\n\t\t\t\tset( this, keypath, value );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set a single keypath\n\telse {\n\t\tset( this, keypath, value );\n\t}\n\n\trunloop.end();\n\n\treturn promise;\n}\n\nfunction set ( ractive, keypath, value ) {\n\tkeypath = getKeypath( normalise( keypath ) );\n\n\tif ( keypath.isPattern ) {\n\t\tgetMatchingKeypaths( ractive, keypath ).forEach( keypath => {\n\t\t\tractive.viewmodel.set( keypath, value );\n\t\t});\n\t} else {\n\t\tractive.viewmodel.set( keypath, value );\n\t}\n}","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'reverse' );\n","import { default as templateConfigurator } from 'Ractive/config/custom/template/template';\nimport Fragment from 'virtualdom/Fragment';\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nexport default function Ractive$resetTemplate ( template ) {\n\tvar transitionsEnabled, component;\n\n\ttemplateConfigurator.init( null, this, { template: template });\n\n\ttransitionsEnabled = this.transitionsEnabled;\n\tthis.transitionsEnabled = false;\n\n\t// Is this is a component, we need to set the `shouldDestroy`\n\t// flag, otherwise it will assume by default that a parent node\n\t// will be detached, and therefore it doesn't need to bother\n\t// detaching its own nodes\n\tif ( component = this.component ) {\n\t\tcomponent.shouldDestroy = true;\n\t}\n\n\tthis.unrender();\n\n\tif ( component ) {\n\t\tcomponent.shouldDestroy = false;\n\t}\n\n\t// remove existing fragment and create new one\n\tthis.fragment.unbind();\n\tthis.fragment = new Fragment({\n\t\ttemplate: this.template,\n\t\troot: this,\n\t\towner: this\n\t});\n\n\tthis.render( this.el, this.anchor );\n\n\tthis.transitionsEnabled = transitionsEnabled;\n}\n","import { isArray } from 'utils/is';\nimport runloop from 'global/runloop';\nimport { PARTIAL, COMPONENT, ELEMENT } from 'config/types';\n\nexport default function ( name, partial ) {\n\tvar promise, collection = [];\n\n\tfunction collect( source, dest, ractive ) {\n\t\t// if this is a component and it has its own partial, bail\n\t\tif ( ractive && ractive.partials[name] ) return;\n\n\t\tsource.forEach( item => {\n\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\tif ( item.type === PARTIAL && item.getPartialName() === name ) {\n\t\t\t\tdest.push( item );\n\t\t\t}\n\n\t\t\t// if it has a fragment, process its items\n\t\t\tif ( item.fragment ) {\n\t\t\t\tcollect( item.fragment.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it has fragments\n\t\t\tif ( isArray( item.fragments ) ) {\n\t\t\t\tcollect( item.fragments, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is itself a fragment, process its items\n\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\tcollect( item.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is a component, step in and process its items\n\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\tcollect( item.instance.fragment.items, dest, item.instance );\n\t\t\t}\n\n\t\t\t// if the item is an element, process its attributes too\n\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\tcollect( item.attributes, dest, ractive );\n\t\t\t\t}\n\n\t\t\t\tif ( isArray( item.conditionalAttributes ) ) {\n\t\t\t\t\tcollect( item.conditionalAttributes, dest, ractive );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tcollect( this.fragment.items, collection );\n\tthis.partials[name] = partial;\n\n\tpromise = runloop.start( this, true );\n\n\tcollection.forEach( item => {\n\t\titem.value = undefined;\n\t\titem.setValue( name );\n\t});\n\n\trunloop.end();\n\n\treturn promise;\n}\n","import config from 'Ractive/config/config';\nimport Fragment from 'virtualdom/Fragment';\nimport Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { rootKeypath } from 'shared/keypaths';\n\nvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ],\n\tresetHook = new Hook( 'reset' );\n\nexport default function Ractive$reset ( data ) {\n\tvar promise, wrapper, changes, i, rerender;\n\n\tdata = data || {};\n\n\tif ( typeof data !== 'object' ) {\n\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t}\n\n\t// If the root object is wrapped, try and use the wrapper's reset value\n\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t// reset was rejected, we need to replace the object\n\t\t\tthis.viewmodel.reset( data );\n\t\t}\n\t} else {\n\t\tthis.viewmodel.reset( data );\n\t}\n\n\t// reset config items and track if need to rerender\n\tchanges = config.reset( this );\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\trerender = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( rerender ) {\n\t\tlet component;\n\n\t\tthis.viewmodel.mark( rootKeypath );\n\n\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t \t// flag, otherwise it will assume by default that a parent node\n\t \t// will be detached, and therefore it doesn't need to bother\n\t \t// detaching its own nodes\n\t \tif ( component = this.component ) {\n\t \t\tcomponent.shouldDestroy = true;\n\t \t}\n\n\t\tthis.unrender();\n\n\t\tif ( component ) {\n\t\t\tcomponent.shouldDestroy = false;\n\t\t}\n\n\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t// TODO if we're here, presumably it did?\n\t\tif ( this.fragment.template !== this.template ) {\n\t\t\tthis.fragment.unbind();\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tpromise = this.render( this.el, this.anchor );\n\t} else {\n\t\tpromise = runloop.start( this, true );\n\t\tthis.viewmodel.mark( rootKeypath );\n\t\trunloop.end();\n\t}\n\n\tresetHook.fire( this, data );\n\n\treturn promise;\n}\n","import bubble from './Fragment/prototype/bubble';\nimport detach from './Fragment/prototype/detach';\nimport find from './Fragment/prototype/find';\nimport findAll from './Fragment/prototype/findAll';\nimport findAllComponents from './Fragment/prototype/findAllComponents';\nimport findComponent from './Fragment/prototype/findComponent';\nimport findNextNode from './Fragment/prototype/findNextNode';\nimport firstNode from './Fragment/prototype/firstNode';\nimport getArgsList from './Fragment/prototype/getArgsList';\nimport getNode from './Fragment/prototype/getNode';\nimport getValue from './Fragment/prototype/getValue';\nimport init from './Fragment/prototype/init';\nimport rebind from './Fragment/prototype/rebind';\nimport render from './Fragment/prototype/render';\nimport toString from './Fragment/prototype/toString';\nimport unbind from './Fragment/prototype/unbind';\nimport unrender from './Fragment/prototype/unrender';\n\nvar Fragment = function ( options ) {\n\tthis.init( options );\n};\n\nFragment.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetArgsList: getArgsList,\n\tgetNode: getNode,\n\tgetValue: getValue,\n\tinit: init,\n\trebind: rebind,\n\tregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tif ( idxs.indexOf( idx ) === -1 ) {\n\t\t\tidxs.push( idx );\n\t\t}\n\t},\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tidxs.splice( idxs.indexOf( idx ), 1 );\n\t},\n\tunrender: unrender\n};\n\nexport default Fragment;\n","export default function Fragment$unrender ( shouldDestroy ) {\n\tif ( !this.rendered ) {\n\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t}\n\n\tthis.items.forEach( i => i.unrender( shouldDestroy ) );\n\tthis.rendered = false;\n}\n","export default function Fragment$unbind () {\n\tif ( !this.bound ) {\n\t\treturn;\n\t}\n\n\tthis.items.forEach( unbindItem );\n\tthis.bound = false;\n}\n\nfunction unbindItem ( item ) {\n\tif ( item.unbind ) {\n\t\titem.unbind();\n\t}\n}\n","export default function Fragment$toString ( escape ) {\n\tif ( !this.items ) {\n\t\treturn '';\n\t}\n\n\treturn this.items.map( escape ? toEscapedString : toString ).join( '' );\n}\n\nfunction toString ( item ) {\n\treturn item.toString();\n}\n\nfunction toEscapedString ( item ) {\n\treturn item.toString( true );\n}","export default function Fragment$render () {\n\tvar result;\n\n\tif ( this.items.length === 1 ) {\n\t\tresult = this.items[0].render();\n\t} else {\n\t\tresult = document.createDocumentFragment();\n\n\t\tthis.items.forEach( item => {\n\t\t\tresult.appendChild( item.render() );\n\t\t});\n\t}\n\n\tthis.rendered = true;\n\treturn result;\n}\n","import { assignNewKeypath } from 'shared/keypaths';\n\nexport default function Fragment$rebind ( oldKeypath, newKeypath ) {\n\n\t// assign new context keypath if needed\n\tif ( !this.owner || this.owner.hasContext ) {\n\t\tassignNewKeypath( this, 'context', oldKeypath, newKeypath );\n\t}\n\n\tthis.items.forEach( item => {\n\t\tif ( item.rebind ) {\n\t\t\titem.rebind( oldKeypath, newKeypath );\n\t\t}\n\t});\n}\n","import { YIELDER, INTERPOLATOR, SECTION, TRIPLE, ELEMENT, PARTIAL, COMMENT, DOCTYPE } from 'config/types';\nimport Text from 'virtualdom/items/Text';\nimport Interpolator from 'virtualdom/items/Interpolator';\nimport Section from 'virtualdom/items/Section/_Section';\nimport Triple from 'virtualdom/items/Triple/_Triple';\nimport Element from 'virtualdom/items/Element/_Element';\nimport Partial from 'virtualdom/items/Partial/_Partial';\nimport getComponent from 'virtualdom/items/Component/getComponent';\nimport Component from 'virtualdom/items/Component/_Component';\nimport Comment from 'virtualdom/items/Comment';\nimport Yielder from 'virtualdom/items/Yielder';\nimport Doctype from 'virtualdom/items/Doctype';\n\nexport default function Fragment$init ( options ) {\n\tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\tthis.parent = this.owner.parentFragment;\n\n\t// inherited properties\n\tthis.root = options.root;\n\tthis.pElement = options.pElement;\n\tthis.context = options.context;\n\tthis.index = options.index;\n\tthis.key = options.key;\n\tthis.registeredIndexRefs = [];\n\n\t// encapsulated styles should be inherited until they get applied by an element\n\tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\n\tthis.items = options.template.map( ( template, i ) => createItem({\n\t\tparentFragment: this,\n\t\tpElement: options.pElement,\n\t\ttemplate: template,\n\t\tindex: i\n\t}) );\n\n\tthis.value = this.argsList = null;\n\tthis.dirtyArgs = this.dirtyValue = true;\n\n\tthis.bound = true;\n}\n\nfunction createItem ( options ) {\n\tif ( typeof options.template === 'string' ) {\n\t\treturn new Text( options );\n\t}\n\n\tswitch ( options.template.t ) {\n\t\tcase YIELDER:      return new Yielder( options );\n\t\tcase INTERPOLATOR: return new Interpolator( options );\n\t\tcase SECTION:      return new Section( options );\n\t\tcase TRIPLE:       return new Triple( options );\n\t\tcase ELEMENT:\n\t\t\tlet constructor;\n\t\t\tif ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {\n\t\t\t\treturn new Component( options, constructor );\n\t\t\t}\n\t\t\treturn new Element( options );\n\t\tcase PARTIAL:      return new Partial( options );\n\t\tcase COMMENT:      return new Comment( options );\n\t\tcase DOCTYPE:      return new Doctype( options );\n\n\t\tdefault: throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );\n\t}\n}\n","import noop from 'utils/noop';\n\nvar Doctype = function ( options ) {\n\tthis.declaration = options.template.a;\n};\n\nDoctype.prototype = {\n\tinit: noop,\n\trender: noop,\n\tunrender: noop,\n\tteardown: noop,\n\ttoString () {\n\t\treturn '<!DOCTYPE' + this.declaration + '>';\n\t}\n};\n\nexport default Doctype;","import { YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\nimport { isArray } from 'utils/is';\n\nvar Yielder = function ( options ) {\n\tvar container, component;\n\n\tthis.type = YIELDER;\n\n\tthis.container = container = options.parentFragment.root;\n\tthis.component = component = container.component;\n\n\tthis.container = container;\n\tthis.containerFragment = options.parentFragment;\n\tthis.parentFragment = component.parentFragment;\n\n\tlet name = this.name = options.template.n || '';\n\n\tlet template = container._inlinePartials[ name ];\n\n\tif ( !template ) {\n\t\twarnIfDebug( `Could not find template for partial \"${name}\"`, { ractive: options.root });\n\t\ttemplate = [];\n\t}\n\n\tthis.fragment = new Fragment({\n\t\towner: this,\n\t\troot: container.parent,\n\t\ttemplate,\n\t\tpElement: this.containerFragment.pElement\n\t});\n\n\t// even though only one yielder is allowed, we need to have an array of them\n\t// as it's possible to cause a yielder to be created before the last one\n\t// was destroyed in the same turn of the runloop\n\tif ( !isArray( component.yielders[ name ] ) ) {\n\t\tcomponent.yielders[ name ] = [ this ];\n\t} else {\n\t\tcomponent.yielders[ name ].push( this );\n\t}\n\n\trunloop.scheduleTask( () => {\n\t\tif ( component.yielders[ name ].length > 1 ) {\n\t\t\tthrow new Error( 'A component template can only have one {{yield' + (name ? ' ' + name : '') + '}} declaration at a time' );\n\t\t}\n\t});\n};\n\nYielder.prototype = {\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfindNextNode () {\n\t\treturn this.containerFragment.findNextNode( this );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tgetValue ( options ) {\n\t\treturn this.fragment.getValue( options );\n\t},\n\n\trender () {\n\t\treturn this.fragment.render();\n\t},\n\n\tunbind () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tthis.fragment.unrender( shouldDestroy );\n\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\ttoString () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default Yielder;\n","import { COMMENT } from 'config/types';\nimport detach from './shared/detach';\n\nvar Comment = function ( options ) {\n\tthis.type = COMMENT;\n\tthis.value = options.template.c;\n};\n\nComment.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createComment( this.value );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString () {\n\t\treturn '<!--' + this.value + '-->';\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t}\n\t}\n};\n\nexport default Comment;\n","import detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Component = function ( options, Constructor ) {\n\tthis.init( options, Constructor );\n};\n\nComponent.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Component;\n","export default function Component$unrender ( shouldDestroy ) {\n\tthis.shouldDestroy = shouldDestroy;\n\tthis.instance.unrender();\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport { unbind, cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\nexport default function Component$unbind () {\n\tvar instance = this.instance;\n\n\tthis.resolvers.forEach( unbind );\n\n\tremoveFromLiveComponentQueries( this );\n\n\tinstance._observers.forEach( cancel );\n\n\t// teardown the instance\n\tinstance.fragment.unbind();\n\tinstance.viewmodel.teardown();\n\n\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t}\n\n\tteardownHook.fire( instance );\n}\n\nfunction removeFromLiveComponentQueries ( component ) {\n\tvar instance, query;\n\n\tinstance = component.root;\n\n\tdo {\n\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery._remove( component );\n\t\t}\n\t} while ( instance = instance.parent );\n}","export default function Component$toString () {\n\treturn this.instance.fragment.toString();\n}\n","export default function Component$render () {\n\tvar instance = this.instance;\n\n\tinstance.render( this.parentFragment.getNode() );\n\n\tthis.rendered = true;\n\treturn instance.fragment.detach();\n}\n","export default function Component$rebind ( oldKeypath, newKeypath ) {\n\tvar query;\n\n\tthis.resolvers.forEach( rebind );\n\n\tfor ( let k in this.yielders ) {\n\t\tif ( this.yielders[k][0] ) {\n\t\t\trebind( this.yielders[k][0] );\n\t\t}\n\t}\n\n\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\tquery._makeDirty();\n\t}\n\n\tfunction rebind ( x ) {\n\t\tx.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import createInstance from 'virtualdom/items/Component/initialise/createInstance';\nimport propagateEvents from 'virtualdom/items/Component/initialise/propagateEvents';\nimport { COMPONENT } from 'config/types';\nimport updateLiveQueries from 'virtualdom/items/Component/initialise/updateLiveQueries';\nimport { warnIfDebug } from 'utils/log';\n\nexport default function Component$init ( options, Component ) {\n\tvar parentFragment, root;\n\n\tif ( !Component ) {\n\t\tthrow new Error( 'Component \"' + this.name + '\" not found' );\n\t}\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\troot = parentFragment.root;\n\n\tthis.root = root;\n\tthis.type = COMPONENT;\n\tthis.name = options.template.e;\n\tthis.index = options.index;\n\tthis.indexRefBindings = {};\n\tthis.yielders = {};\n\tthis.resolvers = [];\n\n\tcreateInstance( this, Component, options.template.a, options.template.f, options.template.p );\n\tpropagateEvents( this, options.template.v );\n\n\t// intro, outro and decorator directives have no effect\n\tif ( options.template.t0 || options.template.t1 || options.template.t2 || options.template.o ) {\n\t\twarnIfDebug( 'The \"intro\", \"outro\" and \"decorator\" directives have no effect on components', { ractive: this.instance });\n\t}\n\n\tupdateLiveQueries( this );\n}\n","export default function ( component ) {\n\tvar ancestor, query;\n\n\t// If there's a live query for this component type, add it\n\tancestor = component.root;\n\twhile ( ancestor ) {\n\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery.push( component.instance );\n\t\t}\n\n\t\tancestor = ancestor.parent;\n\t}\n}\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal } from 'utils/log';\n\n// TODO how should event arguments be handled? e.g.\n// <widget on-foo='bar:1,2,3'/>\n// The event 'bar' will be fired on the parent instance\n// when 'foo' fires on the child, but the 1,2,3 arguments\n// will be lost\n\nexport default function propagateEvents ( component, eventsDescriptor ) {\n\tvar eventName;\n\n\tfor ( eventName in eventsDescriptor ) {\n\t\tif ( eventsDescriptor.hasOwnProperty( eventName ) ) {\n\t\t\tpropagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );\n\t\t}\n\t}\n}\n\nfunction propagateEvent ( childInstance, parentInstance, eventName, proxyEventName ) {\n\tif ( typeof proxyEventName !== 'string' ) {\n\t\tfatal( 'Components currently only support simple events - you cannot include arguments. Sorry!' );\n\t}\n\n\tchildInstance.on( eventName, function () {\n\t\tvar event, args;\n\n\t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n\t\t\tevent = Array.prototype.shift.call( arguments );\n\t\t}\n\n\t\targs = Array.prototype.slice.call( arguments );\n\n\t\tfireEvent( parentInstance, proxyEventName, { event: event, args: args } );\n\n\t\t// cancel bubbling\n\t\treturn false;\n\t});\n}\n","import { INTERPOLATOR, YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport parseJSON from 'utils/parseJSON';\nimport initialise from 'Ractive/initialise';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\nimport ReferenceExpressionResolver from 'virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ComplexParameter from './ComplexParameter';\n\nexport default function ( component, Component, attributes, yieldTemplate, partials ) {\n\tvar instance, parentFragment, ractive, fragment, container, inlinePartials = {}, data = {}, mappings = {}, ready, resolvers = [];\n\n\tparentFragment = component.parentFragment;\n\tractive = component.root;\n\n\tpartials = partials || {};\n\textend( inlinePartials, partials );\n\n\t// Make contents available as a {{>content}} partial\n\tpartials.content = yieldTemplate || [];\n\n\t// set a default partial for yields with no name\n\tinlinePartials[''] = partials.content;\n\n\tif ( Component.defaults.el ) {\n\t\twarnIfDebug( 'The <%s/> component has a default `el` property; it has been disregarded', component.name );\n\t}\n\n\t// find container\n\tfragment = parentFragment;\n\twhile ( fragment ) {\n\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\tcontainer = fragment.owner.container;\n\t\t\tbreak;\n\t\t}\n\n\t\tfragment = fragment.parent;\n\t}\n\n\t// each attribute represents either a) data or b) a mapping\n\tif ( attributes ) {\n\t\tObject.keys( attributes ).forEach( key => {\n\t\t\tvar attribute = attributes[ key ], parsed, resolver;\n\n\t\t\tif ( typeof attribute === 'string' ) {\n\t\t\t\t// it's static data\n\t\t\t\tparsed = parseJSON( attribute );\n\t\t\t\tdata[ key ] = parsed ? parsed.value : attribute;\n\t\t\t}\n\n\t\t\telse if ( attribute === 0 ) {\n\t\t\t\t// it had no '=', so we'll call it true\n\t\t\t\tdata[ key ] = true;\n\t\t\t}\n\n\t\t\telse if ( isArray( attribute ) ) {\n\t\t\t\t// this represents dynamic data\n\t\t\t\tif ( isSingleInterpolator( attribute ) ) {\n\t\t\t\t\tmappings[ key ] = {\n\t\t\t\t\t\torigin: component.root.viewmodel,\n\t\t\t\t\t\tkeypath: undefined\n\t\t\t\t\t};\n\n\t\t\t\t\tresolver = createResolver( component, attribute[0], function ( keypath ) {\n\t\t\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.set( key, keypath.value ); // TODO use viewmodel?\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[ key ] = keypath.value;\n\n\t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n\t\t\t\t\t\t\t\tdelete mappings[ key ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.viewmodel.mappings[ key ].resolve( keypath );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// resolved immediately\n\t\t\t\t\t\t\t\tmappings[ key ].keypath = keypath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresolver = new ComplexParameter( component, attribute, function ( value ) {\n\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\tinstance.set( key, value ); // TODO use viewmodel?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tresolvers.push( resolver );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow new Error( 'erm wut' );\n\t\t\t}\n\t\t});\n\t}\n\n\tinstance = create( Component.prototype );\n\n\tinitialise( instance, {\n\t\tel: null,\n\t\tappend: true,\n\t\tdata,\n\t\tpartials,\n\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\tmodifyArrays: ractive.modifyArrays,\n\t\t// need to inherit runtime parent adaptors\n\t\tadapt: ractive.adapt\n\t}, {\n\t\tparent: ractive,\n\t\tcomponent,\n\t\tcontainer,\n\t\tmappings,\n\t\tinlinePartials,\n\t\tcssIds: parentFragment.cssIds\n\t});\n\n\tready = true;\n\tcomponent.resolvers = resolvers;\n\n\treturn instance;\n}\n\nfunction createResolver ( component, template, callback ) {\n\tvar resolver;\n\n\tif ( template.r ) {\n\t\tresolver = createReferenceResolver( component, template.r, callback );\n\t}\n\n\telse if ( template.x ) {\n\t\tresolver = new ExpressionResolver( component, component.parentFragment, template.x, callback );\n\t}\n\n\telse if ( template.rx ) {\n\t\tresolver = new ReferenceExpressionResolver( component, template.rx, callback );\n\t}\n\n\treturn resolver;\n}\n\nfunction isSingleInterpolator( template ){\n\treturn template.length === 1 && template[0].t === INTERPOLATOR;\n}\n","import runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nfunction ComplexParameter ( component, template, callback ) {\n\tthis.parentFragment = component.parentFragment;\n\tthis.callback = callback;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: template,\n\t\troot:     component.root,\n\t\towner:    this\n\t});\n\n\tthis.update();\n}\n\nexport default ComplexParameter;\n\nComplexParameter.prototype = {\n\tbubble: function () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\tthis.callback( this.fragment.getValue() );\n\t\tthis.dirty = false;\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t}\n};\n\n","import { fatal, logIfDebug, warnIfDebug, warnOnceIfDebug, welcome } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport { magic as magicSupported } from 'config/environment';\nimport { ensureArray } from 'utils/array';\nimport { findInViewHierarchy } from 'shared/registry';\nimport arrayAdaptor from 'Ractive/static/adaptors/array/index';\nimport magicAdaptor from 'Ractive/static/adaptors/magic';\nimport magicArrayAdaptor from 'Ractive/static/adaptors/magicArray';\nimport { getElement } from 'utils/dom';\nimport { create, defineProperty, extend } from 'utils/object';\nimport runloop from 'global/runloop';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport Fragment from 'virtualdom/Fragment';\nimport Viewmodel from 'viewmodel/Viewmodel';\nimport Hook from './prototype/shared/hooks/Hook';\nimport HookQueue from './prototype/shared/hooks/HookQueue';\nimport getComputationSignatures from './helpers/getComputationSignatures';\nimport Ractive from '../Ractive';\n\nlet constructHook = new Hook( 'construct' );\nlet configHook = new Hook( 'config' );\nlet initHook = new HookQueue( 'init' );\nlet uid = 0;\n\nlet registryNames = [\n\t'adaptors',\n\t'components',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nexport default initialiseRactiveInstance;\n\nfunction initialiseRactiveInstance ( ractive, userOptions = {}, options = {} ) {\n\tvar el, viewmodel;\n\n\tif ( Ractive.DEBUG ) {\n\t\twelcome();\n\t}\n\n\tinitialiseProperties( ractive, options );\n\n\t// TODO remove this, eventually\n\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\tconstructHook.fire( ractive, userOptions );\n\n\t// Add registries\n\tregistryNames.forEach( name => {\n\t\tractive[ name ] = extend( create( ractive.constructor[ name ] || null ), userOptions[ name ] );\n\t});\n\n\t// Create a viewmodel\n\tviewmodel = new Viewmodel({\n\t\tadapt: getAdaptors( ractive, ractive.adapt, userOptions ),\n\t\tdata: dataConfigurator.init( ractive.constructor, ractive, userOptions ),\n\t\tcomputed: getComputationSignatures( ractive, extend( create( ractive.constructor.prototype.computed ), userOptions.computed ) ),\n\t\tmappings: options.mappings,\n\t\tractive: ractive,\n\t\tonchange: () => runloop.addRactive( ractive )\n\t});\n\n\tractive.viewmodel = viewmodel;\n\n\t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n\tviewmodel.init();\n\n\t// init config from Parent and options\n\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\tconfigHook.fire( ractive );\n\tinitHook.begin( ractive );\n\n\t// // If this is a component with a function `data` property, call the function\n\t// // with `ractive` as context (unless the child was also a function)\n\t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n\t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n\t// }\n\n\n\t// Render virtual DOM\n\tif ( ractive.template ) {\n\t\tlet cssIds;\n\n\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n\t\t\tif ( ractive.cssId ) {\n\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t}\n\t\t}\n\n\t\tractive.fragment = new Fragment({\n\t\t\ttemplate: ractive.template,\n\t\t\troot: ractive,\n\t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n\t\t\tcssIds\n\t\t});\n\t}\n\n\tinitHook.end( ractive );\n\n\t// render automatically ( if `el` is specified )\n\tif ( el = getElement( ractive.el ) ) {\n\t\tlet promise = ractive.render( el, ractive.append );\n\n\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\tpromise.catch( err => {\n\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive });\n\t\t\t\terr.stack && logIfDebug( err.stack );\n\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction getAdaptors ( ractive, protoAdapt, userOptions ) {\n\tvar adapt, magic, modifyArrays;\n\n\tprotoAdapt = protoAdapt.map( lookup );\n\tadapt = ensureArray( userOptions.adapt ).map( lookup );\n\n\tadapt = combine( protoAdapt, adapt );\n\n\tmagic = 'magic' in userOptions ? userOptions.magic : ractive.magic;\n\tmodifyArrays = 'modifyArrays' in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n\tif ( magic ) {\n\t\tif ( !magicSupported ) {\n\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t}\n\n\t\tif ( modifyArrays ) {\n\t\t\tadapt.push( magicArrayAdaptor );\n\t\t}\n\n\t\tadapt.push( magicAdaptor );\n\t}\n\n\tif ( modifyArrays ) {\n\t\tadapt.push( arrayAdaptor );\n\t}\n\n\treturn adapt;\n\n\n\tfunction lookup ( adaptor ) {\n\t\tif ( typeof adaptor === 'string' ) {\n\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\tif ( !adaptor ) {\n\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t}\n\t\t}\n\n\t\treturn adaptor;\n\t}\n}\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}\n\nfunction initialiseProperties ( ractive, options ) {\n\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t// existed\n\tractive._guid = 'r-' + uid++;\n\n\t// events\n\tractive._subs = create( null );\n\n\t// storage for item configuration from instantiation to reset,\n\t// like dynamic functions or original values\n\tractive._config = {};\n\n\t// two-way bindings\n\tractive._twowayBindings = create( null );\n\n\t// animations (so we can stop any in progress at teardown)\n\tractive._animations = [];\n\n\t// nodes registry\n\tractive.nodes = {};\n\n\t// live queries\n\tractive._liveQueries = [];\n\tractive._liveComponentQueries = [];\n\n\t// bound data functions\n\tractive._boundFunctions = [];\n\n\t// observers\n\tractive._observers = [];\n\n\n\t// properties specific to inline components\n\tif ( options.component ) {\n\t\tractive.parent = options.parent;\n\t\tractive.container = options.container || null;\n\t\tractive.root = ractive.parent.root;\n\n\t\tractive.component = options.component;\n\t\toptions.component.instance = ractive;\n\n\t\t// for hackability, this could be an open option\n\t\t// for any ractive instance, but for now, just\n\t\t// for components and just for ractive...\n\t\tractive._inlinePartials = options.inlinePartials;\n\t} else {\n\t\tractive.root = ractive;\n\t\tractive.parent = ractive.container = null;\n\t}\n}\n\nfunction deprecateRactiveData () {\n\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n}\n","import { fatal } from 'utils/log';\n\nvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\nexport default function getComputationSignatures ( ractive, computed ) {\n\tvar signatures = {}, key;\n\n\tfor ( key in computed ) {\n\t\tsignatures[ key ] = getComputationSignature( ractive, key, computed[ key ] );\n\t}\n\n\treturn signatures;\n}\n\nfunction getComputationSignature ( ractive, key, signature ) {\n\tvar getter, setter;\n\n\tif ( typeof signature === 'function' ) {\n\t\tgetter = bind( signature, ractive );\n\t}\n\n\tif ( typeof signature === 'string' ) {\n\t\tgetter = createFunctionFromString( ractive, signature );\n\t}\n\n\tif ( typeof signature === 'object' ) {\n\t\tif ( typeof signature.get === 'string' ) {\n\t\t\tgetter = createFunctionFromString( ractive, signature.get );\n\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\tgetter = bind( signature.get, ractive );\n\t\t} else {\n\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t}\n\n\t\tif ( typeof signature.set === 'function' ) {\n\t\t\tsetter = bind( signature.set, ractive );\n\t\t}\n\t}\n\n\treturn { getter: getter, setter: setter };\n}\n\nfunction createFunctionFromString ( ractive, str ) {\n\tvar functionBody, hasThis, fn;\n\n\tfunctionBody = 'return (' + str.replace( pattern, ( match, keypath ) => {\n\t\thasThis = true;\n\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t}) + ');';\n\n\tif ( hasThis ) {\n\t\tfunctionBody = 'var __ractive = this; ' + functionBody;\n\t}\n\n\tfn = new Function( functionBody );\n\treturn hasThis ? fn.bind( ractive ) : fn;\n}\n\nfunction bind ( fn, context ) {\n\treturn /this/.test( fn.toString() ) ? fn.bind( context ) : fn;\n}","import Hook from './Hook';\n\nfunction HookQueue ( event ) {\n\tthis.hook = new Hook( event );\n\tthis.inProcess = {};\n\tthis.queue = {};\n}\n\nHookQueue.prototype = {\n\n\tconstructor: HookQueue,\n\n\tbegin: function ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t},\n\n\tend: function ( ractive ) {\n\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t}\n};\n\nfunction getChildQueue ( queue, ractive ) {\n\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n}\n\nfunction fire ( hookQueue, ractive ) {\n\n\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\thookQueue.hook.fire( ractive );\n\n\t// queue is \"live\" because components can end up being\n\t// added while hooks fire on parents that modify data values.\n\twhile ( childQueue.length ) {\n\t\tfire( hookQueue, childQueue.shift() );\n\t}\n\n\tdelete hookQueue.queue[ ractive._guid ];\n}\n\n\nexport default HookQueue;\n","import { fatal } from 'utils/log';\nimport { getKeypath } from 'shared/keypaths';\nimport { create } from 'utils/object';\nimport adapt from './prototype/adapt';\nimport applyChanges from './prototype/applyChanges';\nimport capture from './prototype/capture';\nimport clearCache from './prototype/clearCache';\nimport compute from './prototype/compute';\nimport get from './prototype/get';\nimport init from './prototype/init';\nimport map from './prototype/map';\nimport mark from './prototype/mark';\nimport merge from './prototype/merge';\nimport register from './prototype/register';\nimport release from './prototype/release';\nimport reset from './prototype/reset';\nimport set from './prototype/set';\nimport smartUpdate from './prototype/smartUpdate';\nimport teardown from './prototype/teardown';\nimport unregister from './prototype/unregister';\n\nvar Viewmodel = function ( options ) {\n\tvar { adapt, data, ractive, computed, mappings } = options,\n\t\tkey,\n\t\tmapping;\n\n\t// TODO is it possible to remove this reference?\n\tthis.ractive = ractive;\n\n\tthis.adaptors = adapt;\n\tthis.onchange = options.onchange;\n\n\tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n\tthis.cacheMap = create( null );\n\n\tthis.deps = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\tthis.depsMap = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\n\tthis.patternObservers = [];\n\n\tthis.specials = create( null );\n\n\tthis.wrapped = create( null );\n\tthis.computations = create( null );\n\n\tthis.captureGroups = [];\n\tthis.unresolvedImplicitDependencies = [];\n\n\tthis.changes = [];\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\tthis.data = data;\n\n\t// set up explicit mappings\n\tthis.mappings = create( null );\n\tfor ( key in mappings ) {\n\t\tthis.map( getKeypath( key ), mappings[ key ] );\n\t}\n\n\tif ( data ) {\n\t\t// if data exists locally, but is missing on the parent,\n\t\t// we transfer ownership to the parent\n\t\tfor ( key in data ) {\n\t\t\tif ( ( mapping = this.mappings[ key ] ) && mapping.getValue() === undefined ) {\n\t\t\t\tmapping.setValue( data[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( key in computed ) {\n\t\tif ( mappings && key in mappings ) {\n\t\t\tfatal( 'Cannot map to a computed property (\\'%s\\')', key );\n\t\t}\n\n\t\tthis.compute( getKeypath( key ), computed[ key ] );\n\t}\n\n\tthis.ready = true;\n};\n\nViewmodel.prototype = {\n\tadapt: adapt,\n\tapplyChanges: applyChanges,\n\tcapture: capture,\n\tclearCache: clearCache,\n\tcompute: compute,\n\tget: get,\n\tinit: init,\n\tmap: map,\n\tmark: mark,\n\tmerge: merge,\n\tregister: register,\n\trelease: release,\n\treset: reset,\n\tset: set,\n\tsmartUpdate: smartUpdate,\n\tteardown: teardown,\n\tunregister: unregister\n};\n\nexport default Viewmodel;\n","import { removeFromArray } from 'utils/array';\n\nexport default function Viewmodel$unregister ( keypath, dependant, group = 'default' ) {\n\tvar mapping, deps, index;\n\n\tif ( dependant.isStatic ) {\n\t\treturn;\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\treturn mapping.unregister( keypath, dependant, group );\n\t}\n\n\tdeps = this.deps[ group ][ keypath.str ];\n\tindex = deps.indexOf( dependant );\n\n\tif ( index === -1 ) {\n\t\tthrow new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );\n\t}\n\n\tdeps.splice( index, 1 );\n\n\tif ( keypath.isRoot ) {\n\t\treturn;\n\t}\n\n\tupdateDependantsMap( this, keypath, group );\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ];\n\n\t\tparent[ '_' + keypath.str ] -= 1;\n\n\t\tif ( !parent[ '_' + keypath.str ] ) {\n\t\t\t// remove from parent deps map\n\t\t\tremoveFromArray( parent, keypath );\n\t\t\tparent[ '_' + keypath.str ] = undefined;\n\t\t}\n\n\t\tkeypath = keypath.parent;\n\t}\n}\n","export default function Viewmodel$teardown () {\n\tvar unresolvedImplicitDependency;\n\n\t// Clear entire cache - this has the desired side-effect\n\t// of unwrapping adapted values (e.g. arrays)\n\tObject.keys( this.cache ).forEach( keypath => this.clearCache( keypath ) );\n\n\t// Teardown any failed lookups - we don't need them to resolve any more\n\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\tunresolvedImplicitDependency.teardown();\n\t}\n}\n","var implicitOption = { implicit: true }, noCascadeOption = { noCascade: true };\n\nexport default function Viewmodel$smartUpdate ( keypath, array, newIndices ) {\n\tvar dependants, oldLength, i;\n\n\toldLength = newIndices.length;\n\n\t// Indices that are being removed should be marked as dirty\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.mark( keypath.join( oldIndex ), noCascadeOption );\n\t\t}\n\t});\n\n\t// Update the model\n\t// TODO allow existing array to be updated in place, rather than replaced?\n\tthis.set( keypath, array, { silent: true } );\n\n\tif ( dependants = this.deps[ 'default' ][ keypath.str ] ) {\n\t\tdependants.filter( canShuffle ).forEach( d => d.shuffle( newIndices, array ) );\n\t}\n\n\tif ( oldLength !== array.length ) {\n\t\tthis.mark( keypath.join( 'length' ), implicitOption );\n\n\t\tfor ( i = newIndices.touchedFrom; i < array.length; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ) );\n\t\t}\n\n\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t// TODO is this still necessary, now that computations are lazy?\n\t\tfor ( i = array.length; i < oldLength; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ), noCascadeOption );\n\t\t}\n\t}\n}\n\nfunction canShuffle ( dependant ) {\n\treturn typeof dependant.shuffle === 'function';\n}\n","import { isEqual } from 'utils/is';\nimport createBranch from 'utils/createBranch';\n\nexport default function Viewmodel$set ( keypath, value, options = {} ) {\n\tvar mapping, computation, wrapper, keepExistingWrapper;\n\n\t// unless data is being set for data tracking purposes\n\tif ( !options.noMapping ) {\n\t\t// If this data belongs to a different viewmodel,\n\t\t// pass the change along\n\t\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\t\treturn mapping.set( keypath, value );\n\t\t}\n\t}\n\n\tcomputation = this.computations[ keypath.str ];\n\tif ( computation ) {\n\t\tif ( computation.setting ) {\n\t\t\t// let the other computation set() handle things...\n\t\t\treturn;\n\t\t}\n\t\tcomputation.set( value );\n\t\tvalue = computation.get();\n\t}\n\n\tif ( isEqual( this.cache[ keypath.str ], value ) ) {\n\t\treturn;\n\t}\n\n\twrapper = this.wrapped[ keypath.str ];\n\n\t// If we have a wrapper with a `reset()` method, we try and use it. If the\n\t// `reset()` method returns false, the wrapper should be torn down, and\n\t// (most likely) a new one should be created later\n\tif ( wrapper && wrapper.reset ) {\n\t\tkeepExistingWrapper = ( wrapper.reset( value ) !== false );\n\n\t\tif ( keepExistingWrapper ) {\n\t\t\tvalue = wrapper.get();\n\t\t}\n\t}\n\n\tif ( !computation && !keepExistingWrapper ) {\n\t\tresolveSet( this, keypath, value );\n\t}\n\n\tif ( !options.silent ) {\n\t\tthis.mark( keypath );\n\t} else {\n\t\t// We're setting a parent of the original target keypath (i.e.\n\t\t// creating a fresh branch) - we need to clear the cache, but\n\t\t// not mark it as a change\n\t\tthis.clearCache( keypath.str );\n\t}\n}\n\nfunction resolveSet ( viewmodel, keypath, value ) {\n\tvar wrapper, parentValue, wrapperSet, valueSet;\n\n\twrapperSet = function() {\n\t\tif ( wrapper.set ) {\n\t\t\twrapper.set( keypath.lastKey, value );\n\t\t} else {\n\t\t\tparentValue = wrapper.get();\n\t\t\tvalueSet();\n\t\t}\n\t};\n\n\tvalueSet = function(){\n\t\tif ( !parentValue ) {\n\t\t\tparentValue = createBranch( keypath.lastKey );\n\t\t\tviewmodel.set( keypath.parent, parentValue, { silent: true } );\n\t\t}\n\t\tparentValue[ keypath.lastKey ] = value;\n\t};\n\n\twrapper = viewmodel.wrapped[ keypath.parent.str ];\n\n\tif ( wrapper ) {\n\t\twrapperSet();\n\t} else {\n\t\tparentValue = viewmodel.get( keypath.parent );\n\n\t\t// may have been wrapped via the above .get()\n\t\t// call on viewmodel if this is first access via .set()!\n\t\tif( wrapper = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\t\twrapperSet();\n\t\t} else {\n\t\t\tvalueSet();\n\t\t}\n\t}\n}\n","export default function Viewmodel$reset ( data ) {\n\tthis.data = data;\n\tthis.clearCache( '' );\n}","export default function Viewmodel$release () {\n\treturn this.captureGroups.pop();\n}\n","export default function Viewmodel$register ( keypath, dependant, group = 'default' ) {\n\tvar mapping, depsByKeypath, deps;\n\n\tif ( dependant.isStatic ) {\n\t\treturn; // TODO we should never get here if a dependant is static...\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\tmapping.register( keypath, dependant, group );\n\t}\n\n\telse {\n\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\tdeps = depsByKeypath[ keypath.str ] || ( depsByKeypath[ keypath.str ] = [] );\n\n\t\tdeps.push( dependant );\n\n\t\tif ( !this.depsMap[ group ] ) {\n\t\t\tthis.depsMap[ group ] = {};\n\t\t}\n\n\t\tif ( !keypath.isRoot ) {\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t}\n\t}\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent, keypathStr;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ] || ( map[ keypath.parent.str ] = [] );\n\n\t\tkeypathStr = keypath.str;\n\n\t\t// TODO find an alternative to this nasty approach\n\t\tif ( parent[ '_' + keypathStr ] === undefined ) {\n\t\t\tparent[ '_' + keypathStr ] = 0;\n\t\t\tparent.push( keypath );\n\t\t}\n\n\t\tparent[ '_' + keypathStr ] += 1;\n\t\tkeypath = keypath.parent;\n\t}\n}\n","import { warnIfDebug } from 'utils/log';\nimport mapOldToNewIndex from './merge/mapOldToNewIndex';\n\nvar comparators = {};\n\nexport default function Viewmodel$merge ( keypath, currentArray, array, options ) {\n\tvar oldArray,\n\t\tnewArray,\n\t\tcomparator,\n\t\tnewIndices;\n\n\tthis.mark( keypath );\n\n\tif ( options && options.compare ) {\n\n\t\tcomparator = getComparatorFunction( options.compare );\n\n\t\ttry {\n\t\t\toldArray = currentArray.map( comparator );\n\t\t\tnewArray = array.map( comparator );\n\t\t} catch ( err ) {\n\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t// to do more DOM manipulation than we thought...\n\t\t\twarnIfDebug( 'merge(): \"%s\" comparison failed. Falling back to identity checking', keypath );\n\n\t\t\toldArray = currentArray;\n\t\t\tnewArray = array;\n\t\t}\n\n\t} else {\n\t\toldArray = currentArray;\n\t\tnewArray = array;\n\t}\n\n\t// find new indices for members of oldArray\n\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\n\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n}\n\nfunction stringify ( item ) {\n\treturn JSON.stringify( item );\n}\n\nfunction getComparatorFunction ( comparator ) {\n\t// If `compare` is `true`, we use JSON.stringify to compare\n\t// objects that are the same shape, but non-identical - i.e.\n\t// { foo: 'bar' } !== { foo: 'bar' }\n\tif ( comparator === true ) {\n\t\treturn stringify;\n\t}\n\n\tif ( typeof comparator === 'string' ) {\n\t\tif ( !comparators[ comparator ] ) {\n\t\t\tcomparators[ comparator ] = function ( item ) {\n\t\t\t\treturn item[ comparator ];\n\t\t\t};\n\t\t}\n\n\t\treturn comparators[ comparator ];\n\t}\n\n\tif ( typeof comparator === 'function' ) {\n\t\treturn comparator;\n\t}\n\n\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n}\n","export default function ( oldArray, newArray ) {\n\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n\tusedIndices = {};\n\tfirstUnusedIndex = 0;\n\n\tnewIndices = oldArray.map( function ( item, i ) {\n\t\tvar index, start, len;\n\n\t\tstart = firstUnusedIndex;\n\t\tlen = newArray.length;\n\n\t\tdo {\n\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\tif ( index === -1 ) {\n\t\t\t\tchanged = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstart = index + 1;\n\t\t} while ( usedIndices[ index ] && start < len );\n\n\t\t// keep track of the first unused index, so we don't search\n\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\tif ( index === firstUnusedIndex ) {\n\t\t\tfirstUnusedIndex += 1;\n\t\t}\n\n\t\tif ( index !== i ) {\n\t\t\tchanged = true;\n\t\t}\n\n\t\tusedIndices[ index ] = true;\n\t\treturn index;\n\t});\n\n\treturn newIndices;\n}\n","export default function Viewmodel$mark ( keypath, options ) {\n\tvar computation, keypathStr = keypath.str;\n\n\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t// should not be picked up by pattern observers\n\tif ( options ) {\n\t\tif ( options.implicit ) {\n\t\t\tthis.implicitChanges[ keypathStr ] = true;\n\t\t}\n\t\tif ( options.noCascade ) {\n\t\t\tthis.noCascade[ keypathStr ] = true;\n\t\t}\n\t}\n\n\tif ( computation = this.computations[ keypathStr ] ) {\n\t\tcomputation.invalidate();\n\t}\n\n\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\tthis.changes.push( keypath );\n\t}\n\n\t// pass on keepExistingWrapper, if we can\n\tlet keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n\tthis.clearCache( keypathStr, keepExistingWrapper );\n\n\tif ( this.ready ) {\n\t\tthis.onchange();\n\t}\n}\n","export default function Viewmodel$map ( key, options ) {\n\tvar mapping = this.mappings[ key.str ] = new Mapping( key, options );\n\tmapping.initViewmodel( this );\n\treturn mapping;\n}\n\nvar Mapping = function ( localKey, options ) {\n\tthis.localKey = localKey;\n\tthis.keypath = options.keypath;\n\tthis.origin = options.origin;\n\n\tthis.deps = [];\n\tthis.unresolved = [];\n\n\tthis.resolved = false;\n};\n\nMapping.prototype = {\n\tforceResolution () {\n\t\t// TODO warn, as per #1692?\n\t\tthis.keypath = this.localKey;\n\t\tthis.setup();\n\t},\n\n\tget ( keypath, options ) {\n\t\tif ( !this.resolved ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.map( keypath ), options );\n\t},\n\n\tgetValue () {\n\t\tif ( !this.keypath ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.keypath );\n\t},\n\n\tinitViewmodel ( viewmodel ) {\n\t\tthis.local = viewmodel;\n\t\tthis.setup();\n\t},\n\n\tmap ( keypath ) {\n    \t\tif( typeof this.keypath === undefined ) {\n    \t\t\treturn this.localKey;\n    \t\t}\n    \t\treturn keypath.replace( this.localKey, this.keypath );\n\t},\n\n\tregister ( keypath, dependant, group ) {\n\t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n\t\tif ( this.resolved ) {\n\t\t\tthis.origin.register( this.map( keypath ), dependant, group );\n\t\t}\n\t},\n\n\tresolve ( keypath ) {\n\t\tif ( this.keypath !== undefined ) {\n\t\t\tthis.unbind( true );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.setup();\n\t},\n\n\tset ( keypath, value ) {\n\t\tif ( !this.resolved ) {\n\t\t\tthis.forceResolution();\n\t\t}\n\n\t\tthis.origin.set( this.map( keypath ), value );\n\t},\n\n\tsetup () {\n\t\tif ( this.keypath === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\t// accumulated dependants can now be registered\n\t\tif ( this.deps.length ) {\n\t\t\tthis.deps.forEach( d => {\n\t\t\t\tvar keypath = this.map( d.keypath );\n\t\t\t\tthis.origin.register( keypath, d.dep, d.group );\n\n\t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n\t\t\t\tif ( d.dep.setValue ) {\n\t\t\t\t\td.dep.setValue( this.origin.get( keypath ) );\n\t\t\t\t} else if ( d.dep.invalidate ) {\n\t\t\t\t\td.dep.invalidate();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.origin.mark( this.keypath );\n\t\t}\n\t},\n\n\tsetValue ( value ) {\n\t\tif ( !this.keypath ) {\n\t\t\tthrow new Error( 'Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t}\n\n\t\tthis.origin.set( this.keypath, value );\n\t},\n\n\tunbind ( keepLocal ) {\n\t\tif ( !keepLocal ) {\n\t\t\tdelete this.local.mappings[ this.localKey ];\n\t\t}\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deps.forEach( d => {\n\t\t\tthis.origin.unregister( this.map( d.keypath ), d.dep, d.group );\n\t\t});\n\n\t\tif ( this.tracker ) {\n\t\t\tthis.origin.unregister( this.keypath, this.tracker );\n\t\t}\n\t},\n\n\tunregister ( keypath, dependant, group ) {\n\t\tvar deps, i;\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeps = this.deps;\n\t\ti = deps.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( deps[i].dep === dependant ) {\n\t\t\t\tdeps.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.origin.unregister( this.map( keypath ), dependant, group );\n\t}\n};\n","export default function Viewmodel$init () {\n\tvar key;\n\n\tfor ( key in this.computations ) {\n\t\tthis.computations[ key ].init( this );\n\t}\n}","import { lastItem } from 'utils/array';\nimport { hasOwn } from 'utils/object';\nimport FAILED_LOOKUP from './get/FAILED_LOOKUP';\n\nvar empty = {};\n\nexport default function Viewmodel$get ( keypath, options ) {\n\tvar cache = this.cache,\n\t\tvalue,\n\t\tcomputation,\n\t\twrapped,\n\t\tcaptureGroup,\n\t\tkeypathStr = keypath.str,\n\t\tkey;\n\n\toptions = options || empty;\n\n\t// capture the keypath, if we're inside a computation\n\tif ( options.capture && ( captureGroup = lastItem( this.captureGroups ) ) ) {\n\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\tcaptureGroup.push( keypath );\n\t\t}\n\t}\n\n\tif ( hasOwn.call( this.mappings, keypath.firstKey ) ) {\n\t\treturn this.mappings[ keypath.firstKey ].get( keypath, options );\n\t}\n\n\tif ( keypath.isSpecial ) {\n\t\treturn keypath.value;\n\t}\n\n\tif ( cache[ keypathStr ] === undefined ) {\n\n\t\t// Is this a computed property?\n\t\tif ( ( computation = this.computations[ keypathStr ] ) && !computation.bypass ) {\n\t\t\tvalue = computation.get();\n\t\t\tthis.adapt( keypathStr, value );\n\t\t}\n\n\t\t// Is this a wrapped property?\n\t\telse if ( wrapped = this.wrapped[ keypathStr ] ) {\n\t\t\tvalue = wrapped.value;\n\t\t}\n\n\t\t// Is it the root?\n\t\telse if ( keypath.isRoot ) {\n\t\t\tthis.adapt( '', this.data );\n\t\t\tvalue = this.data;\n\t\t}\n\n\t\t// No? Then we need to retrieve the value one key at a time\n\t\telse {\n\t\t\tvalue = retrieve( this, keypath );\n\t\t}\n\n\t\tcache[ keypathStr ] = value;\n\t} else {\n\t\tvalue = cache[ keypathStr ];\n\t}\n\n\tif ( !options.noUnwrap && ( wrapped = this.wrapped[ keypathStr ] ) ) {\n\t\tvalue = wrapped.get();\n\t}\n\n\tif ( keypath.isRoot && options.fullRootGet ) {\n\t\tfor ( key in this.mappings ) {\n\t\t\tvalue[ key ] = this.mappings[ key ].getValue();\n\t\t}\n\t}\n\n\treturn value === FAILED_LOOKUP ? void 0 : value;\n}\n\nfunction retrieve ( viewmodel, keypath ) {\n\n\tvar parentValue, cacheMap, value, wrapped;\n\n\tparentValue = viewmodel.get( keypath.parent );\n\n\tif ( wrapped = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\tparentValue = wrapped.get();\n\t}\n\n\tif ( parentValue === null || parentValue === undefined ) {\n\t\treturn;\n\t}\n\n\t// update cache map\n\tif ( !( cacheMap = viewmodel.cacheMap[ keypath.parent.str ] ) ) {\n\t\tviewmodel.cacheMap[ keypath.parent.str ] = [ keypath.str ];\n\t} else {\n\t\tif ( cacheMap.indexOf( keypath.str ) === -1 ) {\n\t\t\tcacheMap.push( keypath.str );\n\t\t}\n\t}\n\n\t// If this property doesn't exist, we return a sentinel value\n\t// so that we know to query parent scope (if such there be)\n\tif ( typeof parentValue === 'object' && !( keypath.lastKey in parentValue ) ) {\n\t\treturn viewmodel.cache[ keypath.str ] = FAILED_LOOKUP;\n\t}\n\n\tvalue = parentValue[ keypath.lastKey ];\n\n\t// Do we have an adaptor for this value?\n\tviewmodel.adapt( keypath.str, value, false );\n\n\t// Update cache\n\tviewmodel.cache[ keypath.str ] = value;\n\treturn value;\n}\n","import Computation from '../Computation/Computation';\n\nexport default function Viewmodel$compute ( key, signature ) {\n\tvar computation = new Computation( key, signature );\n\n\tif ( this.ready ) {\n\t\tcomputation.init( this );\n\t}\n\n\treturn ( this.computations[ key.str ] = computation );\n}\n","import runloop from 'global/runloop';\nimport { logIfDebug, warnIfDebug, warnOnce } from 'utils/log';\nimport { isEqual } from 'utils/is';\nimport UnresolvedDependency from './UnresolvedDependency';\n\nvar Computation = function ( key, signature ) {\n\tthis.key = key;\n\n\tthis.getter = signature.getter;\n\tthis.setter = signature.setter;\n\n\tthis.hardDeps = signature.deps || [];\n\tthis.softDeps = [];\n\tthis.unresolvedDeps = {};\n\n\tthis.depValues = {};\n\n\tthis._dirty = this._firstRun = true;\n};\n\nComputation.prototype = {\n\tconstructor: Computation,\n\n\tinit ( viewmodel ) {\n\t\tvar initial;\n\n\t\tthis.viewmodel = viewmodel;\n\t\tthis.bypass = true;\n\n\t\tinitial = viewmodel.get( this.key );\n\t\tviewmodel.clearCache( this.key.str );\n\n\t\tthis.bypass = false;\n\n\t\tif ( this.setter && initial !== undefined ) {\n\t\t\tthis.set( initial );\n\t\t}\n\n\t\tif ( this.hardDeps ) {\n\t\t\tthis.hardDeps.forEach( d => viewmodel.register( d, this, 'computed' ) );\n\t\t}\n\t},\n\n\tinvalidate () {\n\t\tthis._dirty = true;\n\t},\n\n\tget () {\n\t\tvar newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\n\t\tif ( this.getting ) {\n\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\tlet msg = `The ${this.key.str} computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by \\`array.sort(...)\\` - if that\\'s the case, clone the array first with \\`array.slice().sort(...)\\``;\n\t\t\twarnOnce( msg );\n\t\t\treturn this.value;\n\t\t}\n\n\t\tthis.getting = true;\n\n\t\tif ( this._dirty ) {\n\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t// other computed values\n\t\t\tif ( this._firstRun || ( !this.hardDeps.length && !this.softDeps.length ) ) {\n\t\t\t\tdependencyValuesChanged = true;\n\t\t\t} else {\n\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\tvar keypath, value, i;\n\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ti = deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = deps[i];\n\t\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\n\t\t\t\t\t\tif ( !isEqual( value, this.depValues[ keypath.str ] ) ) {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = value;\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\tthis.viewmodel.capture();\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.value = this.getter();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( 'Failed to compute \"%s\"', this.key.str );\n\t\t\t\t\tlogIfDebug( err.stack || err );\n\n\t\t\t\t\tthis.value = void 0;\n\t\t\t\t}\n\n\t\t\t\tnewDeps = this.viewmodel.release();\n\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\t\tdeps.forEach( keypath => {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = this.viewmodel.get( keypath );\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tthis.getting = this._firstRun = false;\n\t\treturn this.value;\n\t},\n\n\tset ( value ) {\n\t\tif ( this.setting ) {\n\t\t\tthis.value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.setter ) {\n\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t}\n\n\t\tthis.setter( value );\n\t},\n\n\tupdateDependencies ( newDeps ) {\n\t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n\t\toldDeps = this.softDeps;\n\n\t\t// remove dependencies that are no longer used\n\t\ti = oldDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = oldDeps[i];\n\n\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\tdependenciesChanged = true;\n\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t}\n\t\t}\n\n\t\t// create references for any new dependencies\n\t\ti = newDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = newDeps[i];\n\n\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\tdependenciesChanged = true;\n\n\t\t\t\t// if this keypath is currently unresolved, we need to mark\n\t\t\t\t// it as such. TODO this is a bit muddy...\n\t\t\t\tif ( isUnresolved( this.viewmodel, keypath ) && ( !this.unresolvedDeps[ keypath.str ] ) ) {\n\t\t\t\t\tunresolved = new UnresolvedDependency( this, keypath.str );\n\t\t\t\t\tnewDeps.splice( i, 1 );\n\n\t\t\t\t\tthis.unresolvedDeps[ keypath.str ] = unresolved;\n\t\t\t\t\trunloop.addUnresolved( unresolved );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dependenciesChanged ) {\n\t\t\tthis.softDeps = newDeps.slice();\n\t\t}\n\n\t\treturn dependenciesChanged;\n\t}\n};\n\nfunction isUnresolved( viewmodel, keypath ) {\n\tvar key = keypath.firstKey;\n\n\treturn !( key in viewmodel.data ) &&\n\t       !( key in viewmodel.computations ) &&\n\t       !( key in viewmodel.mappings );\n}\n\nexport default Computation;\n","var UnresolvedDependency = function ( computation, ref ) {\n\tthis.computation = computation;\n\tthis.viewmodel = computation.viewmodel;\n\tthis.ref = ref;\n\n\t// TODO this seems like a red flag!\n\tthis.root = this.viewmodel.ractive;\n\tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n};\n\nUnresolvedDependency.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.computation.softDeps.push( keypath );\n\t\tthis.computation.unresolvedDeps[ keypath.str ] = null;\n\t\tthis.viewmodel.register( keypath, this.computation, 'computed' );\n\t}\n};\n\nexport default UnresolvedDependency;","export default function Viewmodel$clearCache ( keypath, keepExistingWrapper ) {\n\tvar cacheMap, wrapper;\n\n\tif ( !keepExistingWrapper ) {\n\t\t// Is there a wrapped property at this keypath?\n\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t// Did we unwrap it?\n\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t// Is this right?\n\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache[ keypath ] = undefined;\n\n\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\twhile ( cacheMap.length ) {\n\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t}\n\t}\n}\n","export default function Viewmodel$capture () {\n\tthis.captureGroups.push([]);\n}\n","import getUpstreamChanges from '../helpers/getUpstreamChanges';\nimport notifyPatternObservers from './applyChanges/notifyPatternObservers';\n\nexport default function Viewmodel$applyChanges () {\n\tvar self = this,\n\t\tchanges,\n\t\tupstreamChanges,\n\t\thash = {},\n\t\tbindings;\n\n\tchanges = this.changes;\n\n\tif ( !changes.length ) {\n\t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n\t\treturn;\n\t}\n\n\tfunction invalidateComputation ( computation ) {\n\t\tvar key = computation.key;\n\n\t\tif ( computation.viewmodel === self ) {\n\t\t\tself.clearCache( key.str );\n\t\t\tcomputation.invalidate();\n\n\t\t\tchanges.push( key );\n\t\t\tcascade( key );\n\t\t} else {\n\t\t\tcomputation.viewmodel.mark( key );\n\t\t}\n\t}\n\n\tfunction cascade ( keypath ) {\n\t\tvar map, computations;\n\n\t\tif ( self.noCascade.hasOwnProperty( keypath.str ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( computations = self.deps.computed[ keypath.str ] ) {\n\t\t\tcomputations.forEach( invalidateComputation );\n\t\t}\n\n\t\tif ( map = self.depsMap.computed[ keypath.str ] ) {\n\t\t\tmap.forEach( cascade );\n\t\t}\n\t}\n\n\tchanges.slice().forEach( cascade );\n\n\tupstreamChanges = getUpstreamChanges( changes );\n\tupstreamChanges.forEach( keypath => {\n\t\tvar computations;\n\n\t\t// make sure we haven't already been down this particular keypath in this turn\n\t\tif ( changes.indexOf( keypath ) === -1 && ( computations = self.deps.computed[ keypath.str ] ) ) {\n\t\t\tcomputations.forEach( invalidateComputation );\n\t\t}\n\t});\n\n\tthis.changes = [];\n\n\t// Pattern observers are a weird special case\n\tif ( this.patternObservers.length ) {\n\t\tupstreamChanges.forEach( keypath => notifyPatternObservers( this, keypath, true ) );\n\t\tchanges.forEach( keypath => notifyPatternObservers( this, keypath ) );\n\t}\n\n\tif ( this.deps.observers ) {\n\t\tupstreamChanges.forEach( keypath => notifyUpstreamDependants( this, null, keypath, 'observers' ) );\n\t\tnotifyAllDependants( this, changes, 'observers' );\n\t}\n\n\tif ( this.deps['default'] ) {\n\t\tbindings = [];\n\t\tupstreamChanges.forEach( keypath => notifyUpstreamDependants( this, bindings, keypath, 'default' ) );\n\n\t\tif( bindings.length ) {\n\t\t\tnotifyBindings( this, bindings, changes );\n\t\t}\n\n\t\tnotifyAllDependants( this, changes, 'default' );\n\t}\n\n\t// Return a hash of keypaths to updated values\n\tchanges.forEach( keypath => {\n\t\thash[ keypath.str ] = this.get( keypath );\n\t});\n\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\treturn hash;\n}\n\nfunction notifyUpstreamDependants ( viewmodel, bindings, keypath, groupName ) {\n\tvar dependants, value;\n\n\tif ( dependants = findDependants( viewmodel, keypath, groupName ) ) {\n\t\tvalue = viewmodel.get( keypath );\n\n\t\tdependants.forEach( d => {\n\t\t\t// don't \"set\" the parent value, refine it\n\t\t\t// i.e. not data = value, but data[foo] = fooValue\n\t\t\tif( bindings && d.refineValue ) {\n\t\t\t\tbindings.push( d );\n\t\t\t}\n\t\t\telse {\n\t\t\t\td.setValue( value );\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction notifyBindings ( viewmodel, bindings, changes ) {\n\n\tbindings.forEach( binding => {\n\t\tlet useSet = false, i = 0, length = changes.length, refinements = [];\n\n\t\twhile( i < length ) {\n\t\t\tlet keypath = changes[i];\n\n\t\t\tif ( keypath === binding.keypath ) {\n\t\t\t\tuseSet = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ( keypath.slice(0, binding.keypath.length) === binding.keypath ) {\n\t\t\t\trefinements.push( keypath );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tif ( useSet ) {\n\t\t\tbinding.setValue( viewmodel.get( binding.keypath ) );\n\t\t}\n\n\t\tif( refinements.length ) {\n\t\t\tbinding.refineValue( refinements );\n\t\t}\n\t});\n}\n\n\nfunction notifyAllDependants ( viewmodel, keypaths, groupName ) {\n\tvar queue = [];\n\n\taddKeypaths( keypaths );\n\tqueue.forEach( dispatch );\n\n\tfunction addKeypaths ( keypaths ) {\n\t\tkeypaths.forEach( addKeypath );\n\t\tkeypaths.forEach( cascade );\n\t}\n\n\tfunction addKeypath ( keypath ) {\n\t\tvar deps = findDependants( viewmodel, keypath, groupName );\n\n\t\tif ( deps ) {\n\t\t\tqueue.push({\n\t\t\t\tkeypath: keypath,\n\t\t\t\tdeps: deps\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction cascade ( keypath ) {\n\t\tvar childDeps;\n\n\t\tif ( childDeps = viewmodel.depsMap[ groupName ][ keypath.str ] ) {\n\t\t\taddKeypaths( childDeps );\n\t\t}\n\t}\n\n\tfunction dispatch ( set ) {\n\t\tvar value = viewmodel.get( set.keypath );\n\t\tset.deps.forEach( d => d.setValue( value ) );\n\t}\n}\n\nfunction findDependants ( viewmodel, keypath, groupName ) {\n\tvar group = viewmodel.deps[ groupName ];\n\treturn group ? group[ keypath.str ] : null;\n}\n","export default notifyPatternObservers;\n\nfunction notifyPatternObservers ( viewmodel, keypath, onlyDirect ) {\n\tvar potentialWildcardMatches;\n\n\tupdateMatchingPatternObservers( viewmodel, keypath );\n\n\tif ( onlyDirect ) {\n\t\treturn;\n\t}\n\n\tpotentialWildcardMatches = keypath.wildcardMatches();\n\tpotentialWildcardMatches.forEach( upstreamPattern => {\n\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t});\n}\n\n\nfunction cascade ( viewmodel, upstreamPattern, keypath ) {\n\tvar group, map, actualChildKeypath;\n\n\t// TODO should be one or the other\n\tupstreamPattern = ( upstreamPattern.str || upstreamPattern );\n\n\tgroup = viewmodel.depsMap.patternObservers;\n\tmap = group && group[ upstreamPattern ];\n\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\tmap.forEach( childKeypath => {\n\t\tactualChildKeypath = keypath.join( childKeypath.lastKey ); // 'foo.bar.baz'\n\n\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t});\n}\n\nfunction updateMatchingPatternObservers ( viewmodel, keypath ) {\n\tviewmodel.patternObservers.forEach( observer => {\n\t\tif ( observer.regex.test( keypath.str ) ) {\n\t\t\tobserver.update( keypath );\n\t\t}\n\t});\n}\n","import { addToArray } from 'utils/array';\nimport { rootKeypath } from 'shared/keypaths'; // TEMP\n\nexport default function getUpstreamChanges ( changes ) {\n\tvar upstreamChanges = [ rootKeypath ], i, keypath;\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tkeypath = changes[i].parent;\n\n\t\twhile ( keypath && !keypath.isRoot ) {\n\t\t\tif( changes.indexOf(keypath) === -1 ) {\n\t\t\t\taddToArray( upstreamChanges, keypath );\n\t\t\t}\n\t\t\tkeypath = keypath.parent;\n\t\t}\n\t}\n\n\treturn upstreamChanges;\n}\n","var prefixers = {};\n\nexport default function Viewmodel$adapt ( keypath, value ) {\n\tvar len, i, adaptor, wrapped;\n\n\tif ( !this.adaptors ) return;\n\n\t// Do we have an adaptor for this value?\n\tlen = this.adaptors.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tadaptor = this.adaptors[i];\n\n\t\tif ( adaptor.filter( value, keypath, this.ractive ) ) {\n\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( this.ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\twrapped.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nfunction prefixKeypath ( obj, prefix ) {\n\tvar prefixed = {}, key;\n\n\tif ( !prefix ) {\n\t\treturn obj;\n\t}\n\n\tprefix += '.';\n\n\tfor ( key in obj ) {\n\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn prefixed;\n}\n\nfunction getPrefixer ( rootKeypath ) {\n\tvar rootDot;\n\n\tif ( !prefixers[ rootKeypath ] ) {\n\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\tvar obj;\n\n\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t}\n\t\t};\n\t}\n\n\treturn prefixers[ rootKeypath ];\n}\n","import magicAdaptor from './magic';\nimport arrayAdaptor from './array/index';\n\nvar magicArrayAdaptor, MagicArrayWrapper;\n\nif ( magicAdaptor ) {\n\tmagicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tMagicArrayWrapper = function ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t};\n\n\tMagicArrayWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t},\n\t\treset: function ( value ) {\n\t\t\treturn this.magicWrapper.reset( value );\n\t\t}\n\t};\n}\n\nexport default magicArrayAdaptor;\n","import runloop from 'global/runloop';\nimport createBranch from 'utils/createBranch';\nimport { getKeypath } from 'shared/keypaths';\nimport { isArray } from 'utils/is';\n\nvar magicAdaptor, MagicWrapper;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tmagicAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\tvar parentWrapper, parentValue;\n\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tkeypath = getKeypath( keypath );\n\n\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t// we shouldn't wrap this property\n\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ keypath.parent.str ] ) && !parentWrapper.magic ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparentValue = ractive.viewmodel.get( keypath.parent );\n\n\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( keypath.lastKey ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) );\n\t\t},\n\t\twrap: function ( ractive, property, keypath ) {\n\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t}\n\t};\n\n\tMagicWrapper = function ( ractive, value, keypath ) {\n\t\tvar objKeypath, template, siblings;\n\n\t\tkeypath = getKeypath( keypath );\n\n\t\tthis.magic = true;\n\n\t\tthis.ractive = ractive;\n\t\tthis.keypath = keypath;\n\t\tthis.value = value;\n\n\t\tthis.prop = keypath.lastKey;\n\n\t\tobjKeypath = keypath.parent;\n\t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get( objKeypath );\n\n\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\n\t\t// Has this property already been wrapped?\n\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\tsiblings.push( this );\n\t\t\t}\n\n\t\t\treturn; // already wrapped\n\t\t}\n\n\t\t// No, it hasn't been wrapped\n\t\tcreateAccessors( this, value, template );\n\t};\n\n\tMagicWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\treset: function ( value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updating = true;\n\t\t\tthis.obj[ this.prop ] = value; // trigger set() accessor\n\t\t\trunloop.addRactive( this.ractive );\n\t\t\tthis.ractive.viewmodel.mark( this.keypath, { keepExistingWrapper: true } );\n\t\t\tthis.updating = false;\n\t\t\treturn true;\n\t\t},\n\t\tset: function ( key, value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\n\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tvar template, set, value, wrappers, index;\n\n\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t// so that it doesn't get torn down\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\tset = template && template.set;\n\n\t\t\tif ( !set ) {\n\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twrappers = set._ractiveWrappers;\n\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t}\n\n\t\t\t// Last one out, turn off the lights\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tvalue = this.obj[ this.prop ];\n\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t}\n\t\t}\n\t};\n} catch ( err ) {\n\tmagicAdaptor = false; // no magic in this browser\n}\n\nexport default magicAdaptor;\n\nfunction createAccessors ( originalWrapper, value, template ) {\n\n\tvar object, property, oldGet, oldSet, get, set;\n\n\tobject = originalWrapper.obj;\n\tproperty = originalWrapper.prop;\n\n\t// Is this template configurable?\n\tif ( template && !template.configurable ) {\n\t\t// Special case - array length\n\t\tif ( property === 'length' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t}\n\n\n\t// Time to wrap this property\n\tif ( template ) {\n\t\toldGet = template.get;\n\t\toldSet = template.set;\n\t}\n\n\tget = oldGet || function () {\n\t\treturn value;\n\t};\n\n\tset = function ( v ) {\n\t\tif ( oldSet ) {\n\t\t\toldSet( v );\n\t\t}\n\n\t\tvalue = oldGet ? oldGet() : v;\n\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t};\n\n\tfunction updateWrapper ( wrapper ) {\n\t\tvar keypath, ractive;\n\n\t\twrapper.value = value;\n\n\t\tif ( wrapper.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tractive = wrapper.ractive;\n\t\tkeypath = wrapper.keypath;\n\n\t\twrapper.updating = true;\n\t\trunloop.start( ractive );\n\n\t\tractive.viewmodel.mark( keypath );\n\n\t\trunloop.end();\n\t\twrapper.updating = false;\n\t}\n\n\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\tset._ractiveWrappers = [ originalWrapper ];\n\tObject.defineProperty( object, property, { get: get, set: set, enumerable: true, configurable: true });\n}\n","var numeric = /^\\s*[0-9]+\\s*$/;\n\nexport default function ( key ) {\n\treturn numeric.test( key ) ? [] : {};\n}\n","import { defineProperty } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport { getKeypath } from 'shared/keypaths';\nimport patch from './patch';\n\nvar arrayAdaptor,\n\n\t// helpers\n\tArrayWrapper,\n\terrorMessage;\n\narrayAdaptor = {\n\tfilter: function ( object ) {\n\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t// or the array didn't trigger the get() itself\n\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t},\n\twrap: function ( ractive, array, keypath ) {\n\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t}\n};\n\nArrayWrapper = function ( ractive, array, keypath ) {\n\tthis.root = ractive;\n\tthis.value = array;\n\tthis.keypath = getKeypath( keypath );\n\n\t// if this array hasn't already been ractified, ractify it\n\tif ( !array._ractive ) {\n\n\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\tdefineProperty( array, '_ractive', {\n\t\t\tvalue: {\n\t\t\t\twrappers: [],\n\t\t\t\tinstances: [],\n\t\t\t\tsetting: false\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tpatch( array );\n\t}\n\n\t// store the ractive instance, so we can handle transitions later\n\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\tarray._ractive.instances.push( ractive );\n\t}\n\n\tarray._ractive.instances[ ractive._guid ] += 1;\n\tarray._ractive.wrappers.push( this );\n};\n\nArrayWrapper.prototype = {\n\tget: function () {\n\t\treturn this.value;\n\t},\n\tteardown: function () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n};\n\nerrorMessage = 'Something went wrong in a rather interesting way';\nexport default arrayAdaptor;\n","import runloop from 'global/runloop';\nimport { defineProperty } from 'utils/object';\nimport getNewIndices from 'shared/getNewIndices';\nimport processWrapper from './processWrapper';\n\nvar patchedArrayProto = [],\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ],\n\ttestObj,\n\tpatchArrayMethods,\n\tunpatchArrayMethods;\n\nmutatorMethods.forEach( function ( methodName ) {\n\tvar method = function ( ...args ) {\n\t\tvar newIndices,\n\t\t\tresult,\n\t\t\twrapper,\n\t\t\ti;\n\n\t\tnewIndices = getNewIndices( this, methodName, args );\n\n\t\t// apply the underlying method\n\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t// trigger changes\n\t\trunloop.start();\n\n\t\tthis._ractive.setting = true;\n\t\ti = this._ractive.wrappers.length;\n\t\twhile ( i-- ) {\n\t\t\twrapper = this._ractive.wrappers[i];\n\n\t\t\trunloop.addRactive( wrapper.root );\n\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tthis._ractive.setting = false;\n\t\treturn result;\n\t};\n\n\tdefineProperty( patchedArrayProto, methodName, {\n\t\tvalue: method\n\t});\n});\n\n// can we use prototype chain injection?\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\ntestObj = {};\n\nif ( testObj.__proto__ ) {\n\t// yes, we can\n\tpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = patchedArrayProto;\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = Array.prototype;\n\t};\n}\n\nelse {\n\t// no, we can't\n\tpatchArrayMethods = function ( array ) {\n\t\tvar i, methodName;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tmethodName = mutatorMethods[i];\n\t\t\tdefineProperty( array, methodName, {\n\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tvar i;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t}\n\t};\n}\n\npatchArrayMethods.unpatch = unpatchArrayMethods;\nexport default patchArrayMethods;\n","export default function ( wrapper, array, methodName, newIndices ) {\n\tvar { root, keypath } = wrapper;\n\n\tif ( !!newIndices ) {\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t} else {\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\troot.viewmodel.mark( keypath );\n\t}\n}\n","export default function Component$firstNode () {\n\tif ( this.rendered ) {\n\t\treturn this.instance.fragment.firstNode();\n\t}\n\n\treturn null;\n}\n","export default function Component$findNextNode () {\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Component$findComponent ( selector ) {\n\tif ( !selector || ( selector === this.name ) ) {\n\t\treturn this.instance;\n\t}\n\n\tif ( this.instance.fragment ) {\n\t\treturn this.instance.fragment.findComponent( selector );\n\t}\n\n\treturn null;\n}\n","export default function Component$findAllComponents ( selector, query ) {\n\tquery._test( this, true );\n\n\tif ( this.instance.fragment ) {\n\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function Component$findAll ( selector, query ) {\n\treturn this.instance.fragment.findAll( selector, query );\n}\n","export default function Component$find ( selector ) {\n\treturn this.instance.fragment.find( selector );\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Component$detach () {\n\tvar detached = this.instance.fragment.detach();\n\tdetachHook.fire( this.instance );\n\treturn detached;\n}\n","import { noRegistryFunctionReturn } from 'config/errors';\nimport { warnIfDebug } from 'utils/log';\nimport { findInstance } from 'shared/registry';\n\n// finds the component constructor in the registry or view hierarchy registries\n\nexport default function getComponent ( ractive, name ) {\n\n\tvar Component, instance = findInstance( 'components', ractive, name );\n\n\tif ( instance ) {\n\t\tComponent = instance.components[ name ];\n\n\t\t// best test we have for not Ractive.extend\n\t\tif ( !Component._Parent ) {\n\t\t\t// function option, execute and store for reset\n\t\t\tlet fn = Component.bind( instance );\n\t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t\t\tComponent = fn();\n\n\t\t\tif ( !Component ) {\n\t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive });\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( typeof Component === 'string' ) {\n\t\t\t\t// allow string lookup\n\t\t\t\tComponent = getComponent ( ractive, Component );\n\t\t\t}\n\n\t\t\tComponent._fn = fn;\n\t\t\tinstance.components[ name ] = Component;\n\t\t}\n\t}\n\n\treturn Component;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { PARTIAL, TEXT } from 'config/types';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\nimport Mustache from '../shared/Mustache/_Mustache';\nimport rebind from '../shared/Mustache/rebind';\nimport unbind from '../shared/unbind';\nimport getPartialTemplate from './getPartialTemplate';\nimport applyIndent from './applyIndent';\n\nlet missingPartialMessage = 'Could not find template for partial \"%s\"';\n\nlet Partial = function ( options ) {\n\tvar parentFragment, template;\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\n\tthis.root = parentFragment.root;\n\tthis.type = PARTIAL;\n\tthis.index = options.index;\n\tthis.name = options.template.r;\n\tthis.rendered = false;\n\n\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n\tMustache.init( this, options );\n\n\t// If this didn't resolve, it most likely means we have a named partial\n\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t// whose name is the value of `foo`')\n\tif ( !this.keypath ) {\n\t\tif ( template = getPartialTemplate( this.root, this.name, parentFragment ) ) {\n\t\t\tunbind.call( this ); // prevent any further changes\n\t\t\tthis.isNamed = true;\n\t\t\tthis.setTemplate( template );\n\t\t} else {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name );\n\t\t}\n\t}\n};\n\nPartial.prototype = {\n\tbubble () {\n\t\tthis.parentFragment.bubble();\n\t},\n\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tfindNextNode () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t},\n\n\tgetPartialName () {\n\t\tif ( this.isNamed && this.name ) return this.name;\n\t\telse if ( this.value === undefined ) return this.name;\n\t\telse return this.value;\n\t},\n\n\tgetValue () {\n\t\treturn this.fragment.getValue();\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// named partials aren't bound, so don't rebind\n\t\tif ( !this.isNamed ) {\n\t\t\trebind.call( this, oldKeypath, newKeypath );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\trender () {\n\t\tthis.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\n\t\tthis.rendered = true;\n\t\treturn this.docFrag;\n\t},\n\n\tresolve: Mustache.resolve,\n\n\tsetValue ( value ) {\n\t\tvar template;\n\n\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t// nothing has changed, so no work to be done\n\t\t\treturn;\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\ttemplate = getPartialTemplate( this.root, '' + value, this.parentFragment );\n\t\t}\n\n\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t// and a partial. In those cases, this becomes a named partial\n\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name, this.parentFragment ) ) ) {\n\t\t\tunbind.call( this );\n\t\t\tthis.isNamed = true;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name, { ractive: this.root });\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.setTemplate( template || [] );\n\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tsetTemplate ( template ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t}\n\t\t}\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate,\n\t\t\troot: this.root,\n\t\t\towner: this,\n\t\t\tpElement: this.parentFragment.pElement\n\t\t});\n\n\t\tthis.fragmentToRender = this.fragment;\n\t},\n\n\ttoString ( toString ) {\n\t\tvar string, previousItem, lastLine, match;\n\n\t\tstring = this.fragment.toString( toString );\n\n\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\n\t\tif ( !previousItem || ( previousItem.type !== TEXT ) ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\n\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\treturn applyIndent( string, match[0] );\n\t\t}\n\n\t\treturn string;\n\t},\n\n\tunbind () {\n\t\tif ( !this.isNamed ) { // dynamic partial - need to unbind self\n\t\t\tunbind.call( this );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( this.rendered ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t}\n\t},\n\n\tupdate() {\n\t\tvar target, anchor;\n\n\t\tif ( this.fragmentToUnrender ) {\n\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\tthis.fragmentToUnrender = null;\n\t\t}\n\n\t\tif ( this.fragmentToRender ) {\n\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\tthis.fragmentToRender = null;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t}\n};\n\nexport default Partial;\n","export default function ( string, indent ) {\n\tvar indented;\n\n\tif ( !indent ) {\n\t\treturn string;\n\t}\n\n\tindented = string.split( '\\n' ).map( function ( line, notFirstLine ) {\n\t\treturn notFirstLine ? indent + line : line;\n\t}).join( '\\n' );\n\n\treturn indented;\n}\n","import { noRegistryFunctionReturn } from 'config/errors';\nimport { warnIfDebug } from 'utils/log';\nimport parser from 'Ractive/config/custom/template/parser';\nimport { findInstance } from 'shared/registry';\nimport deIndent from './deIndent';\n\nexport default function getPartialTemplate ( ractive, name, parentFragment ) {\n\tvar partial;\n\n\t// If the partial in instance or view heirarchy instances, great\n\tif ( partial = getPartialFromRegistry( ractive, name, parentFragment || {} ) ) {\n\t\treturn partial;\n\t}\n\n\t// Does it exist on the page as a script tag?\n\tpartial = parser.fromId( name, { noThrow: true } );\n\n\tif ( partial ) {\n\t\t// is this necessary?\n\t\tpartial = deIndent( partial );\n\n\t\t// parse and register to this ractive instance\n\t\tlet parsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\n\t\t// register (and return main partial if there are others in the template)\n\t\treturn ractive.partials[ name ] = parsed.t;\n\t}\n}\n\nfunction getPartialFromRegistry ( ractive, name, parentFragment ) {\n\tlet fn, partial = findParentPartial( name, parentFragment.owner );\n\n\t// if there was an instance up-hierarchy, cool\n\tif ( partial ) return partial;\n\n\t// find first instance in the ractive or view hierarchy that has this partial\n\tvar instance = findInstance( 'partials', ractive, name );\n\n\tif ( !instance ) { return; }\n\n\tpartial = instance.partials[ name ];\n\n\t// partial is a function?\n\tif ( typeof partial === 'function' ) {\n\t\tfn = partial.bind( instance );\n\t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n\t\tpartial = fn.call( ractive, parser );\n\t}\n\n\tif ( !partial && partial !== '' ) {\n\t\twarnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive });\n\t\treturn;\n\t}\n\n\t// If this was added manually to the registry,\n\t// but hasn't been parsed, parse it now\n\tif ( !parser.isParsed( partial ) ) {\n\n\t\t// use the parseOptions of the ractive instance on which it was found\n\t\tlet parsed = parser.parse( partial, parser.getParseOptions( instance ) );\n\n\t\t// Partials cannot contain nested partials!\n\t\t// TODO add a test for this\n\t\tif ( parsed.p ) {\n\t\t\twarnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive });\n\t\t}\n\n\t\t// if fn, use instance to store result, otherwise needs to go\n\t\t// in the correct point in prototype chain on instance or constructor\n\t\tlet target = fn ? instance : findOwner( instance, name );\n\n\t\t// may be a template with partials, which need to be registered and main template extracted\n\t\ttarget.partials[ name ] = partial = parsed.t;\n\t}\n\n\t// store for reset\n\tif ( fn ) {\n\t\tpartial._fn = fn;\n\t}\n\n\treturn partial.v ? partial.t : partial;\n}\n\nfunction findOwner ( ractive, key ) {\n\treturn ractive.partials.hasOwnProperty( key )\n\t\t? ractive\n\t\t: findConstructor( ractive.constructor, key);\n}\n\nfunction findConstructor ( constructor, key ) {\n\tif ( !constructor ) { return; }\n\treturn constructor.partials.hasOwnProperty( key )\n\t\t? constructor\n\t\t: findConstructor( constructor._Parent, key );\n}\n\nfunction findParentPartial( name, parent ) {\n\tif ( parent ) {\n\t\tif ( parent.template && parent.template.p && parent.template.p[name] ) {\n\t\t\treturn parent.template.p[name];\n\t\t} else if ( parent.parentFragment && parent.parentFragment.owner ) {\n\t\t\treturn findParentPartial( name, parent.parentFragment.owner );\n\t\t}\n\t}\n}\n","import { lastItem } from 'utils/array';\n\nvar empty = /^\\s*$/, leadingWhitespace = /^\\s*/;\n\nexport default function ( str ) {\n\tvar lines, firstLine, lastLine, minIndent;\n\n\tlines = str.split( '\\n' );\n\n\t// remove first and last line, if they only contain whitespace\n\tfirstLine = lines[0];\n\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\tlines.shift();\n\t}\n\n\tlastLine = lastItem( lines );\n\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\tlines.pop();\n\t}\n\n\tminIndent = lines.reduce( reducer, null );\n\n\tif ( minIndent ) {\n\t\tstr = lines.map( function ( line ) {\n\t\t\treturn line.replace( minIndent, '' );\n\t\t}).join( '\\n' );\n\t}\n\n\treturn str;\n}\n\nfunction reducer ( previous, line ) {\n\tvar lineIndent = leadingWhitespace.exec( line )[0];\n\n\tif ( previous === null || ( lineIndent.length < previous.length ) ) {\n\t\treturn lineIndent;\n\t}\n\n\treturn previous;\n}\n","import bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport getAttribute from './prototype/getAttribute';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Element = function ( options ) {\n\tthis.init( options );\n};\n\nElement.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetAttribute: getAttribute,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Element;\n","import runloop from 'global/runloop';\nimport Transition from '../Transition/_Transition';\nimport { unrender as unrenderForm } from '../special/form';\nimport { unrender } from 'shared/methodCallers';\n\nexport default function Element$unrender ( shouldDestroy ) {\n\tvar binding, bindings, transition;\n\n\tif ( transition = this.transition ) {\n\t\ttransition.complete();\n\t}\n\n\t// Detach as soon as we can\n\tif ( this.name === 'option' ) {\n\t\t// <option> elements detach immediately, so that\n\t\t// their parent <select> element syncs correctly, and\n\t\t// since option elements can't have transitions anyway\n\t\tthis.detach();\n\t} else if ( shouldDestroy ) {\n\t\trunloop.detachWhenReady( this );\n\t}\n\n\t// Children first. that way, any transitions on child elements will be\n\t// handled by the current transitionManager\n\tif ( this.fragment ) {\n\t\tthis.fragment.unrender( false );\n\t}\n\n\tif ( binding = this.binding ) {\n\t\tthis.binding.unrender();\n\n\t\tthis.node._ractive.binding = null;\n\t\tbindings = this.root._twowayBindings[ binding.keypath.str ];\n\t\tbindings.splice( bindings.indexOf( binding ), 1 );\n\t}\n\n\t// Remove event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( unrender );\n\t}\n\n\tif ( this.decorator ) {\n\t\trunloop.registerDecorator( this.decorator );\n\t}\n\n\t// trigger outro transition if necessary\n\tif ( this.root.transitionsEnabled && this.outro ) {\n\t\ttransition = new Transition( this, this.outro, false );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start() );\n\t}\n\n\t// Remove this node from any live queries\n\tif ( this.liveQueries ) {\n\t\tremoveFromLiveQueries( this );\n\t}\n\n\tif ( this.name === 'form' ) {\n\t\tunrenderForm( this );\n\t}\n}\n\nfunction removeFromLiveQueries ( element ) {\n\tvar query, selector, i;\n\n\ti = element.liveQueries.length;\n\twhile ( i-- ) {\n\t\tquery = element.liveQueries[i];\n\t\tselector = query.selector;\n\n\t\tquery._remove( element.node );\n\t}\n}\n","import { unbind as unbindOption } from 'virtualdom/items/Element/special/option';\nimport { unbind } from 'shared/methodCallers';\n\nexport default function Element$unbind () {\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.binding ) {\n\t\tthis.binding.unbind();\n\t}\n\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( unbind );\n\t}\n\n\t// Special case - <option>\n\tif ( this.name === 'option' ) {\n\t\tunbindOption( this );\n\t}\n\n\tthis.attributes.forEach( unbind );\n\tthis.conditionalAttributes.forEach( unbind );\n}\n","import { escapeHtml, voidElementNames } from 'utils/html';\nimport { isArray } from 'utils/is';\n\nexport default function () {\n\tvar str, escape;\n\n\tif ( this.template.y ) {\n\t\t// DOCTYPE declaration\n\t\treturn '<!DOCTYPE' + this.template.dd + '>';\n\t}\n\n\tstr = '<' + this.template.e;\n\n\tstr += this.attributes.map( stringifyAttribute ).join( '' )\n\t     + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\n\t// Special case - selected options\n\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\tstr += ' selected';\n\t}\n\n\t// Special case - two-way radio name bindings\n\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\tstr += ' checked';\n\t}\n\n\tstr += '>';\n\n\t// Special case - textarea\n\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t}\n\n\t// Special case - contenteditable\n\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t}\n\n\tif ( this.fragment ) {\n\t\tescape = ( this.name !== 'script' && this.name !== 'style' );\n\t\tstr += this.fragment.toString( escape );\n\t}\n\n\t// add a closing tag if this isn't a void element\n\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\tstr += '</' + this.template.e + '>';\n\t}\n\n\treturn str;\n}\n\nfunction optionIsSelected ( element ) {\n\tvar optionValue, selectValue, i;\n\n\toptionValue = element.getAttribute( 'value' );\n\n\tif ( optionValue === undefined || !element.select ) {\n\t\treturn false;\n\t}\n\n\tselectValue = element.select.getAttribute( 'value' );\n\n\tif ( selectValue == optionValue ) {\n\t\treturn true;\n\t}\n\n\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction inputIsCheckedRadio ( element ) {\n\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n\tattributes = element.attributes;\n\n\ttypeAttribute  = attributes.type;\n\tvalueAttribute = attributes.value;\n\tnameAttribute  = attributes.name;\n\n\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\treturn;\n\t}\n\n\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\treturn true;\n\t}\n}\n\nfunction stringifyAttribute ( attribute ) {\n\tvar str = attribute.toString();\n\treturn str ? ' ' + str : '';\n}\n","import { namespaces } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport { warnIfDebug } from 'utils/log';\nimport { create, defineProperty } from 'utils/object';\nimport { createElement } from 'utils/dom';\nimport noop from 'utils/noop';\nimport runloop from 'global/runloop';\nimport getInnerContext from 'shared/getInnerContext';\nimport { render as renderImage } from '../special/img';\nimport { render as renderForm } from '../special/form';\nimport Transition from '../Transition/_Transition';\n\nvar updateCss, updateScript;\n\nupdateCss = function () {\n\tvar node = this.node, content = this.fragment.toString( false );\n\n\t// IE8 has no styleSheet unless there's a type text/css\n\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\tnode.type = 'text/css';\n\t}\n\n\tif ( node.styleSheet ) {\n\t\tnode.styleSheet.cssText = content;\n\t} else {\n\n\t\twhile ( node.hasChildNodes() ) {\n\t\t\tnode.removeChild( node.firstChild );\n\t\t}\n\n\t\tnode.appendChild( document.createTextNode(content) );\n\t}\n};\n\nupdateScript = function () {\n\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\twarnIfDebug( 'Script tag was updated. This does not cause the code to be re-evaluated!', { ractive: this.root });\n\t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n\t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n\t\t// But this would be a terrible idea with unpredictable results, so let's not.\n\t}\n\n\tthis.node.text = this.fragment.toString( false );\n};\n\nexport default function Element$render () {\n\tvar root = this.root, namespace, node, transition;\n\n\tnamespace = getNamespace( this );\n\tnode = this.node = createElement( this.name, namespace );\n\n\t// Is this a top-level node of a component? If so, we may need to add\n\t// a data-ractive-css attribute, for CSS encapsulation\n\tif ( this.parentFragment.cssIds ) {\n\t\tthis.node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( x => `{${x}}` ).join( ' ' ) );\n\t}\n\n\t// Add _ractive property to the node - we use this object to store stuff\n\t// related to proxy events, two-way bindings etc\n\tdefineProperty( this.node, '_ractive', {\n\t\tvalue: {\n\t\t\tproxy: this,\n\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\tevents: create( null ),\n\t\t\troot: root\n\t\t}\n\t});\n\n\t// Render attributes\n\tthis.attributes.forEach( a => a.render( node ) );\n\tthis.conditionalAttributes.forEach( a => a.render( node ) );\n\n\t// Render children\n\tif ( this.fragment ) {\n\t\t// Special case - <script> element\n\t\tif ( this.name === 'script' ) {\n\t\t\tthis.bubble = updateScript;\n\t\t\tthis.node.text = this.fragment.toString( false ); // bypass warning initially\n\t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n\t\t}\n\n\t\t// Special case - <style> element\n\t\telse if ( this.name === 'style' ) {\n\t\t\tthis.bubble = updateCss;\n\t\t\tthis.bubble();\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\t// Special case - contenteditable\n\t\telse if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\telse {\n\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\t// deal with two-way bindings\n\tif ( this.binding ) {\n\t\tthis.binding.render();\n\t\tthis.node._ractive.binding = this.binding;\n\t}\n\n\t// Add proxy event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( h => h.render() );\n\t}\n\n\tif ( this.name === 'option' ) {\n\t\tprocessOption( this );\n\t}\n\n\t// Special cases\n\tif ( this.name === 'img' ) {\n\t\t// if this is an <img>, and we're in a crap browser, we may\n\t\t// need to prevent it from overriding width and height when\n\t\t// it loads the src\n\t\trenderImage( this );\n\t} else if ( this.name === 'form' ) {\n\t\t// forms need to keep track of their bindings, in case of reset\n\t\trenderForm( this );\n\t} else if ( this.name === 'input' || this.name === 'textarea' ) {\n\t\t// inputs and textareas should store their initial value as\n\t\t// `defaultValue` in case of reset\n\t\tthis.node.defaultValue = this.node.value;\n\t} else if ( this.name === 'option' ) {\n\t\t// similarly for option nodes\n\t\tthis.node.defaultSelected = this.node.selected;\n\t}\n\n\t// apply decorator(s)\n\tif ( this.decorator && this.decorator.fn ) {\n\t\trunloop.scheduleTask( () => {\n\t\t\tif ( !this.decorator.torndown ) {\n\t\t\t\tthis.decorator.init();\n\t\t\t}\n\t\t}, true );\n\t}\n\n\t// trigger intro transition\n\tif ( root.transitionsEnabled && this.intro ) {\n\t\ttransition = new Transition ( this, this.intro, true );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start(), true );\n\n\t\tthis.transition = transition;\n\t}\n\n\tif ( this.node.autofocus ) {\n\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\trunloop.scheduleTask( () => this.node.focus(), true );\n\t}\n\n\tupdateLiveQueries( this );\n\treturn this.node;\n}\n\nfunction getNamespace ( element ) {\n\tvar namespace, xmlns, parent;\n\n\t// Use specified namespace...\n\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\tnamespace = xmlns;\n\t}\n\n\t// ...or SVG namespace, if this is an <svg> element\n\telse if ( element.name === 'svg' ) {\n\t\tnamespace = namespaces.svg;\n\t}\n\n\telse if ( parent = element.parent ) {\n\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\tnamespace = namespaces.html;\n\t\t}\n\n\t\t// ...or inherit from the parent node\n\t\telse {\n\t\t\tnamespace = parent.node.namespaceURI;\n\t\t}\n\t}\n\n\telse {\n\t\tnamespace = element.root.el.namespaceURI;\n\t}\n\n\treturn namespace;\n}\n\nfunction processOption ( option ) {\n\tvar optionValue, selectValue, i;\n\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\tselectValue = option.select.getAttribute( 'value' );\n\tif ( selectValue === undefined ) {\n\t\treturn;\n\t}\n\n\toptionValue = option.getAttribute( 'value' );\n\n\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( optionValue == selectValue[i] ) {\n\t\t\t\toption.node.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toption.node.selected = ( optionValue == selectValue );\n\t}\n}\n\nfunction updateLiveQueries ( element ) {\n\tvar instance, liveQueries, i, selector, query;\n\n\t// Does this need to be added to any live queries?\n\tinstance = element.root;\n\n\tdo {\n\t\tliveQueries = instance._liveQueries;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tselector = liveQueries[i];\n\t\t\tquery = liveQueries[ '_' + selector ];\n\n\t\t\tif ( query._test( element ) ) {\n\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t}\n\t\t}\n\t} while ( instance = instance.parent );\n}\n","import init from './prototype/init';\nimport getStyle from './prototype/getStyle';\nimport setStyle from './prototype/setStyle';\nimport animateStyle from './prototype/animateStyle/_animateStyle';\nimport processParams from './prototype/processParams';\nimport start from './prototype/start';\n\nvar Transition = function ( owner, template, isIntro ) {\n\tthis.init( owner, template, isIntro );\n};\n\nTransition.prototype = {\n\tinit: init,\n\tstart: start,\n\tgetStyle: getStyle,\n\tsetStyle: setStyle,\n\tanimateStyle: animateStyle,\n\tprocessParams: processParams\n};\n\nexport default Transition;\n","export default function Transition$start () {\n\tvar node, originalStyle, completed;\n\n\tnode = this.node = this.element.node;\n\toriginalStyle = node.getAttribute( 'style' );\n\n\t// create t.complete() - we don't want this on the prototype,\n\t// because we don't want `this` silliness when passing it as\n\t// an argument\n\tthis.complete = noReset => {\n\t\tif ( completed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !noReset && this.isIntro ) {\n\t\t\tresetStyle( node, originalStyle);\n\t\t}\n\n\t\tnode._ractive.transition = null;\n\t\tthis._manager.remove( this );\n\n\t\tcompleted = true;\n\t};\n\n\t// If the transition function doesn't exist, abort\n\tif ( !this._fn ) {\n\t\tthis.complete();\n\t\treturn;\n\t}\n\n\tthis._fn.apply( this.root, [ this ].concat( this.params ) );\n}\n\nfunction resetStyle ( node, style ) {\n\tif ( style ) {\n\t\tnode.setAttribute( 'style', style );\n\t} else {\n\n\t\t// Next line is necessary, to remove empty style attribute!\n\t\t// See http://stackoverflow.com/a/7167553\n\t\tnode.getAttribute( 'style' );\n\t\tnode.removeAttribute( 'style' );\n\t}\n}\n","import { fillGaps } from 'utils/object';\n\nexport default function ( params, defaults ) {\n\tif ( typeof params === 'number' ) {\n\t\tparams = { duration: params };\n\t}\n\n\telse if ( typeof params === 'string' ) {\n\t\tif ( params === 'slow' ) {\n\t\t\tparams = { duration: 600 };\n\t\t} else if ( params === 'fast' ) {\n\t\t\tparams = { duration: 200 };\n\t\t} else {\n\t\t\tparams = { duration: 400 };\n\t\t}\n\t} else if ( !params ) {\n\t\tparams = {};\n\t}\n\n\treturn fillGaps( {}, params, defaults );\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isClient } from 'config/environment';\nimport legacy from 'legacy';\nimport prefix from 'virtualdom/items/Element/Transition/helpers/prefix';\nimport Promise from 'utils/Promise';\nimport createTransitions from './createTransitions';\nimport visibility from './visibility';\n\nvar animateStyle, getComputedStyle, resolved;\n\nif ( !isClient ) {\n\tanimateStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tanimateStyle = function ( style, value, options ) {\n\t\tvar to;\n\n\t\tif ( arguments.length === 4 ) {\n\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t}\n\n\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t// that way you'll never get CSS transitionend events\n\t\tif ( visibility.hidden ) {\n\t\t\tthis.setStyle( style, value );\n\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t}\n\n\t\tif ( typeof style === 'string' ) {\n\t\t\tto = {};\n\t\t\tto[ style ] = value;\n\t\t} else {\n\t\t\tto = style;\n\n\t\t\t// shuffle arguments\n\t\t\toptions = value;\n\t\t}\n\n\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t// callback function that gets called after the animation completes\n\n\t\t// TODO remove this check in a future version\n\t\tif ( !options ) {\n\t\t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\toptions = this;\n\t\t}\n\n\t\tvar promise = new Promise( resolve => {\n\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\tif ( !options.duration ) {\n\t\t\t\tthis.setStyle( to );\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get a list of the properties we're animating\n\t\t\tpropertyNames = Object.keys( to );\n\t\t\tchangedProperties = [];\n\n\t\t\t// Store the current styles\n\t\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\t\tfrom = {};\n\t\t\ti = propertyNames.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = propertyNames[i];\n\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\n\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\tcurrent = 0;\n\t\t\t\t}\n\n\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\tchangedProperties.push( prop );\n\n\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\tthis.node.style[ prefix( prop ) ] = current;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t// will never fire! So we complete early\n\t\t\tif ( !changedProperties.length ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTransitions( this, to, options, changedProperties, resolve );\n\t\t});\n\n\t\treturn promise;\n\t};\n}\n\nexport default animateStyle;\n","import { vendors } from 'config/environment';\n\nvar hidden, vendor, prefix, i, visibility;\n\nif ( typeof document !== 'undefined' ) {\n\thidden = 'hidden';\n\n\tvisibility = {};\n\n\tif ( hidden in document ) {\n\t\tprefix = '';\n\t} else {\n\t\ti = vendors.length;\n\t\twhile ( i-- ) {\n\t\t\tvendor = vendors[i];\n\t\t\thidden = vendor + 'Hidden';\n\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = vendor;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( prefix !== undefined ) {\n\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\n\t\t// initialise\n\t\tonChange();\n\t}\n\n\telse {\n        // gah, we're in an old browser\n        if ( 'onfocusout' in document ) {\n        \tdocument.addEventListener( 'focusout', onHide );\n        \tdocument.addEventListener( 'focusin', onShow );\n        }\n\n        else {\n        \twindow.addEventListener( 'pagehide', onHide );\n        \twindow.addEventListener( 'blur', onHide );\n\n        \twindow.addEventListener( 'pageshow', onShow );\n        \twindow.addEventListener( 'focus', onShow );\n        }\n\n        visibility.hidden = false; // until proven otherwise. Not ideal but hey\n    }\n}\n\nfunction onChange () {\n\tvisibility.hidden = document[ hidden ];\n}\n\nfunction onHide () {\n\tvisibility.hidden = true;\n}\n\nfunction onShow () {\n\tvisibility.hidden = false;\n}\n\nexport default visibility;\n","import { isClient } from 'config/environment';\nimport { warnIfDebug } from 'utils/log';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\nimport interpolate from 'shared/interpolate';\nimport Ticker from 'shared/Ticker';\nimport prefix from '../../helpers/prefix';\nimport unprefix from '../../helpers/unprefix';\nimport hyphenate from '../../helpers/hyphenate';\n\nvar createTransitions,\n\ttestStyle,\n\tTRANSITION,\n\tTRANSITIONEND,\n\tCSS_TRANSITIONS_ENABLED,\n\tTRANSITION_DURATION,\n\tTRANSITION_PROPERTY,\n\tTRANSITION_TIMING_FUNCTION,\n\tcanUseCssTransitions = {},\n\tcannotUseCssTransitions = {};\n\nif ( !isClient ) {\n\tcreateTransitions = null;\n} else {\n\ttestStyle = createElement( 'div' ).style;\n\n\t// determine some facts about our environment\n\t(function() {\n\t\tif ( testStyle.transition !== undefined ) {\n\t\t\tTRANSITION = 'transition';\n\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\tTRANSITION = 'webkitTransition';\n\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else {\n\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t}\n\t}());\n\n\tif ( TRANSITION ) {\n\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t}\n\n\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t// TODO use a fastdom-style mechanism?\n\t\tsetTimeout( function () {\n\n\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n\t\t\tcheckComplete = function () {\n\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t// which properties\n\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\tt.node.style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n\t\t\ttransitionEndHandler = function ( event ) {\n\t\t\t\tvar index;\n\n\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t// still transitioning...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\tsetTimeout( function () {\n\t\t\t\tvar i = changedProperties.length, hash, originalValue, index, propertiesToTransitionInJs = [], prop, suffix;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\thash = hashPrefix + prop;\n\n\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\n\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\n\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t// javascript transitions\n\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\tvar prop, i;\n\n\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t}\n\n\n\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}, 0 );\n\t\t}, options.delay || 0 );\n\t};\n}\n\nexport default createTransitions;\n","import { vendors } from 'config/environment';\n\nvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\nexport default function ( str ) {\n\tvar hyphenated;\n\n\tif ( !str ) {\n\t\treturn ''; // edge case\n\t}\n\n\tif ( vendorPattern.test( str ) ) {\n\t\tstr = '-' + str;\n\t}\n\n\thyphenated = str.replace( /[A-Z]/g, function ( match ) {\n\t\treturn '-' + match.toLowerCase();\n\t});\n\n\treturn hyphenated;\n}\n","import { vendors } from 'config/environment';\n\nvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\nexport default function ( prop ) {\n\treturn prop.replace( unprefixPattern, '' );\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport getTime from 'utils/getTime';\nimport animations from 'shared/animations';\n\n// TODO what happens if a transition is aborted?\n// TODO use this with Animation to dedupe some code?\n\nvar Ticker = function ( options ) {\n\tvar easing;\n\n\tthis.duration = options.duration;\n\tthis.step = options.step;\n\tthis.complete = options.complete;\n\n\t// easing\n\tif ( typeof options.easing === 'string' ) {\n\t\teasing = options.root.easing[ options.easing ];\n\n\t\tif ( !easing ) {\n\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t\t\teasing = linear;\n\t\t}\n\t} else if ( typeof options.easing === 'function' ) {\n\t\teasing = options.easing;\n\t} else {\n\t\teasing = linear;\n\t}\n\n\tthis.easing = easing;\n\n\tthis.start = getTime();\n\tthis.end = this.start + this.duration;\n\n\tthis.running = true;\n\tanimations.add( this );\n};\n\nTicker.prototype = {\n\ttick: function ( now ) {\n\t\tvar elapsed, eased;\n\n\t\tif ( !this.running ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( now > this.end ) {\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( 1 );\n\t\t\t}\n\n\t\t\tif ( this.complete ) {\n\t\t\t\tthis.complete( 1 );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\telapsed = now - this.start;\n\t\teased = this.easing( elapsed / this.duration );\n\n\t\tif ( this.step ) {\n\t\t\tthis.step( eased );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tstop: function () {\n\t\tif ( this.abort ) {\n\t\t\tthis.abort();\n\t\t}\n\n\t\tthis.running = false;\n\t}\n};\n\nexport default Ticker;\nfunction linear ( t ) { return t; }\n","import prefix from '../helpers/prefix';\n\nexport default function ( style, value ) {\n\tvar prop;\n\n\tif ( typeof style === 'string' ) {\n\t\tthis.node.style[ prefix( style ) ] = value;\n\t}\n\n\telse {\n\t\tfor ( prop in style ) {\n\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n}\n","import legacy from 'legacy';\nimport { isClient } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport prefix from '../helpers/prefix';\n\nvar getStyle, getComputedStyle;\n\nif ( !isClient ) {\n\tgetStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tgetStyle = function ( props ) {\n\t\tvar computedStyle, styles, i, prop, value;\n\n\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\tif ( typeof props === 'string' ) {\n\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( !isArray( props ) ) {\n\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t}\n\n\t\tstyles = {};\n\n\t\ti = props.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = props[i];\n\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tstyles[ prop ] = value;\n\t\t}\n\n\t\treturn styles;\n\t};\n}\n\nexport default getStyle;\n","import { isClient, vendors } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\n\nvar prefix, prefixCache, testStyle;\n\nif ( !isClient ) {\n\tprefix = null;\n} else {\n\tprefixCache = {};\n\ttestStyle = createElement( 'div' ).style;\n\n\tprefix = function ( prop ) {\n\t\tvar i, vendor, capped;\n\n\t\tprop = camelCase( prop );\n\n\t\tif ( !prefixCache[ prop ] ) {\n\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// test vendors...\n\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[i];\n\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn prefixCache[ prop ];\n\t};\n}\n\nexport default prefix;\n","export default function ( hyphenatedStr ) {\n\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\treturn $1.toUpperCase();\n\t});\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nexport default function Transition$init ( element, template, isIntro ) {\n\tvar ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\tthis.isIntro = isIntro;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no transition\n\t\t\treturn;\n\t\t}\n\t}\n\n\tthis.name = name;\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t\t// 'dependency thrashing'?\n\t\tfragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = fragment.getArgsList();\n\t\tfragment.unbind();\n\t}\n\n\tthis._fn = findInViewHierarchy( 'transitions', ractive, name );\n\n\tif ( !this._fn ) {\n\t\twarnOnceIfDebug( missingPlugin( name, 'transition' ), { ractive: this.root });\n\t}\n}\n","import runloop from 'global/runloop';\n\nexport function render ( element ) {\n\telement.node.addEventListener( 'reset', handleReset, false);\n}\n\nexport function unrender ( element ) {\n\telement.node.removeEventListener( 'reset', handleReset, false);\n}\n\nfunction handleReset () {\n\tvar element = this._ractive.proxy;\n\n\trunloop.start();\n\telement.formBindings.forEach( updateModel );\n\trunloop.end();\n}\n\nfunction updateModel ( binding ) {\n\tbinding.root.viewmodel.set( binding.keypath, binding.resetValue );\n}","export function render ( img ) {\n\tvar loadHandler;\n\n\t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n\t// from overriding width and height when it loads the src\n\tif ( img.attributes.width || img.attributes.height ) {\n\t\timg.node.addEventListener( 'load', loadHandler = function () {\n\t\t\tvar width = img.getAttribute( 'width' ),\n\t\t\t\theight = img.getAttribute( 'height' );\n\n\t\t\tif ( width !== undefined ) {\n\t\t\t\timg.node.setAttribute('width', width);\n\t\t\t}\n\n\t\t\tif ( height !== undefined ) {\n\t\t\t\timg.node.setAttribute('height', height);\n\t\t\t}\n\n\t\t\timg.node.removeEventListener( 'load', loadHandler, false );\n\t\t}, false );\n\t}\n}\n","import { assignNewKeypath } from 'shared/keypaths';\n\nexport default function Element$rebind ( oldKeypath, newKeypath ) {\n\tvar i, storage, liveQueries, ractive;\n\n\tif ( this.attributes ) {\n\t\tthis.attributes.forEach( rebind );\n\t}\n\n\tif ( this.conditionalAttributes ) {\n\t\tthis.conditionalAttributes.forEach( rebind );\n\t}\n\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( rebind );\n\t}\n\n\tif ( this.decorator ) {\n\t\trebind( this.decorator );\n\t}\n\n\t// rebind children\n\tif ( this.fragment ) {\n\t\trebind( this.fragment );\n\t}\n\n\t// Update live queries, if necessary\n\tif ( liveQueries = this.liveQueries ) {\n\t\tractive = this.root;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tliveQueries[i]._makeDirty();\n\t\t}\n\t}\n\n\tif ( this.node && ( storage = this.node._ractive ) ) {\n\n\t\t// adjust keypath if needed\n\t\tassignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { ELEMENT } from 'config/types';\nimport processBindingAttributes from './init/processBindingAttributes';\nimport createAttributes from './init/createAttributes';\nimport createConditionalAttributes from './init/createConditionalAttributes';\nimport createTwowayBinding from './init/createTwowayBinding';\nimport createEventHandlers from './init/createEventHandlers';\nimport enforceCase from '../shared/enforceCase';\nimport Decorator from '../Decorator/_Decorator';\nimport { bubble as bubbleSelect } from '../special/select';\nimport { init as initOption } from '../special/option';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Element$init ( options ) {\n\tvar parentFragment,\n\t\ttemplate,\n\t\tractive,\n\t\tbinding,\n\t\tbindings,\n\t\ttwoway,\n\t\tbindingAttrs;\n\n\tthis.type = ELEMENT;\n\n\t// stuff we'll need later\n\tparentFragment = this.parentFragment = options.parentFragment;\n\ttemplate = this.template = options.template;\n\n\tthis.parent = options.pElement || parentFragment.pElement;\n\n\tthis.root = ractive = parentFragment.root;\n\tthis.index = options.index;\n\tthis.key = options.key;\n\n\tthis.name = enforceCase( template.e );\n\n\t// Special case - <option> elements\n\tif ( this.name === 'option' ) {\n\t\tinitOption( this, template );\n\t}\n\n\t// Special case - <select> elements\n\tif ( this.name === 'select' ) {\n\t\tthis.options = [];\n\t\tthis.bubble = bubbleSelect; // TODO this is a kludge\n\t}\n\n\t// Special case - <form> elements\n\tif ( this.name === 'form' ) {\n\t\tthis.formBindings = [];\n\t}\n\n\t// handle binding attributes first (twoway, lazy)\n\tbindingAttrs = processBindingAttributes( this, template );\n\n\t// create attributes\n\tthis.attributes = createAttributes( this, template.a );\n\tthis.conditionalAttributes = createConditionalAttributes( this, template.m );\n\n\t// append children, if there are any\n\tif ( template.f ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.f,\n\t\t\troot:     ractive,\n\t\t\towner:    this,\n\t\t\tpElement: this,\n\t\t\tcssIds: null\n\t\t});\n\t}\n\n\t// the element setting should override the ractive setting\n\ttwoway = ractive.twoway;\n\tif ( bindingAttrs.twoway === false ) twoway = false;\n\telse if ( bindingAttrs.twoway === true ) twoway = true;\n\n\tthis.twoway = twoway;\n\tthis.lazy = bindingAttrs.lazy;\n\n\t// create twoway binding\n\tif ( twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {\n\t\tthis.binding = binding;\n\n\t\t// register this with the root, so that we can do ractive.updateModel()\n\t\tbindings = this.root._twowayBindings[ binding.keypath.str ] || ( this.root._twowayBindings[ binding.keypath.str ] = [] );\n\t\tbindings.push( binding );\n\t}\n\n\t// create event proxies\n\tif ( template.v ) {\n\t\tthis.eventHandlers = createEventHandlers( this, template.v );\n\t}\n\n\t// create decorator\n\tif ( template.o ) {\n\t\tthis.decorator = new Decorator( this, template.o );\n\t}\n\n\t// create transitions\n\tthis.intro = template.t0 || template.t1;\n\tthis.outro = template.t0 || template.t2;\n}\n","import { removeFromArray } from 'utils/array';\n\nexport function init ( option, template ) {\n\toption.select = findParentSelect( option.parent );\n\n\t// we might be inside a <datalist> element\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\toption.select.options.push( option );\n\n\t// If the value attribute is missing, use the element's content\n\tif ( !template.a ) {\n\t\ttemplate.a = {};\n\t}\n\n\t// ...as long as it isn't disabled\n\tif ( template.a.value === undefined && !template.a.hasOwnProperty( 'disabled' ) ) {\n\t\ttemplate.a.value = template.f;\n\t}\n\n\t// If there is a `selected` attribute, but the <select>\n\t// already has a value, delete it\n\tif ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {\n\t\tdelete template.a.selected;\n\t}\n}\n\nexport function unbind ( option ) {\n\tif ( option.select ) {\n\t\tremoveFromArray( option.select.options, option );\n\t}\n}\n\nfunction findParentSelect ( element ) {\n\tif ( !element ) { return; }\n\n\tdo {\n\t\tif ( element.name === 'select' ) {\n\t\t\treturn element;\n\t\t}\n\t} while ( element = element.parent );\n}\n","import { toArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nexport function bubble () {\n\tif ( !this.dirty ) {\n\t\tthis.dirty = true;\n\n\t\trunloop.scheduleTask( () => {\n\t\t\tsync( this );\n\t\t\tthis.dirty = false;\n\t\t});\n\t}\n\n\tthis.parentFragment.bubble(); // default behaviour\n}\n\nfunction sync ( selectElement ) {\n\tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n\tselectNode = selectElement.node;\n\n\tif ( !selectNode ) {\n\t\treturn;\n\t}\n\n\toptions = toArray( selectNode.options );\n\n\tselectValue = selectElement.getAttribute( 'value' );\n\tisMultiple = selectElement.getAttribute( 'multiple' );\n\n\t// If the <select> has a specified value, that should override\n\t// these options\n\tif ( selectValue !== undefined ) {\n\t\toptions.forEach( o => {\n\t\t\tvar optionValue, shouldSelect;\n\n\t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n\t\t\tshouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\n\t\t\tif ( shouldSelect ) {\n\t\t\t\toptionWasSelected = true;\n\t\t\t}\n\n\t\t\to.selected = shouldSelect;\n\t\t});\n\n\t\tif ( !optionWasSelected ) {\n\t\t\tif ( options[0] ) {\n\t\t\t\toptions[0].selected = true;\n\t\t\t}\n\n\t\t\tif ( selectElement.binding ) {\n\t\t\t\tselectElement.binding.forceUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Otherwise the value should be initialised according to which\n\t// <option> element is selected, if twoway binding is in effect\n\telse if ( selectElement.binding ) {\n\t\tselectElement.binding.forceUpdate();\n\t}\n}\n\nfunction valueContains ( selectValue, optionValue ) {\n\tvar i = selectValue.length;\n\twhile ( i-- ) {\n\t\tif ( selectValue[i] == optionValue ) {\n\t\t\treturn true;\n\t\t}\n\t}\n}\n","import { fatal } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar Decorator = function ( element, template ) {\n\tvar self = this, ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no decorator\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = this.fragment.getArgsList();\n\n\t\tthis.fragment.bubble = function () {\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tself.params = this.getArgsList();\n\n\t\t\tif ( self.ready ) {\n\t\t\t\tself.update();\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.fn = findInViewHierarchy( 'decorators', ractive, name );\n\n\tif ( !this.fn ) {\n\t\tfatal( missingPlugin( name, 'decorator' ) );\n\t}\n};\n\nDecorator.prototype = {\n\tinit: function () {\n\t\tvar node, result, args;\n\n\t\tnode = this.element.node;\n\n\t\tif ( this.params ) {\n\t\t\targs = [ node ].concat( this.params );\n\t\t\tresult = this.fn.apply( this.root, args );\n\t\t} else {\n\t\t\tresult = this.fn.call( this.root, node );\n\t\t}\n\n\t\tif ( !result || !result.teardown ) {\n\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t}\n\n\t\t// TODO does this make sense?\n\t\tthis.actual = result;\n\t\tthis.ready = true;\n\t},\n\n\tupdate: function () {\n\t\tif ( this.actual.update ) {\n\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t}\n\n\t\telse {\n\t\t\tthis.actual.teardown( true );\n\t\t\tthis.init();\n\t\t}\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tteardown: function ( updating ) {\n\t\tthis.torndown = true;\n\t\tif ( this.ready ) {\n\t\t\tthis.actual.teardown();\n\t\t}\n\n\t\tif ( !updating && this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t}\n};\n\nexport default Decorator;\n","import EventHandler from '../../EventHandler/_EventHandler';\n\nexport default function ( element, template ) {\n\tvar i, name, names, handler, result = [];\n\n\tfor ( name in template ) {\n\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\tnames = name.split( '-' );\n\t\t\ti = names.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\thandler = new EventHandler( element, names[i], template[ name ] );\n\t\t\t\tresult.push( handler );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n","import bubble from './prototype/bubble';\nimport fire from './prototype/fire';\nimport getAction from './prototype/getAction';\nimport init from './prototype/init';\nimport listen from './prototype/listen';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport resolve from './prototype/resolve';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar EventHandler = function ( element, name, template ) {\n\tthis.init( element, name, template );\n};\n\nEventHandler.prototype = {\n\tbubble: bubble,\n\tfire: fire,\n\tgetAction: getAction,\n\tinit: init,\n\tlisten: listen,\n\trebind: rebind,\n\trender: render,\n\tresolve: resolve,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default EventHandler;\n","import genericHandler from '../shared/genericHandler';\n\nexport default function EventHandler$unrender () {\n\n\tif ( this.custom ) {\n\t\tthis.custom.teardown();\n\t}\n\n\telse {\n\t\tthis.node.removeEventListener( this.name, genericHandler, false );\n\t}\n\n\tthis.hasListener = false;\n\n}\n","import { unbind } from 'shared/methodCallers';\n\nexport default function EventHandler$unbind () {\n\tif ( this.method ) {\n\t\tthis.refResolvers.forEach( unbind );\n\t\treturn;\n\t}\n\n\t// Tear down dynamic name\n\tif ( typeof this.action !== 'string' ) {\n\t\tthis.action.unbind();\n\t}\n\n\t// Tear down dynamic parameters\n\tif ( this.dynamicParams ) {\n\t\tthis.dynamicParams.unbind();\n\t}\n}\n","export default function EventHandler$resolve ( index, keypath ) {\n\tthis.keypaths[ index ] = keypath;\n}\n","export default function EventHandler$render () {\n\tthis.node = this.element.node;\n\t// store this on the node itself, so it can be retrieved by a\n\t// universal handler\n\tthis.node._ractive.events[ this.name ] = this;\n\n\tif ( this.method || this.getAction() ) {\n\t\tthis.listen();\n\t}\n}\n","export default function EventHandler$rebind ( oldKeypath, newKeypath ) {\n\tvar fragment;\n\tif ( this.method ) {\n\t\tfragment = this.element.parentFragment;\n\t\tthis.refResolvers.forEach( rebind );\n\n\t\treturn;\n\t}\n\n\tif ( typeof this.action !== 'string' ) {\n\t\trebind( this.action );\n\t}\n\n\tif ( this.dynamicParams ) {\n\t\trebind( this.dynamicParams );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing && thing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isJsdom } from 'config/environment';\nimport { missingPlugin } from 'config/errors';\nimport genericHandler from '../shared/genericHandler';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar customHandlers = {},\n\ttouchEvents = {\n\t\ttouchstart: true,\n\t\ttouchmove: true,\n\t\ttouchend: true,\n\t\ttouchcancel: true,\n\t\t//not w3c, but supported in some browsers\n\t\ttouchleave: true\n\t};\n\nexport default function EventHandler$listen () {\n\tvar definition, name = this.name;\n\n\tif ( this.invalid ) { return; }\n\n\tif ( definition = findInViewHierarchy( 'events', this.root, name ) ) {\n\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t} else {\n\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) && !isJsdom ) {\n\n\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\twarnOnceIfDebug( missingPlugin( name, 'event' ), { node: this.node });\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.addEventListener( name, genericHandler, false );\n\t}\n\n\tthis.hasListener = true;\n}\n\nfunction getCustomHandler ( name ) {\n\tif ( !customHandlers[ name ] ) {\n\t\tcustomHandlers[ name ] = function ( event ) {\n\t\t\tvar storage = event.node._ractive;\n\n\t\t\tevent.index = storage.index;\n\t\t\tevent.keypath = storage.keypath.str;\n\t\t\tevent.context = storage.root.viewmodel.get( storage.keypath );\n\n\t\t\tstorage.events[ name ].fire( event );\n\t\t};\n\t}\n\n\treturn customHandlers[ name ];\n}\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function genericHandler ( event ) {\n\tvar storage, handler, indices, index = {};\n\n\tstorage = this._ractive;\n\thandler = storage.events[ event.type ];\n\n\tif ( indices = findIndexRefs( handler.element.parentFragment ) ) {\n\t\tindex = findIndexRefs.resolve( indices );\n\t}\n\n\thandler.fire({\n\t\tnode: this,\n\t\toriginal: event,\n\t\tindex: index,\n\t\tkeypath: storage.keypath.str,\n\t\tcontext: storage.root.viewmodel.get( storage.keypath )\n\t});\n}\n","import getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport Fragment from 'virtualdom/Fragment';\nimport eventStack from 'Ractive/prototype/shared/eventStack';\nimport fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal } from 'utils/log';\n\nvar eventPattern = /^event(?:\\.(.+))?/;\n\nexport default function EventHandler$init ( element, name, template ) {\n\tvar action, refs, ractive;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\tthis.name = name;\n\n\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\tfatal( 'Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid', element.name, name );\n\t\tthis.invalid = true;\n\t}\n\n\tif ( template.m ) {\n\t\trefs = template.a.r;\n\n\t\t// This is a method call\n\t\tthis.method = template.m;\n\t\tthis.keypaths = [];\n\t\tthis.fn = getFunctionFromString( template.a.s, refs.length );\n\n\t\tthis.parentFragment = element.parentFragment;\n\t\tractive = this.root;\n\n\t\t// Create resolvers for each reference\n\t\tthis.refResolvers = [];\n\t\trefs.forEach(( ref, i ) => {\n\t\t\tlet match;\n\n\t\t\t// special case - the `event` object\n\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\tthis.keypaths[i] = {\n\t\t\t\t\teventObject: true,\n\t\t\t\t\trefinements: match[1] ? match[1].split( '.' ) : []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.refResolvers.push( createReferenceResolver( this, ref, keypath => this.resolve( i, keypath ) ) );\n\t\t\t}\n\t\t});\n\n\t\tthis.fire = fireMethodCall;\n\t}\n\n\telse {\n\t\t// Get action ('foo' in 'on-click='foo')\n\t\taction = template.n || template;\n\t\tif ( typeof action !== 'string' ) {\n\t\t\taction = new Fragment({\n\t\t\t\ttemplate: action,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tthis.action = action;\n\n\t\t// Get parameters\n\t\tif ( template.d ) {\n\t\t\tthis.dynamicParams = new Fragment({\n\t\t\t\ttemplate: template.d,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this.element\n\t\t\t});\n\n\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t} else if ( template.a ) {\n\t\t\tthis.params = template.a;\n\t\t\tthis.fire = fireEventWithParams;\n\t\t}\n\t}\n}\n\n\nfunction fireMethodCall ( event ) {\n\tvar ractive, values, args;\n\n\tractive = this.root;\n\n\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t}\n\n\tvalues = this.keypaths.map( function ( keypath ) {\n\t\tvar value, len, i;\n\n\t\tif ( keypath === undefined ) {\n\t\t\t// not yet resolved\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// TODO the refinements stuff would be better handled at parse time\n\t\tif ( keypath.eventObject ) {\n\t\t\tvalue = event;\n\n\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvalue = value[ keypath.refinements[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t}\n\n\t\treturn value;\n\t});\n\n\teventStack.enqueue( ractive, event );\n\n\targs = this.fn.apply( null, values );\n\tractive[ this.method ].apply( ractive, args );\n\n\teventStack.dequeue( ractive );\n}\n\nfunction fireEventWithParams ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event, args: this.params } );\n}\n\nfunction fireEventWithDynamicParams ( event ) {\n\tvar args = this.dynamicParams.getArgsList();\n\n\t// need to strip [] from ends if a string!\n\tif ( typeof args === 'string' ) {\n\t\targs = args.substr( 1, args.length - 2 );\n\t}\n\n\tfireEvent( this.root, this.getAction(), { event: event, args: args } );\n}\n","export default function EventHandler$getAction () {\n\treturn this.action.toString().trim();\n}\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\n\n// This function may be overwritten, if the event directive\n// includes parameters\nexport default function EventHandler$fire ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event } );\n}\n","export default function EventHandler$bubble () {\n\tvar hasAction = this.getAction();\n\n\tif( hasAction && !this.hasListener ) {\n\t\tthis.listen();\n\t}\n\telse if ( !hasAction && this.hasListener ) {\n\t\tthis.unrender();\n\t}\n}\n","import { warnIfDebug } from 'utils/log';\nimport ContentEditableBinding from '../../Binding/ContentEditableBinding';\nimport RadioBinding from '../../Binding/RadioBinding';\nimport RadioNameBinding from '../../Binding/RadioNameBinding';\nimport CheckboxNameBinding from '../../Binding/CheckboxNameBinding';\nimport CheckboxBinding from '../../Binding/CheckboxBinding';\nimport SelectBinding from '../../Binding/SelectBinding';\nimport MultipleSelectBinding from '../../Binding/MultipleSelectBinding';\nimport FileListBinding from '../../Binding/FileListBinding';\nimport NumericBinding from '../../Binding/NumericBinding';\nimport GenericBinding from '../../Binding/GenericBinding';\n\nexport default function createTwowayBinding ( element ) {\n\tvar attributes = element.attributes, type, Binding, bindName, bindChecked, binding;\n\n\t// if this is a late binding, and there's already one, it\n\t// needs to be torn down\n\tif ( element.binding ) {\n\t\telement.binding.teardown();\n\t\telement.binding = null;\n\t}\n\n\t// contenteditable\n\tif (\n\t\t// if the contenteditable attribute is true or is bindable and may thus become true\n\t\t( element.getAttribute( 'contenteditable' ) || ( !!attributes.contenteditable && isBindable( attributes.contenteditable ) ) )\n\t\t// and this element also has a value attribute to bind\n\t\t&& isBindable( attributes.value )\n\t) {\n\t\tBinding = ContentEditableBinding;\n\t}\n\n\t// <input>\n\telse if ( element.name === 'input' ) {\n\t\ttype = element.getAttribute( 'type' );\n\n\t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t\t\tbindName = isBindable( attributes.name );\n\t\t\tbindChecked = isBindable( attributes.checked );\n\n\t\t\t// we can either bind the name attribute, or the checked attribute - not both\n\t\t\tif ( bindName && bindChecked ) {\n\t\t\t\twarnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });\n\t\t\t}\n\n\t\t\tif ( bindName ) {\n\t\t\t\tBinding = ( type === 'radio' ? RadioNameBinding : CheckboxNameBinding );\n\t\t\t}\n\n\t\t\telse if ( bindChecked ) {\n\t\t\t\tBinding = ( type === 'radio' ? RadioBinding : CheckboxBinding );\n\t\t\t}\n\t\t}\n\n\t\telse if ( type === 'file' && isBindable( attributes.value ) ) {\n\t\t\tBinding = FileListBinding;\n\t\t}\n\n\t\telse if ( isBindable( attributes.value ) ) {\n\t\t\tBinding = ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n\t\t}\n\t}\n\n\t// <select>\n\telse if ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t\tBinding = ( element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding );\n\t}\n\n\t// <textarea>\n\telse if ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t\tBinding = GenericBinding;\n\t}\n\n\tif ( Binding && ( binding = new Binding( element ) ) && binding.keypath ) {\n\t\treturn binding;\n\t}\n}\n\nfunction isBindable ( attribute ) {\n\treturn attribute && attribute.isBindable;\n}\n","import GenericBinding from './GenericBinding';\n\nexport default GenericBinding.extend({\n\tgetInitialValue: () => undefined,\n\n\tgetValue: function () {\n\t\tvar value = parseFloat( this.element.node.value );\n\t\treturn isNaN( value ) ? undefined : value;\n\t}\n});\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar FileListBinding = Binding.extend({\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.files;\n\t}\n});\n\nexport default FileListBinding;\n","import runloop from 'global/runloop';\nimport { arrayContentsMatch } from 'utils/array';\nimport SelectBinding from './SelectBinding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar MultipleSelectBinding = SelectBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.options\n\t\t\t.filter( option => option.getAttribute( 'selected' ) )\n\t\t\t.map( option => option.getAttribute( 'value' ) );\n\t},\n\n\trender: function () {\n\t\tvar valueFromModel;\n\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\n\t\tif ( valueFromModel === undefined ) {\n\t\t\t// get value from DOM, if possible\n\t\t\tthis.handleChange();\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tsetValue: function () {\n\t\tthrow new Error( 'TODO not implemented yet' );\n\t},\n\n\tgetValue: function () {\n\t\tvar selectedValues, options, i, len, option, optionValue;\n\n\t\tselectedValues = [];\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i=0; i<len; i+=1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( option.selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\tselectedValues.push( optionValue );\n\t\t\t}\n\t\t}\n\n\t\treturn selectedValues;\n\t},\n\n\thandleChange: function () {\n\t\tvar attribute, previousValue, value;\n\n\t\tattribute = this.attribute;\n\t\tpreviousValue = attribute.value;\n\n\t\tvalue = this.getValue();\n\n\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t},\n\n\tupdateModel: function () {\n\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t}\n\t}\n});\n\nexport default MultipleSelectBinding;\n","import runloop from 'global/runloop';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar SelectBinding = Binding.extend({\n\tgetInitialValue: function () {\n\t\tvar options = this.element.options, len, i, value, optionWasSelected;\n\n\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\ti = len = options.length;\n\n\t\tif ( !len ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// take the final selected option...\n\t\twhile ( i-- ) {\n\t\t\tif ( options[i].getAttribute( 'selected' ) ) {\n\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\toptionWasSelected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// or the first non-disabled option, if none are selected\n\t\tif ( !optionWasSelected ) {\n\t\t\twhile ( ++i < len ) {\n\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t// other more expensive work\n\t\tif ( value !== undefined ) {\n\t\t\tthis.element.attributes.value.value = value;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\t// TODO this method is an anomaly... is it necessary?\n\tsetValue: function ( value ) {\n\t\tthis.root.viewmodel.set( this.keypath, value );\n\t},\n\n\tgetValue: function () {\n\t\tvar options, i, len, option, optionValue;\n\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( options[i].selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\treturn optionValue;\n\t\t\t}\n\t\t}\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t}\n});\n\nexport default SelectBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxBinding = Binding.extend({\n\tname: 'checked',\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t}\n});\n\nexport default CheckboxBinding;\n","import { isArray } from 'utils/is';\nimport { arrayContains, removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxNameBinding = Binding.extend({\n\tname: 'name',\n\n\tgetInitialValue: function () {\n\t\t// This only gets called once per group (of inputs that\n\t\t// share a name), because it only gets called if there\n\t\t// isn't an initial value. By the same token, we can make\n\t\t// a note of that fact that there was no initial value,\n\t\t// and populate it using any `checked` attributes that\n\t\t// exist (which users should avoid, but which we should\n\t\t// support anyway to avoid breaking expectations)\n\t\tthis.noInitialValue = true;\n\t\treturn [];\n\t},\n\n\tinit: function () {\n\t\tvar existingValue, bindingValue;\n\n\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n\t\t// Each input has a reference to an array containing it and its\n\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t// the status of all inputs within the group\n\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tif ( this.noInitialValue ) {\n\t\t\tthis.siblings.noInitialValue = true;\n\t\t}\n\n\t\t// If no initial value was set, and this input is checked, we\n\t\t// update the model\n\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\t\texistingValue.push( bindingValue );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, existingValue, bindingValue;\n\n\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\tif ( isArray( existingValue ) ) {\n\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t} else {\n\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t}\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.isChecked;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t// in case of IE emergency, bind to click event as well\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tchanged: function () {\n\t\tvar wasChecked = !!this.isChecked;\n\t\tthis.isChecked = this.element.node.checked;\n\t\treturn this.isChecked === wasChecked;\n\t},\n\n\thandleChange: function () {\n\t\tthis.isChecked = this.element.node.checked;\n\t\tBinding.prototype.handleChange.call( this );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t}\n});\n\nfunction isChecked ( binding ) {\n\treturn binding.isChecked;\n}\n\nfunction getValue ( binding ) {\n\treturn binding.element.getAttribute( 'value' );\n}\n\nexport default CheckboxNameBinding;\n","import { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport getSiblings from './shared/getSiblings';\n\nvar RadioNameBinding = Binding.extend({\n\tname: 'name',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n\t},\n\n\tgetInitialValue: function () {\n\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\treturn this.element.getAttribute( 'value' );\n\t\t}\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\tvar node = this.element.node;\n\t\treturn node._ractive ? node._ractive.value : node.value;\n\t},\n\n\thandleChange: function () {\n\t\t// If this <input> is the one that's checked, then the value of its\n\t\t// `name` keypath gets set to its value\n\t\tif ( this.element.node.checked ) {\n\t\t\tBinding.prototype.handleChange.call( this );\n\t\t}\n\t},\n\n\trebound: function ( oldKeypath, newKeypath ) {\n\t\tvar node;\n\n\t\tBinding.prototype.rebound.call( this, oldKeypath, newKeypath );\n\n\t\tif ( node = this.element.node ) {\n\t\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioNameBinding;\n","import runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar RadioBinding = Binding.extend({\n\tname: 'checked',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\tthis.siblings.push( this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\n\t\tthis.siblings.forEach( binding => {\n\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t});\n\n\t\trunloop.end();\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioBinding;\n","var sets = {};\n\nexport default function getSiblings ( id, group, keypath ) {\n\tvar hash = id + group + keypath;\n\treturn sets[ hash ] || ( sets[ hash ] = [] );\n}\n","import GenericBinding from './GenericBinding';\n\nvar ContentEditableBinding = GenericBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.innerHTML;\n\t}\n});\n\nexport default ContentEditableBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport { isNumeric } from 'utils/is';\n\nvar GenericBinding;\n\nGenericBinding = Binding.extend({\n\tgetInitialValue: () => '',\n\n\tgetValue: function () {\n\t\treturn this.element.node.value;\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, lazy, timeout = false;\n\t\tthis.rendered = true;\n\n\t\t// any lazy setting for this element overrides the root\n\t\t// if the value is a number, it's a timeout\n\t\tlazy = this.root.lazy;\n\t\tif ( this.element.lazy === true ) {\n\t\t\tlazy = true;\n\t\t} else if ( this.element.lazy === false ) {\n\t\t\tlazy = false;\n\t\t} else if ( isNumeric( this.element.lazy ) ) {\n\t\t\tlazy = false;\n\t\t\ttimeout = +this.element.lazy;\n\t\t} else if ( isNumeric( ( lazy || '' ) ) ) {\n\t\t\ttimeout = +lazy;\n\t\t\tlazy = false;\n\n\t\t\t// make sure the timeout is available to the handler\n\t\t\tthis.element.lazy = timeout;\n\t\t}\n\n\t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( !lazy ) {\n\t\t\tnode.addEventListener( 'input', this.handler, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\t\tthis.rendered = false;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t}\n});\n\nexport default GenericBinding;\n\n\nfunction handleBlur () {\n\tvar value;\n\n\thandleDomEvent.call( this );\n\n\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath );\n\tthis.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay () {\n\tvar binding = this._ractive.binding, el = this;\n\n\tif ( !!binding._timeout ) clearTimeout( binding._timeout );\n\n\tbinding._timeout = setTimeout( () => {\n\t\tif ( binding.rendered ) handleDomEvent.call( el );\n\t\tbinding._timeout = undefined;\n\t}, binding.element.lazy );\n}\n","// This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\nexport default function handleChange () {\n\tthis._ractive.binding.handleChange();\n}\n","import runloop from 'global/runloop';\nimport { warnIfDebug, warnOnceIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { removeFromArray } from 'utils/array';\n\nvar Binding = function ( element ) {\n\tvar interpolator, keypath, value, parentForm;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.attribute = element.attributes[ this.name || 'value' ];\n\n\tinterpolator = this.attribute.interpolator;\n\tinterpolator.twowayBinding = this;\n\n\tif ( keypath = interpolator.keypath ) {\n\t\tif ( keypath.str.slice( -1 ) === '}' ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with expressions (`%s` on <%s>)', interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with %s', interpolator.resolver.ref, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\t}\n\n\telse {\n\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t//\n\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t// assumption. That assumption is that the input in question should\n\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t// and not `foo.bar`.\n\t\t//\n\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\tlet ref = interpolator.template.r ? `'${interpolator.template.r}' reference` : 'expression';\n\t\twarnIfDebug( 'The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity', ref, { ractive: this.root });\n\t\tinterpolator.resolver.forceResolution();\n\t\tkeypath = interpolator.keypath;\n\t}\n\n\tthis.attribute.isTwoway = true;\n\tthis.keypath = keypath;\n\n\t// initialise value, if it's undefined\n\tvalue = this.root.viewmodel.get( keypath );\n\n\tif ( value === undefined && this.getInitialValue ) {\n\t\tvalue = this.getInitialValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t}\n\t}\n\n\tif ( parentForm = findParentForm( element ) ) {\n\t\tthis.resetValue = value;\n\t\tparentForm.formBindings.push( this );\n\t}\n};\n\nBinding.prototype = {\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\t\tthis.attribute.locked = true;\n\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\trunloop.end();\n\t},\n\n\trebound: function () {\n\t\tvar bindings, oldKeypath, newKeypath;\n\n\t\toldKeypath = this.keypath;\n\t\tnewKeypath = this.attribute.interpolator.keypath;\n\n\t\t// The attribute this binding is linked to has already done the work\n\t\tif ( oldKeypath === newKeypath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath.str ], this );\n\n\t\tthis.keypath = newKeypath;\n\n\t\tbindings = this.root._twowayBindings[ newKeypath.str ] || ( this.root._twowayBindings[ newKeypath.str ] = [] );\n\t\tbindings.push( this );\n\t},\n\n\tunbind: function () {\n\t\t// this is called when the element is unbound.\n\t\t// Specialised bindings can override it\n\t}\n};\n\nBinding.extend = function ( properties ) {\n\tvar Parent = this, SpecialisedBinding;\n\n\tSpecialisedBinding = function ( element ) {\n\t\tBinding.call( this, element );\n\n\t\tif ( this.init ) {\n\t\t\tthis.init();\n\t\t}\n\t};\n\n\tSpecialisedBinding.prototype = create( Parent.prototype );\n\textend( SpecialisedBinding.prototype, properties );\n\n\tSpecialisedBinding.extend = Binding.extend;\n\n\treturn SpecialisedBinding;\n};\n\nexport default Binding;\n\nfunction findParentForm ( element ) {\n\twhile ( element = element.parent ) {\n\t\tif ( element.name === 'form' ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n","import ConditionalAttribute from '../../ConditionalAttribute/_ConditionalAttribute';\n\nexport default function ( element, attributes ) {\n\tif ( !attributes ) {\n\t\treturn [];\n\t}\n\n\treturn attributes.map( a => {\n\t\treturn new ConditionalAttribute( element, a );\n\t});\n}\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport { toArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\n\nvar div;\n\nif ( typeof document !== 'undefined' ) {\n\tdiv = createElement( 'div' );\n}\n\nvar ConditionalAttribute = function ( element, template ) {\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\n\tthis.attributes = [];\n\n\tthis.fragment = new Fragment({\n\t\troot: element.root,\n\t\towner: this,\n\t\ttemplate: [ template ]\n\t});\n};\n\nConditionalAttribute.prototype = {\n\tbubble: function () {\n\t\tif ( this.node ) {\n\t\t\tthis.update();\n\t\t}\n\n\t\tthis.element.bubble();\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\trender: function ( node ) {\n\t\tthis.node = node;\n\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n\t\tthis.update();\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tupdate: function () {\n\t\tvar str, attrs;\n\n\t\tstr = this.fragment.toString();\n\t\tattrs = parseAttributes( str, this.isSvg );\n\n\t\t// any attributes that previously existed but no longer do\n\t\t// must be removed\n\t\tthis.attributes.filter( a => notIn( attrs, a ) ).forEach( a => {\n\t\t\tthis.node.removeAttribute( a.name );\n\t\t});\n\n\t\tattrs.forEach( a => {\n\t\t\tthis.node.setAttribute( a.name, a.value );\n\t\t});\n\n\t\tthis.attributes = attrs;\n\t},\n\n\ttoString: function () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default ConditionalAttribute;\n\n\nfunction parseAttributes ( str, isSvg ) {\n\tvar tag = isSvg ? 'svg' : 'div';\n\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\n\treturn toArray( div.childNodes[0].attributes );\n}\n\nfunction notIn ( haystack, needle ) {\n\tvar i = haystack.length;\n\n\twhile ( i-- ) {\n\t\tif ( haystack[i].name === needle.name ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","import Attribute from '../../Attribute/_Attribute';\n\nexport default function ( element, attributes ) {\n\tvar name, attribute, result = [];\n\n\tfor ( name in attributes ) {\n\t\t// skip binding attributes\n\t\tif ( name === 'twoway' || name === 'lazy') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\tattribute = new Attribute({\n\t\t\t\telement: element,\n\t\t\t\tname:    name,\n\t\t\t\tvalue:   attributes[ name ],\n\t\t\t\troot:    element.root\n\t\t\t});\n\n\t\t\tresult[ name ] = attribute;\n\n\t\t\tif ( name !== 'value' ) {\n\t\t\t\tresult.push( attribute );\n\t\t\t}\n\t\t}\n\t}\n\n\t// value attribute goes last. This is because it\n\t// may get clamped on render otherwise, e.g. in\n\t// `<input type='range' value='999' min='0' max='1000'>`\n\t// since default max is 100\n\tif ( attribute = result.value ) {\n\t\tresult.push( attribute );\n\t}\n\n\treturn result;\n}\n","import bubble from './prototype/bubble';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport update from './prototype/update';\n\nvar Attribute = function ( options ) {\n\tthis.init( options );\n};\n\nAttribute.prototype = {\n\tbubble: bubble,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tupdate: update\n};\n\nexport default Attribute;\n","import { namespaces } from 'config/environment';\nimport noop from 'utils/noop';\n\nimport updateSelectValue from './update/updateSelectValue';\nimport updateMultipleSelectValue from './update/updateMultipleSelectValue';\nimport updateRadioName from './update/updateRadioName';\nimport updateRadioValue from './update/updateRadioValue';\nimport updateCheckboxName from './update/updateCheckboxName';\nimport updateClassName from './update/updateClassName';\nimport updateIdAttribute from './update/updateIdAttribute';\nimport updateIEStyleAttribute from './update/updateIEStyleAttribute';\nimport updateContentEditableValue from './update/updateContentEditableValue';\nimport updateValue from './update/updateValue';\nimport updateBoolean from './update/updateBoolean';\nimport updateEverythingElse from './update/updateEverythingElse';\n\n// There are a few special cases when it comes to updating attributes. For this reason,\n// the prototype .update() method points to this method, which waits until the\n// attribute has finished initialising, then replaces the prototype method with a more\n// suitable one. That way, we save ourselves doing a bunch of tests on each call\nexport default function Attribute$update () {\n\tvar { name, element, node } = this, type, updateMethod;\n\n\tif ( name === 'id' ) {\n\t\tupdateMethod = updateIdAttribute;\n\t}\n\n\telse if ( name === 'value' ) {\n\t\t// special case - selects\n\t\tif ( element.name === 'select' && name === 'value' ) {\n\t\t\tupdateMethod = element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t\t}\n\n\t\telse if ( element.name === 'textarea' ) {\n\t\t\tupdateMethod = updateValue;\n\t\t}\n\n\t\t// special case - contenteditable\n\t\telse if ( element.getAttribute( 'contenteditable' ) != null ) {\n\t\t\tupdateMethod = updateContentEditableValue;\n\t\t}\n\n\t\t// special case - <input>\n\t\telse if ( element.name === 'input' ) {\n\t\t\ttype = element.getAttribute( 'type' );\n\n\t\t\t// type='file' value='{{fileList}}'>\n\t\t\tif ( type === 'file' ) {\n\t\t\t\tupdateMethod = noop; // read-only\n\t\t\t}\n\n\t\t\t// type='radio' name='{{twoway}}'\n\t\t\telse if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {\n\t\t\t\tupdateMethod = updateRadioValue;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tupdateMethod = updateValue;\n\t\t\t}\n\t\t}\n\t}\n\n\t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n\telse if ( this.isTwoway && name === 'name' ) {\n\t\tif ( node.type === 'radio' ) {\n\t\t\tupdateMethod = updateRadioName;\n\t\t}\n\n\t\telse if ( node.type === 'checkbox' ) {\n\t\t\tupdateMethod = updateCheckboxName;\n\t\t}\n\t}\n\n\t// special case - style attributes in Internet Exploder\n\telse if ( name === 'style' && node.style.setAttribute ) {\n\t\tupdateMethod = updateIEStyleAttribute;\n\t}\n\n\t// special case - class names. IE fucks things up, again\n\telse if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {\n\t\tupdateMethod = updateClassName;\n\t}\n\n\telse if ( this.useProperty ) {\n\t\tupdateMethod = updateBoolean;\n\t}\n\n\tif ( !updateMethod ) {\n\t\tupdateMethod = updateEverythingElse;\n\t}\n\n\tthis.update = updateMethod;\n\tthis.update();\n}\n","export default function Attribute$updateEverythingElse () {\n\tvar { node, namespace, name, value, fragment } = this;\n\n\tif ( namespace ) {\n\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t}\n\n\telse if ( !this.isBoolean ) {\n\t\tif ( value == null ) {\n\t\t\tnode.removeAttribute( name );\n\t\t} else {\n\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t}\n\t}\n\n\t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n\telse {\n\t\tif ( value ) {\n\t\t\tnode.setAttribute( name, '' );\n\t\t} else {\n\t\t\tnode.removeAttribute( name );\n\t\t}\n\t}\n}\n","export default function Attribute$updateBooleanAttribute () {\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tthis.node[ this.propertyName ] = this.value;\n\t}\n}\n","export default function Attribute$updateValue () {\n\tvar { node, value } = this;\n\n\t// store actual value, so it doesn't get coerced to a string\n\tnode._ractive.value = value;\n\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tnode.value = ( value == undefined ? '' : value );\n\t}\n}\n","export default function Attribute$updateContentEditableValue () {\n\tvar value = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tif ( !this.locked ) {\n\t\tthis.node.innerHTML = value;\n\t}\n}\n","export default function Attribute$updateIEStyleAttribute () {\n\tvar node, value;\n\n\tnode = this.node;\n\tvalue = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tnode.style.setAttribute( 'cssText', value );\n}\n","export default function Attribute$updateIdAttribute () {\n\tvar { node, value } = this;\n\n\tthis.root.nodes[ value ] = node;\n\tnode.id = value;\n}\n","import { safeToStringValue } from 'utils/dom';\nexport default function Attribute$updateClassName () {\n\tthis.node.className = safeToStringValue( this.value );\n}\n","import { isArray } from 'utils/is';\n\nexport default function Attribute$updateCheckboxName () {\n\tvar { element, node, value } = this, { binding } = element, valueAttribute, i;\n\n\tvalueAttribute = element.getAttribute( 'value' );\n\n\tif ( !isArray( value ) ) {\n\t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n\t} else {\n\t\ti = value.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( valueAttribute == value[i] ) {\n\t\t\t\tbinding.isChecked = node.checked = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbinding.isChecked = node.checked = false;\n\t}\n}\n","import runloop from 'global/runloop';\n\nexport default function Attribute$updateRadioValue () {\n\tvar wasChecked, node = this.node, binding, bindings, i;\n\n\twasChecked = node.checked;\n\n\tnode.value = this.element.getAttribute( 'value' );\n\tnode.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );\n\n\t// This is a special case - if the input was checked, and the value\n\t// changed so that it's no longer checked, the twoway binding is\n\t// most likely out of date. To fix it we have to jump through some\n\t// hoops... this is a little kludgy but it works\n\tif ( wasChecked && !node.checked && this.element.binding ) {\n\t\tbindings = this.element.binding.siblings;\n\n\t\tif ( i = bindings.length ) {\n\t\t\twhile ( i-- ) {\n\t\t\t\tbinding = bindings[i];\n\n\t\t\t\tif ( !binding.element.node ) {\n\t\t\t\t\t// this is the initial render, siblings are still rendering!\n\t\t\t\t\t// we'll come back later...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( binding.element.node.checked ) {\n\t\t\t\t\trunloop.addRactive( binding.root );\n\t\t\t\t\treturn binding.handleChange();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.root.viewmodel.set( binding.keypath, undefined );\n\t\t}\n\t}\n}\n","export default function Attribute$updateRadioName () {\n\tvar { node, value } = this;\n\tnode.checked = ( value == node._ractive.value );\n}\n","import { arrayContains } from 'utils/array';\nimport { isArray } from 'utils/is';\n\nexport default function Attribute$updateMultipleSelect () {\n\tvar value = this.value, options, i, option, optionValue;\n\n\tif ( !isArray( value ) ) {\n\t\tvalue = [ value ];\n\t}\n\n\toptions = this.node.options;\n\ti = options.length;\n\n\twhile ( i-- ) {\n\t\toption = options[i];\n\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\t\toption.selected = arrayContains( value, optionValue );\n\t}\n}\n","export default function Attribute$updateSelect () {\n\tvar value = this.value, options, option, optionValue, i;\n\n\tif ( !this.locked ) {\n\t\tthis.node._ractive.value = value;\n\n\t\toptions = this.node.options;\n\t\ti = options.length;\n\n\t\twhile ( i-- ) {\n\t\t\toption = options[i];\n\t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\toption.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we're still here, it means the new value didn't match any of the options...\n\t// TODO figure out what to do in this situation\n}\n","export default function Attribute$unbind () {\n\t// ignore non-dynamic attributes\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.name === 'id' ) {\n\t\tdelete this.root.nodes[ this.value ];\n\t}\n}\n","export default function Attribute$toString () {\n\tvar { name, namespacePrefix, value, interpolator, fragment } = this;\n\n\t// Special case - select and textarea values (should not be stringified)\n\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\treturn;\n\t}\n\n\t// Special case - content editable\n\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\treturn;\n\t}\n\n\t// Special case - radio names\n\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\treturn 'name={{' + ( interpolator.keypath.str || interpolator.ref ) + '}}';\n\t}\n\n\t// Boolean attributes\n\tif ( this.isBoolean ) {\n\t\treturn value ? name : '';\n\t}\n\n\tif ( fragment ) {\n\t\t// special case - this catches undefined/null values (#1211)\n\t\tif ( fragment.items.length === 1 && fragment.items[0].value == null ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvalue = fragment.toString();\n\t}\n\n\tif ( namespacePrefix ) {\n\t\tname = namespacePrefix + ':' + name;\n\t}\n\n\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n}\n\nfunction escape ( value ) {\n\treturn value\n\t\t.replace( /&/g, '&amp;' )\n\t\t.replace( /\"/g, '&quot;' )\n\t\t.replace( /'/g, '&#39;' );\n}\n","import { namespaces } from 'config/environment';\n\n// the property name equivalents for element attributes, where they differ\n// from the lowercased attribute name\nvar propertyNames = {\n\t'accept-charset': 'acceptCharset',\n\t'accesskey': 'accessKey',\n\t'bgcolor': 'bgColor',\n\t'class': 'className',\n\t'codebase': 'codeBase',\n\t'colspan': 'colSpan',\n\t'contenteditable': 'contentEditable',\n\t'datetime': 'dateTime',\n\t'dirname': 'dirName',\n\t'for': 'htmlFor',\n\t'http-equiv': 'httpEquiv',\n\t'ismap': 'isMap',\n\t'maxlength': 'maxLength',\n\t'novalidate': 'noValidate',\n\t'pubdate': 'pubDate',\n\t'readonly': 'readOnly',\n\t'rowspan': 'rowSpan',\n\t'tabindex': 'tabIndex',\n\t'usemap': 'useMap'\n};\n\nexport default function Attribute$render ( node ) {\n\tvar propertyName;\n\n\tthis.node = node;\n\n\t// should we use direct property access, or setAttribute?\n\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\n\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\tthis.propertyName = propertyName;\n\t\t}\n\n\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\tif ( this.isBoolean || this.isTwoway ) {\n\t\t\tthis.useProperty = true;\n\t\t}\n\n\t\tif ( propertyName === 'value' ) {\n\t\t\tnode._ractive.value = this.value;\n\t\t}\n\t}\n\n\tthis.rendered = true;\n\tthis.update();\n}\n","export default function Attribute$rebind ( oldKeypath, newKeypath ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t}\n}\n","import { ATTRIBUTE } from 'config/types';\nimport { booleanAttributes } from 'utils/html';\nimport determineNameAndNamespace from '../helpers/determineNameAndNamespace';\nimport getInterpolator from '../helpers/getInterpolator';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Attribute$init ( options ) {\n\tthis.type = ATTRIBUTE;\n\tthis.element = options.element;\n\tthis.root = options.root;\n\n\tdetermineNameAndNamespace( this, options.name );\n\tthis.isBoolean = booleanAttributes.test( this.name );\n\n\t// if it's an empty attribute, or just a straight key-value pair, with no\n\t// mustache shenanigans, set the attribute accordingly and go home\n\tif ( !options.value || typeof options.value === 'string' ) {\n\t\tthis.value = this.isBoolean ? true : options.value || '';\n\t\treturn;\n\t}\n\n\t// otherwise we need to do some work\n\n\t// share parentFragment with parent element\n\tthis.parentFragment = this.element.parentFragment;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: options.value,\n\t\troot:     this.root,\n\t\towner:    this\n\t});\n\n\t// TODO can we use this.fragment.toString() in some cases? It's quicker\n\tthis.value = this.fragment.getValue();\n\n\t// Store a reference to this attribute's interpolator, if its fragment\n\t// takes the form `{{foo}}`. This is necessary for two-way binding and\n\t// for correctly rendering HTML later\n\tthis.interpolator = getInterpolator( this );\n\tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n\t// mark as ready\n\tthis.ready = true;\n}\n","import { INTERPOLATOR } from 'config/types';\n\nexport default function getInterpolator ( attribute ) {\n\tvar items = attribute.fragment.items;\n\n\tif ( items.length !== 1 ) {\n\t\treturn;\n\t}\n\n\tif ( items[0].type === INTERPOLATOR ) {\n\t\treturn items[0];\n\t}\n}\n","import { namespaces } from 'config/environment';\nimport enforceCase from 'virtualdom/items/Element/shared/enforceCase';\n\nexport default function ( attribute, name ) {\n\tvar colonIndex, namespacePrefix;\n\n\t// are we dealing with a namespaced attribute, e.g. xlink:href?\n\tcolonIndex = name.indexOf( ':' );\n\tif ( colonIndex !== -1 ) {\n\n\t\t// looks like we are, yes...\n\t\tnamespacePrefix = name.substr( 0, colonIndex );\n\n\t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n\t\t// that only valid namespaces will be used)\n\t\tif ( namespacePrefix !== 'xmlns' ) {\n\t\t\tname = name.substring( colonIndex + 1 );\n\n\t\t\tattribute.name = enforceCase( name );\n\t\t\tattribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];\n\t\t\tattribute.namespacePrefix = namespacePrefix;\n\n\t\t\tif ( !attribute.namespace ) {\n\t\t\t\tthrow 'Unknown namespace (\"' + namespacePrefix + '\")';\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// SVG attribute names are case sensitive\n\tattribute.name = ( attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name );\n}\n","var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\nsvgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );\nsvgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );\n\ncreateMap = function ( items ) {\n\tvar map = {}, i = items.length;\n\twhile ( i-- ) {\n\t\tmap[ items[i].toLowerCase() ] = items[i];\n\t}\n\treturn map;\n};\n\nmap = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );\n\nexport default function ( elementName ) {\n\tvar lowerCaseElementName = elementName.toLowerCase();\n\treturn map[ lowerCaseElementName ] || lowerCaseElementName;\n}\n","import runloop from 'global/runloop';\nimport { isEqual } from 'utils/is';\n\nexport default function Attribute$bubble () {\n\tvar value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n\t// TODO this can register the attribute multiple times (see render test\n\t// 'Attribute with nested mustaches')\n\tif ( !isEqual( value, this.value ) ) {\n\n\t\t// Need to clear old id from ractive.nodes\n\t\tif ( this.name === 'id' && this.value ) {\n\t\t\tdelete this.root.nodes[ this.value ];\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tif ( this.name === 'value' && this.node ) {\n\t\t\t// We need to store the value on the DOM like this so we\n\t\t\t// can retrieve it later without it being coerced to a string\n\t\t\tthis.node._ractive.value = value;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n}\n","var truthy = /^true|on|yes|1$/i;\nvar isNumeric = /^[0-9]+$/;\n\nexport default function( element, template ) {\n\tvar val, attrs, attributes;\n\n\tattributes = template.a || {};\n\tattrs = {};\n\n\t// attributes that are present but don't have a value (=)\n\t// will be set to the number 0, which we condider to be true\n\t// the string '0', however is false\n\n\tval = attributes.twoway;\n\tif ( val !== undefined ) {\n\t\tattrs.twoway = val === 0 || truthy.test( val );\n\t}\n\n\tval = attributes.lazy;\n\tif ( val !== undefined ) {\n\t\t// check for timeout value\n\t\tif ( val !== 0 && isNumeric.test( val ) ) {\n\t\t\tattrs.lazy = parseInt( val );\n\t\t} else {\n\t\t\tattrs.lazy = val === 0 || truthy.test( val );\n\t\t}\n\t}\n\n\treturn attrs;\n}\n","export default function Element$getAttribute ( name ) {\n\tif ( !this.attributes || !this.attributes[ name ] ) {\n\t\treturn;\n\t}\n\n\treturn this.attributes[ name ].value;\n}\n","export default function Element$firstNode () {\n\treturn this.node;\n}\n","export default function Element$findNextNode () {\n\treturn null;\n}\n","export default function ( selector ) {\n\tif ( this.fragment ) {\n\t\treturn this.fragment.findComponent( selector );\n\t}\n}\n","export default function ( selector, query ) {\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function ( selector, query ) {\n\t// Add this node to the query, if applicable, and register the\n\t// query on this element\n\tif ( query._test( this, true ) && query.live ) {\n\t\t( this.liveQueries || ( this.liveQueries = [] ) ).push( query );\n\t}\n\n\tif ( this.fragment ) {\n\t\tthis.fragment.findAll( selector, query );\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function ( selector ) {\n\tif ( !this.node ) {\n\t\t// this element hasn't been rendered yet\n\t\treturn null;\n\t}\n\n\tif ( matches( this.node, selector ) ) {\n\t\treturn this.node;\n\t}\n\n\tif ( this.fragment && this.fragment.find ) {\n\t\treturn this.fragment.find( selector );\n\t}\n}\n","export default function Element$detach () {\n\tvar node = this.node, parentNode;\n\n\tif ( node ) {\n\t\t// need to check for parent node - DOM may have been altered\n\t\t// by something other than Ractive! e.g. jQuery UI...\n\t\tif ( parentNode = node.parentNode ) {\n\t\t\tparentNode.removeChild( node );\n\t\t}\n\n\t\treturn node;\n\t}\n}\n","export default function () {\n\tthis.parentFragment.bubble();\n}\n","import { TRIPLE } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport firstNode from './prototype/firstNode';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nimport unbind from '../shared/unbind';\n\nvar Triple = function ( options ) {\n\tthis.type = TRIPLE;\n\tMustache.init( this, options );\n};\n\nTriple.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfirstNode: firstNode,\n\tgetValue: Mustache.getValue,\n\trebind: Mustache.rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Triple;\n","import insertHtml from 'virtualdom/items/Triple/helpers/insertHtml';\nimport updateSelect from 'virtualdom/items/Triple/helpers/updateSelect';\n\nexport default function Triple$update () {\n\tvar node, parentNode;\n\n\tif ( !this.rendered ) {\n\t\treturn;\n\t}\n\n\t// Remove existing nodes\n\twhile ( this.nodes && this.nodes.length ) {\n\t\tnode = this.nodes.pop();\n\t\tnode.parentNode.removeChild( node );\n\t}\n\n\t// Insert new nodes\n\tparentNode = this.parentFragment.getNode();\n\n\tthis.nodes = insertHtml( this.value, parentNode, this.docFrag );\n\tparentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );\n\n\t// Special case - we're inserting the contents of a <select>\n\tupdateSelect( this.pElement );\n}\n","import { detachNode } from 'utils/dom';\n\nexport default function Triple$unrender ( shouldDestroy ) {\n\tif ( this.rendered && shouldDestroy ) {\n\t\tthis.nodes.forEach( detachNode );\n\t\tthis.rendered = false;\n\t}\n\n\t// TODO update live queries\n}\n","import { decodeCharacterReferences } from 'utils/html';\n\nexport default function Triple$toString () {\n\treturn ( this.value != undefined ? decodeCharacterReferences( '' + this.value ) : '' );\n}\n","import runloop from 'global/runloop';\n\nexport default function Triple$setValue ( value ) {\n\tvar wrapper;\n\n\t// TODO is there a better way to approach this?\n\tif ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) {\n\t\tvalue = wrapper.get();\n\t}\n\n\tif ( value !== this.value ) {\n\t\tthis.value = value;\n\t\tthis.parentFragment.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n}\n","import insertHtml from 'virtualdom/items/Triple/helpers/insertHtml';\nimport updateSelect from 'virtualdom/items/Triple/helpers/updateSelect';\n\nexport default function Triple$render () {\n\tif ( this.rendered ) {\n\t\tthrow new Error( 'Attempted to render an item that was already rendered' );\n\t}\n\n\tthis.docFrag = document.createDocumentFragment();\n\tthis.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );\n\n\t// Special case - we're inserting the contents of a <select>\n\tupdateSelect( this.pElement );\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","import { toArray } from 'utils/array';\n\nexport default function updateSelect ( parentElement ) {\n\tvar selectedOptions, option, value;\n\n\tif ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {\n\t\treturn;\n\t}\n\n\tselectedOptions = toArray( parentElement.node.options ).filter( isSelected );\n\n\t// If one of them had a `selected` attribute, we need to sync\n\t// the model to the view\n\tif ( parentElement.getAttribute( 'multiple' ) ) {\n\t\tvalue = selectedOptions.map( o => o.value );\n\t} else if ( option = selectedOptions[0] ) {\n\t\tvalue = option.value;\n\t}\n\n\tif ( value !== undefined ) {\n\t\tparentElement.binding.setValue( value );\n\t}\n\n\tparentElement.bubble();\n}\n\nfunction isSelected ( option ) {\n\treturn option.selected;\n}\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\n\nvar elementCache = {}, ieBug, ieBlacklist;\n\ntry {\n\tcreateElement( 'table' ).innerHTML = 'foo';\n} catch ( err ) {\n\tieBug = true;\n\n\tieBlacklist = {\n\t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t};\n}\n\nexport default function ( html, node, docFrag ) {\n\tvar container, nodes = [], wrapper, selectedOption, child, i;\n\n\t// render 0 and false\n\tif ( html != null && html !== '' ) {\n\t\tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t\t\tcontainer = container.querySelector( '.x' );\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\telse if ( node.namespaceURI === namespaces.svg ) {\n\t\t\tcontainer = element( 'DIV' );\n\t\t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t\t\tcontainer = container.querySelector( '.x' );\n\t\t}\n\n\t\telse {\n\t\t\tcontainer = element( node.tagName );\n\t\t\tcontainer.innerHTML = html;\n\n\t\t\tif ( container.tagName === 'SELECT' ) {\n\t\t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t\t\t}\n\t\t}\n\n\t\twhile ( child = container.firstChild ) {\n\t\t\tnodes.push( child );\n\t\t\tdocFrag.appendChild( child );\n\t\t}\n\n\t\t// This is really annoying. Extracting <option> nodes from the\n\t\t// temporary container <select> causes the remaining ones to\n\t\t// become selected. So now we have to deselect them. IE8, you\n\t\t// amaze me. You really do\n\t\t// ...and now Chrome too\n\t\tif ( node.tagName === 'SELECT' ) {\n\t\t\ti = nodes.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( nodes[i] !== selectedOption ) {\n\t\t\t\t\tnodes[i].selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nodes;\n}\n\nfunction element ( tagName ) {\n\treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n}\n","export default function Triple$firstNode () {\n\tif ( this.rendered && this.nodes[0] ) {\n\t\treturn this.nodes[0];\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","import { matches } from 'utils/dom';\n\nexport default function Triple$findAll ( selector, queryResult ) {\n\tvar i, len, node, queryAllResult, numNodes, j;\n\n\tlen = this.nodes.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tnode = this.nodes[i];\n\n\t\tif ( node.nodeType !== 1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( matches( node, selector ) ) {\n\t\t\tqueryResult.push( node );\n\t\t}\n\n\t\tif ( queryAllResult = node.querySelectorAll( selector ) ) {\n\t\t\tnumNodes = queryAllResult.length;\n\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t\t\t\tqueryResult.push( queryAllResult[j] );\n\t\t\t}\n\t\t}\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function Triple$find ( selector ) {\n\tvar i, len, node, queryResult;\n\n\tlen = this.nodes.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tnode = this.nodes[i];\n\n\t\tif ( node.nodeType !== 1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( matches( node, selector ) ) {\n\t\t\treturn node;\n\t\t}\n\n\t\tif ( queryResult = node.querySelector( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Triple$detach () {\n\tvar len, i;\n\n\tif ( this.docFrag ) {\n\t\tlen = this.nodes.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.docFrag.appendChild( this.nodes[i] );\n\t\t}\n\n\t\treturn this.docFrag;\n\t}\n}\n","import { SECTION, SECTION_UNLESS } from 'config/types';\nimport Mustache from 'virtualdom/items/shared/Mustache/_Mustache';\n\nimport bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport shuffle from './prototype/shuffle';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport setValue from './prototype/setValue';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\nimport update from './prototype/update';\n\nvar Section = function ( options ) {\n\tthis.type = SECTION;\n\tthis.subtype = this.currentSubtype = options.template.n;\n\tthis.inverted = this.subtype === SECTION_UNLESS;\n\n\n\tthis.pElement = options.pElement;\n\n\tthis.fragments = [];\n\tthis.fragmentsToCreate = [];\n\tthis.fragmentsToRender = [];\n\tthis.fragmentsToUnrender = [];\n\n\tif ( options.template.i ) {\n\t\tthis.indexRefs = options.template.i.split(',').map( ( k, i ) => {\n\t\t\treturn { n: k, t: i === 0 ? 'k' : 'i' };\n\t\t});\n\t}\n\n\tthis.renderedFragments = [];\n\n\tthis.length = 0; // number of times this section is rendered\n\n\tMustache.init( this, options );\n};\n\nSection.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetIndexRef: function( name ) {\n\t\tif ( this.indexRefs ) {\n\t\t\tlet i = this.indexRefs.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tlet ref = this.indexRefs[i];\n\t\t\t\tif ( ref.n === name ) {\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tgetValue: Mustache.getValue,\n\tshuffle: shuffle,\n\trebind: rebind,\n\trender: render,\n\tresolve: Mustache.resolve,\n\tsetValue: setValue,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender,\n\tupdate: update\n};\n\nexport default Section;\n","export default function Section$update () {\n\tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n\t// `this.renderedFragments` is in the order of the previous render.\n\t// If fragments have shuffled about, this allows us to quickly\n\t// reinsert them in the correct place\n\trenderedFragments = this.renderedFragments;\n\n\t// Remove fragments that have been marked for destruction\n\twhile ( fragment = this.fragmentsToUnrender.pop() ) {\n\t\tfragment.unrender( true );\n\t\trenderedFragments.splice( renderedFragments.indexOf( fragment ), 1 );\n\t}\n\n\t// Render new fragments (but don't insert them yet)\n\twhile ( fragment = this.fragmentsToRender.shift() ) {\n\t\tfragment.render();\n\t}\n\n\tif ( this.rendered ) {\n\t\ttarget = this.parentFragment.getNode();\n\t}\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tfragment = this.fragments[i];\n\t\trenderIndex = renderedFragments.indexOf( fragment, i ); // search from current index - it's guaranteed to be the same or higher\n\n\t\tif ( renderIndex === i ) {\n\t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n\t\t\tif ( this.docFrag.childNodes.length ) {\n\t\t\t\tanchor = fragment.firstNode();\n\t\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tthis.docFrag.appendChild( fragment.detach() );\n\n\t\t// update renderedFragments\n\t\tif ( renderIndex !== -1 ) {\n\t\t\trenderedFragments.splice( renderIndex, 1 );\n\t\t}\n\t\trenderedFragments.splice( i, 0, fragment );\n\t}\n\n\tif ( this.rendered && this.docFrag.childNodes.length ) {\n\t\tanchor = this.parentFragment.findNextNode( this );\n\t\ttarget.insertBefore( this.docFrag, anchor );\n\t}\n\n\t// Save the rendering order for next time\n\tthis.renderedFragments = this.fragments.slice();\n}\n","export default function Section$unrender ( shouldDestroy ) {\n\tthis.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\tthis.renderedFragments = [];\n\tthis.rendered = false;\n}\n\nfunction unrenderAndDestroy ( fragment ) {\n\tfragment.unrender( true );\n}\n\nfunction unrender ( fragment ) {\n\tfragment.unrender( false );\n}\n","import { removeFromArray } from 'utils/array';\nimport { unbind as unbindFragment } from 'shared/methodCallers';\nimport unbind from '../../shared/unbind';\n\nexport default function Section$unbind () {\n\tthis.fragments.forEach( unbindFragment );\n\tthis.fragmentsToRender.forEach( f => removeFromArray( this.fragments, f ) );\n\tthis.fragmentsToRender = [];\n\tunbind.call( this );\n\n\tthis.length = 0;\n\tthis.unbound = true;\n}\n","export default function Section$toString ( escape ) {\n\tvar str, i, len;\n\n\tstr = '';\n\n\ti = 0;\n\tlen = this.length;\n\n\tfor ( i=0; i<len; i+=1 ) {\n\t\tstr += this.fragments[i].toString( escape );\n\t}\n\n\treturn str;\n}\n","import { SECTION_EACH, SECTION_IF, SECTION_UNLESS, SECTION_WITH, SECTION_IF_WITH } from 'config/types';\nimport { isArrayLike, isObject } from 'utils/is';\nimport { unbind } from 'shared/methodCallers';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nexport default function Section$setValue ( value ) {\n\tvar wrapper, fragmentOptions;\n\n\tif ( this.updating ) {\n\t\t// If a child of this section causes a re-evaluation - for example, an\n\t\t// expression refers to a function that mutates the array that this\n\t\t// section depends on - we'll end up with a double rendering bug (see\n\t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n\t\treturn;\n\t}\n\n\tthis.updating = true;\n\n\t// with sections, we need to get the fake value if we have a wrapped object\n\tif ( this.keypath && ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) ) {\n\t\tvalue = wrapper.get();\n\t}\n\n\t// If any fragments are awaiting creation after a splice,\n\t// this is the place to do it\n\tif ( this.fragmentsToCreate.length ) {\n\t\tfragmentOptions = {\n\t\t\ttemplate: this.template.f || [],\n\t\t\troot:     this.root,\n\t\t\tpElement: this.pElement,\n\t\t\towner:    this\n\t\t};\n\n\t\tthis.fragmentsToCreate.forEach( index => {\n\t\t\tvar fragment;\n\n\t\t\tfragmentOptions.context = this.keypath.join( index );\n\t\t\tfragmentOptions.index = index;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\tthis.fragmentsToRender.push( this.fragments[ index ] = fragment );\n\t\t});\n\n\t\tthis.fragmentsToCreate.length = 0;\n\t}\n\n\telse if ( reevaluateSection( this, value ) ) {\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t}\n\n\tthis.value = value;\n\tthis.updating = false;\n}\n\nfunction changeCurrentSubtype ( section, value, obj ) {\n\tif ( value === SECTION_EACH ) {\n\t\t// make sure ref type is up to date for key or value indices\n\t\tif ( section.indexRefs && section.indexRefs[0] ) {\n\t\t\tlet ref = section.indexRefs[0];\n\n\t\t\t// when switching flavors, make sure the section gets updated\n\t\t\tif ( ( obj && ref.t === 'i' ) || ( !obj && ref.t === 'k' ) ) {\n\t\t\t\t// if switching from object to list, unbind all of the old fragments\n\t\t\t\tif ( !obj ) {\n\t\t\t\t\tsection.length = 0;\n\t\t\t\t  section.fragmentsToUnrender = section.fragments.slice( 0 );\n\t\t\t\t\tsection.fragmentsToUnrender.forEach( f => f.unbind() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tref.t = obj ? 'k' : 'i';\n\t\t}\n\t}\n\n\tsection.currentSubtype = value;\n}\n\nfunction reevaluateSection ( section, value ) {\n\tvar fragmentOptions = {\n\t\ttemplate: section.template.f || [],\n\t\troot:     section.root,\n\t\tpElement: section.parentFragment.pElement,\n\t\towner:    section\n\t};\n\n\tsection.hasContext = true;\n\n\t// If we already know the section type, great\n\t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n\t// and avoid doing this each time?\n\tif ( section.subtype ) {\n\t\tswitch ( section.subtype ) {\n\t\t\tcase SECTION_IF:\n\t\t\tsection.hasContext = false;\n\t\t\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n\n\t\t\tcase SECTION_UNLESS:\n\t\t\tsection.hasContext = false;\n\t\t\treturn reevaluateConditionalSection( section, value, true, fragmentOptions );\n\n\t\t\tcase SECTION_WITH:\n\t\t\treturn reevaluateContextSection( section, fragmentOptions );\n\n\t\t\tcase SECTION_IF_WITH:\n\t\t\treturn reevaluateConditionalContextSection( section, value, fragmentOptions );\n\n\t\t\tcase SECTION_EACH:\n\t\t\tif ( isObject( value ) ) {\n\t\t\t\tchangeCurrentSubtype( section, section.subtype, true );\n\t\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t\t}\n\n\t\t\t// Fallthrough - if it's a conditional or an array we need to continue\n\t\t}\n\t}\n\n\t// Otherwise we need to work out what sort of section we're dealing with\n\tsection.ordered = !!isArrayLike( value );\n\n\t// Ordered list section\n\tif ( section.ordered ) {\n\t\tchangeCurrentSubtype( section, SECTION_EACH, false );\n\t\treturn reevaluateListSection( section, value, fragmentOptions );\n\t}\n\n\t// Unordered list, or context\n\tif ( isObject( value ) || typeof value === 'function' ) {\n\t\t// Index reference indicates section should be treated as a list\n\t\tif ( section.template.i ) {\n\t\t\tchangeCurrentSubtype( section, SECTION_EACH, true );\n\t\t\treturn reevaluateListObjectSection( section, value, fragmentOptions );\n\t\t}\n\n\t\t// Otherwise, object provides context for contents\n\t\tchangeCurrentSubtype( section, SECTION_WITH, false );\n\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t}\n\n\t// Conditional section\n\tchangeCurrentSubtype( section, SECTION_IF, false );\n\tsection.hasContext = false;\n\treturn reevaluateConditionalSection( section, value, false, fragmentOptions );\n}\n\nfunction reevaluateListSection ( section, value, fragmentOptions ) {\n\tvar i, length, fragment;\n\n\tlength = value.length;\n\n\tif ( length === section.length ) {\n\t\t// Nothing to do\n\t\treturn false;\n\t}\n\n\t// if the array is shorter than it was previously, remove items\n\tif ( length < section.length ) {\n\t\tsection.fragmentsToUnrender = section.fragments.splice( length, section.length - length );\n\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t}\n\n\t// otherwise...\n\telse {\n\t\tif ( length > section.length ) {\n\t\t\t// add any new ones\n\t\t\tfor ( i = section.length; i < length; i += 1 ) {\n\t\t\t\t// append list item to context stack\n\t\t\t\tfragmentOptions.context = section.keypath.join( i );\n\t\t\t\tfragmentOptions.index = i;\n\n\t\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\t\tsection.fragmentsToRender.push( section.fragments[i] = fragment );\n\t\t\t}\n\t\t}\n\t}\n\n\tsection.length = length;\n\treturn true;\n}\n\nfunction reevaluateListObjectSection ( section, value, fragmentOptions ) {\n\tvar id, i, hasKey, fragment, changed, deps;\n\n\thasKey = section.hasKey || ( section.hasKey = {} );\n\n\t// remove any fragments that should no longer exist\n\ti = section.fragments.length;\n\twhile ( i-- ) {\n\t\tfragment = section.fragments[i];\n\n\t\tif ( !( fragment.key in value ) ) {\n\t\t\tchanged = true;\n\n\t\t\tfragment.unbind();\n\t\t\tsection.fragmentsToUnrender.push( fragment );\n\t\t\tsection.fragments.splice( i, 1 );\n\n\t\t\thasKey[ fragment.key ] = false;\n\t\t}\n\t}\n\n\t// notify any dependents about changed indices\n\ti = section.fragments.length;\n\twhile ( i-- ) {\n\t\tfragment = section.fragments[i];\n\n\t\tif ( fragment.index !== i ){\n\t\t\tfragment.index = i;\n\t\t\tif ( deps = fragment.registeredIndexRefs ) {\n\t\t\t\tdeps.forEach( blindRebind );\n\t\t\t}\n\t\t}\n\t}\n\n\t// add any that haven't been created yet\n\ti = section.fragments.length;\n\tfor ( id in value ) {\n\t\tif ( !hasKey[ id ] ) {\n\t\t\tchanged = true;\n\n\t\t\tfragmentOptions.context = section.keypath.join( id );\n\t\t\tfragmentOptions.key = id;\n\t\t\tfragmentOptions.index = i++;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\n\t\t\tsection.fragmentsToRender.push( fragment );\n\t\t\tsection.fragments.push( fragment );\n\t\t\thasKey[ id ] = true;\n\t\t}\n\t}\n\n\tsection.length = section.fragments.length;\n\treturn changed;\n}\n\nfunction reevaluateConditionalContextSection ( section, value, fragmentOptions ) {\n\tif ( value ) {\n\t\treturn reevaluateContextSection( section, fragmentOptions );\n\t} else {\n\t\treturn removeSectionFragments( section );\n\t}\n}\n\nfunction reevaluateContextSection ( section, fragmentOptions ) {\n\tvar fragment;\n\n\t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n\t// (if it is already rendered, then any children dependent on the context stack\n\t// will update themselves without any prompting)\n\tif ( !section.length ) {\n\t\t// append this section to the context stack\n\t\tfragmentOptions.context = section.keypath;\n\t\tfragmentOptions.index = 0;\n\n\t\tfragment = new Fragment( fragmentOptions );\n\n\t\tsection.fragmentsToRender.push( section.fragments[0] = fragment );\n\t\tsection.length = 1;\n\n\t\treturn true;\n\t}\n}\n\nfunction reevaluateConditionalSection ( section, value, inverted, fragmentOptions ) {\n\tvar doRender, emptyArray, emptyObject, fragment, name;\n\n\temptyArray = ( isArrayLike( value ) && value.length === 0 );\n\temptyObject = false;\n\tif( !isArrayLike( value ) && isObject( value ) ) {\n\t\temptyObject = true;\n\t\tfor( name in value ) {\n\t\t\temptyObject = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( inverted ) {\n\t\tdoRender = emptyArray || emptyObject || !value;\n\t} else {\n\t\tdoRender = value && !emptyArray && !emptyObject;\n\t}\n\n\tif ( doRender ) {\n\t\tif ( !section.length ) {\n\t\t\t// no change to context stack\n\t\t\tfragmentOptions.index = 0;\n\n\t\t\tfragment = new Fragment( fragmentOptions );\n\t\t\tsection.fragmentsToRender.push( section.fragments[0] = fragment );\n\t\t\tsection.length = 1;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( section.length > 1 ) {\n\t\t\tsection.fragmentsToUnrender = section.fragments.splice( 1 );\n\t\t\tsection.fragmentsToUnrender.forEach( unbind );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\telse {\n\t\treturn removeSectionFragments( section );\n\t}\n}\n\nfunction removeSectionFragments ( section ) {\n\tif ( section.length ) {\n\t\tsection.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length ).filter( isRendered );\n\t\tsection.fragmentsToUnrender.forEach( unbind );\n\t\tsection.length = section.fragmentsToRender.length = 0;\n\t\treturn true;\n\t}\n}\n\nfunction isRendered ( fragment ) {\n\treturn fragment.rendered;\n}\n\nfunction blindRebind ( dep ) {\n\t// the keypath doesn't actually matter here as it won't have changed\n\tdep.rebind( '', '' );\n}\n","export default function Section$render () {\n\tthis.docFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( f => this.docFrag.appendChild( f.render() ) );\n\n\tthis.renderedFragments = this.fragments.slice();\n\tthis.fragmentsToRender = [];\n\n\tthis.rendered = true;\n\treturn this.docFrag;\n}\n","import Mustache from '../../shared/Mustache/_Mustache';\n\nexport default function( oldKeypath, newKeypath ) {\n\tMustache.rebind.call( this, oldKeypath, newKeypath );\n}\n","import { SECTION_EACH } from 'config/types';\nimport runloop from 'global/runloop';\n\nexport default function Section$shuffle ( newIndices ) {\n\tvar parentFragment,\n\t\tfirstChange,\n\t\ti,\n\t\tnewLength,\n\t\treboundFragments,\n\t\tfragmentOptions,\n\t\tfragment;\n\n\t// short circuit any double-updates, and ensure that this isn't applied to\n\t// non-list sections\n\tif ( this.shuffling || this.unbound || ( this.currentSubtype !== SECTION_EACH ) ) {\n\t\treturn;\n\t}\n\n\tthis.shuffling = true;\n\trunloop.scheduleTask( () => this.shuffling = false );\n\n\tparentFragment = this.parentFragment;\n\n\treboundFragments = [];\n\n\t// TODO: need to update this\n\t// first, rebind existing fragments\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tvar fragment, by, oldKeypath, newKeypath, deps;\n\n\t\tif ( newIndex === oldIndex ) {\n\t\t\treboundFragments[ newIndex ] = this.fragments[ oldIndex ];\n\t\t\treturn;\n\t\t}\n\n\t\tfragment = this.fragments[ oldIndex ];\n\n\t\tif ( firstChange === undefined ) {\n\t\t\tfirstChange = oldIndex;\n\t\t}\n\n\t\t// does this fragment need to be torn down?\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.fragmentsToUnrender.push( fragment );\n\t\t\tfragment.unbind();\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, it needs to be rebound to a new index\n\t\tby = newIndex - oldIndex;\n\t\toldKeypath = this.keypath.join( oldIndex );\n\t\tnewKeypath = this.keypath.join( newIndex );\n\n\t\tfragment.index = newIndex;\n\n\t\t// notify any registered index refs directly\n\t\tif ( deps = fragment.registeredIndexRefs ) {\n\t\t\tdeps.forEach( blindRebind );\n\t\t}\n\n\t\tfragment.rebind( oldKeypath, newKeypath );\n\t\treboundFragments[ newIndex ] = fragment;\n\t});\n\n\tnewLength = this.root.viewmodel.get( this.keypath ).length;\n\n\t// If nothing changed with the existing fragments, then we start adding\n\t// new fragments at the end...\n\tif ( firstChange === undefined ) {\n\t\t// ...unless there are no new fragments to add\n\t\tif ( this.length === newLength ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfirstChange = this.length;\n\t}\n\n\tthis.length = this.fragments.length = newLength;\n\n\tif ( this.rendered ) {\n\t\trunloop.addView( this );\n\t}\n\n\t// Prepare new fragment options\n\tfragmentOptions = {\n\t\ttemplate: this.template.f,\n\t\troot:       this.root,\n\t\towner:      this\n\t};\n\n\t// Add as many new fragments as we need to, or add back existing\n\t// (detached) fragments\n\tfor ( i = firstChange; i < newLength; i += 1 ) {\n\t\tfragment = reboundFragments[i];\n\n\t\tif ( !fragment ) {\n\t\t\tthis.fragmentsToCreate.push( i );\n\t\t}\n\n\t\tthis.fragments[i] = fragment;\n\t}\n}\n\nfunction blindRebind ( dep ) {\n\t// the keypath doesn't actually matter here as it won't have changed\n\tdep.rebind( '', '' );\n}\n","export default function Section$firstNode () {\n\tvar len, i, node;\n\n\tif ( len = this.fragments.length ) {\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tif ( node = this.fragments[i].firstNode() ) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Section$findNextNode ( fragment ) {\n\tif ( this.fragments[ fragment.index + 1 ] ) {\n\t\treturn this.fragments[ fragment.index + 1 ].firstNode();\n\t}\n\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Section$findComponent ( selector ) {\n\tvar i, len, queryResult;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( queryResult = this.fragments[i].findComponent( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Section$findAllComponents ( selector, query ) {\n\tvar i, len;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tthis.fragments[i].findAllComponents( selector, query );\n\t}\n}\n","export default function Section$findAll ( selector, query ) {\n\tvar i, len;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tthis.fragments[i].findAll( selector, query );\n\t}\n}\n","export default function Section$find ( selector ) {\n\tvar i, len, queryResult;\n\n\tlen = this.fragments.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tif ( queryResult = this.fragments[i].find( selector ) ) {\n\t\t\treturn queryResult;\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Section$detach () {\n\tvar docFrag;\n\n\tif ( this.fragments.length === 1 ) {\n\t\treturn this.fragments[0].detach();\n\t}\n\n\tdocFrag = document.createDocumentFragment();\n\n\tthis.fragments.forEach( item => {\n\t\tdocFrag.appendChild( item.detach() );\n\t});\n\n\treturn docFrag;\n}\n","export default function Section$bubble () {\n\tthis.parentFragment.bubble();\n}\n","import { INTERPOLATOR } from 'config/types';\nimport runloop from 'global/runloop';\nimport { escapeHtml } from 'utils/html';\nimport { detachNode, safeToStringValue } from 'utils/dom';\nimport { isEqual } from 'utils/is';\nimport unbind from './shared/unbind';\nimport Mustache from './shared/Mustache/_Mustache';\nimport detach from './shared/detach';\n\nvar Interpolator = function ( options ) {\n\tthis.type = INTERPOLATOR;\n\tMustache.init( this, options );\n};\n\nInterpolator.prototype = {\n\tupdate () {\n\t\tthis.node.data = ( this.value == undefined ? '' : this.value );\n\t},\n\tresolve: Mustache.resolve,\n\trebind: Mustache.rebind,\n\tdetach: detach,\n\n\tunbind: unbind,\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createTextNode( safeToStringValue(this.value) );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tdetachNode( this.node );\n\t\t}\n\t},\n\n\tgetValue: Mustache.getValue,\n\n\t// TEMP\n\tsetValue ( value ) {\n\t\tvar wrapper;\n\n\t\t// TODO is there a better way to approach this?\n\t\tif ( this.keypath && ( wrapper = this.root.viewmodel.wrapped[ this.keypath.str ] ) ) {\n\t\t\tvalue = wrapper.get();\n\t\t}\n\n\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\tthis.value = value;\n\t\t\tthis.parentFragment.bubble();\n\n\t\t\tif ( this.node ) {\n\t\t\t\trunloop.addView( this );\n\t\t\t}\n\t\t}\n\t},\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\ttoString ( escape ) {\n\t\tvar string = ( '' + safeToStringValue(this.value) );\n\t\treturn escape ? escapeHtml( string ) : string;\n\t}\n};\n\nexport default Interpolator;\n","import getValue from './getValue';\nimport init from './initialise';\nimport resolve from './resolve';\nimport rebind from './rebind';\n\nexport default {\n\tgetValue: getValue,\n\tinit: init,\n\tresolve: resolve,\n\trebind: rebind\n};\n","export default function Mustache$rebind ( oldKeypath, newKeypath ) {\n\t// Children first\n\tif ( this.fragments ) {\n\t\tthis.fragments.forEach( f => f.rebind( oldKeypath, newKeypath ) );\n\t}\n\n\t// Expression mustache?\n\tif ( this.resolver ) {\n\t\tthis.resolver.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function Mustache$resolve ( keypath ) {\n\tvar wasResolved, value, twowayBinding;\n\n\t// 'Special' keypaths, e.g. @foo or @7, encode a value\n\tif ( keypath && keypath.isSpecial ) {\n\t\tthis.keypath = keypath;\n\t\tthis.setValue( keypath.value );\n\t\treturn;\n\t}\n\n\t// If we resolved previously, we need to unregister\n\tif ( this.registered ) { // undefined or null\n\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t\tthis.registered = false;\n\n\t\twasResolved = true;\n\t}\n\n\tthis.keypath = keypath;\n\n\t// If the new keypath exists, we need to register\n\t// with the viewmodel\n\tif ( keypath != undefined ) { // undefined or null\n\t\tvalue = this.root.viewmodel.get( keypath );\n\t\tthis.root.viewmodel.register( keypath, this );\n\n\t\tthis.registered = true;\n\t}\n\n\t// Either way we need to queue up a render (`value`\n\t// will be `undefined` if there's no keypath)\n\tthis.setValue( value );\n\n\t// Two-way bindings need to point to their new target keypath\n\tif ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {\n\t\ttwowayBinding.rebound();\n\t}\n}\n","import { SECTION_UNLESS } from 'config/types';\nimport createReferenceResolver from '../Resolvers/createReferenceResolver';\nimport ReferenceExpressionResolver from '../Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ExpressionResolver from '../Resolvers/ExpressionResolver';\n\nexport default function Mustache$init ( mustache, options ) {\n\n\tvar ref, parentFragment, template;\n\n\tparentFragment = options.parentFragment;\n\ttemplate = options.template;\n\n\tmustache.root           = parentFragment.root;\n\tmustache.parentFragment = parentFragment;\n\tmustache.pElement       = parentFragment.pElement;\n\n\tmustache.template       = options.template;\n\tmustache.index          = options.index || 0;\n\tmustache.isStatic       = options.template.s;\n\n\tmustache.type = options.template.t;\n\n\tmustache.registered = false;\n\n\t// if this is a simple mustache, with a reference, we just need to resolve\n\t// the reference to a keypath\n\tif ( ref = template.r ) {\n\t\tmustache.resolver = createReferenceResolver( mustache, ref, resolve );\n\t}\n\n\t// if it's an expression, we have a bit more work to do\n\tif ( options.template.x ) {\n\t\tmustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );\n\t}\n\n\tif ( options.template.rx ) {\n\t\tmustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );\n\t}\n\n\t// Special case - inverted sections\n\tif ( mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {\n\t\tmustache.setValue( undefined );\n\t}\n\n\tfunction resolve ( keypath ) {\n\t\tmustache.resolve( keypath );\n\t}\n\n\tfunction resolveAndRebindChildren ( newKeypath ) {\n\t\tvar oldKeypath = mustache.keypath;\n\n\t\tif ( newKeypath != oldKeypath ) {\n\t\t\tmustache.resolve( newKeypath );\n\n\t\t\tif ( oldKeypath !== undefined ) {\n\t\t\t\tmustache.fragments && mustache.fragments.forEach( f => {\n\t\t\t\t\tf.rebind( oldKeypath, newKeypath );\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n","import resolveRef from 'shared/resolveRef';\nimport { unbind } from 'shared/methodCallers';\nimport { getKeypath } from 'shared/keypaths';\nimport ReferenceResolver from '../ReferenceResolver';\nimport MemberResolver from './MemberResolver';\n\nvar ReferenceExpressionResolver = function ( mustache, template, callback ) {\n\tvar ractive, ref, keypath, parentFragment;\n\n\tthis.parentFragment = parentFragment = mustache.parentFragment;\n\tthis.root = ractive = mustache.root;\n\tthis.mustache = mustache;\n\n\tthis.ref = ref = template.r;\n\tthis.callback = callback;\n\n\tthis.unresolved = [];\n\n\t// Find base keypath\n\tif ( keypath = resolveRef( ractive, ref, parentFragment ) ) {\n\t\tthis.base = keypath;\n\t} else {\n\t\tthis.baseResolver = new ReferenceResolver( this, ref, keypath => {\n\t\t\tthis.base = keypath;\n\t\t\tthis.baseResolver = null;\n\t\t\tthis.bubble();\n\t\t});\n\t}\n\n\t// Find values for members, or mark them as unresolved\n\tthis.members = template.m.map( template => new MemberResolver( template, this, parentFragment ) );\n\n\tthis.ready = true;\n\tthis.bubble(); // trigger initial resolution if possible\n};\n\nReferenceExpressionResolver.prototype = {\n\tgetKeypath: function () {\n\t\tvar values = this.members.map( getValue );\n\n\t\tif ( !values.every( isDefined ) || this.baseResolver ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.base.join( values.join( '.' ) );\n\t},\n\n\tbubble: function () {\n\t\tif ( !this.ready || this.baseResolver ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.callback( this.getKeypath() );\n\t},\n\n\tunbind: function () {\n\t\tthis.members.forEach( unbind );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tvar changed;\n\n\t\tif ( this.base ) {\n\t\t\tlet newBase = this.base.replace( oldKeypath, newKeypath );\n\t\t\tif ( newBase && newBase !== this.base ) {\n\t\t\t\tthis.base = newBase;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.members.forEach( members => {\n\t\t\tif ( members.rebind( oldKeypath, newKeypath ) ) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t});\n\n\t\tif ( changed ) {\n\t\t\tthis.bubble();\n\t\t}\n\t},\n\n\tforceResolution: function () {\n\t\tif ( this.baseResolver ) {\n\t\t\tthis.base = getKeypath( this.ref );\n\n\t\t\tthis.baseResolver.unbind();\n\t\t\tthis.baseResolver = null;\n\t\t}\n\n\t\tthis.members.forEach( forceResolution );\n\t\tthis.bubble();\n\t}\n};\n\nfunction getValue ( member ) {\n\treturn member.value;\n}\n\nfunction isDefined ( value ) {\n\treturn value != undefined;\n}\n\nfunction forceResolution ( member ) {\n\tmember.forceResolution();\n}\n\nexport default ReferenceExpressionResolver;\n","import { REFERENCE } from 'config/types';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\n\nvar MemberResolver = function ( template, resolver, parentFragment ) {\n\tthis.resolver = resolver;\n\tthis.root = resolver.root;\n\tthis.parentFragment = parentFragment;\n\tthis.viewmodel = resolver.root.viewmodel;\n\n\tif ( typeof template === 'string' ) {\n\t\tthis.value = template;\n\t}\n\n\t// Simple reference?\n\telse if ( template.t === REFERENCE ) {\n\t\tthis.refResolver = createReferenceResolver( this, template.n, keypath => {\n\t\t\tthis.resolve( keypath );\n\t\t});\n\t}\n\n\t// Otherwise we have an expression in its own right\n\telse {\n\t\tnew ExpressionResolver( resolver, parentFragment, template, keypath => {\n\t\t\tthis.resolve( keypath );\n\t\t});\n\t}\n};\n\nMemberResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tif ( this.keypath ) {\n\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.value = this.viewmodel.get( keypath );\n\n\t\tthis.bind();\n\n\t\tthis.resolver.bubble();\n\t},\n\n\tbind: function () {\n\t\tthis.viewmodel.register( this.keypath, this );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tsetValue: function ( value ) {\n\t\tthis.value = value;\n\t\tthis.resolver.bubble();\n\t},\n\n\tunbind: function () {\n\t\tif ( this.keypath ) {\n\t\t\tthis.viewmodel.unregister( this.keypath, this );\n\t\t}\n\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.unbind();\n\t\t}\n\t},\n\n\tforceResolution: function () {\n\t\tif ( this.refResolver ) {\n\t\t\tthis.refResolver.forceResolution();\n\t\t}\n\t}\n};\n\nexport default MemberResolver;\n","import { defineProperty } from 'utils/object';\nimport { getKeypath } from 'shared/keypaths';\nimport getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from './createReferenceResolver';\nimport 'legacy'; // for fn.bind()\n\nvar ExpressionResolver, bind = Function.prototype.bind;\n\nExpressionResolver = function ( owner, parentFragment, expression, callback ) {\n\tvar ractive;\n\n\tractive = owner.root;\n\n\tthis.root = ractive;\n\tthis.parentFragment = parentFragment;\n\tthis.callback = callback;\n\tthis.owner = owner;\n\tthis.str = expression.s;\n\tthis.keypaths = [];\n\n\t// Create resolvers for each reference\n\tthis.pending = expression.r.length;\n\tthis.refResolvers = expression.r.map( ( ref, i ) => {\n\t\treturn createReferenceResolver( this, ref, keypath => {\n\t\t\tthis.resolve( i, keypath );\n\t\t});\n\t});\n\n\tthis.ready = true;\n\tthis.bubble();\n};\n\nExpressionResolver.prototype = {\n\tbubble () {\n\t\tif ( !this.ready ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.uniqueString = getUniqueString( this.str, this.keypaths );\n\t\tthis.keypath = createExpressionKeypath( this.uniqueString );\n\n\t\tthis.createEvaluator();\n\t\tthis.callback( this.keypath );\n\t},\n\n\tunbind () {\n\t\tvar resolver;\n\n\t\twhile ( resolver = this.refResolvers.pop() ) {\n\t\t\tresolver.unbind();\n\t\t}\n\t},\n\n\tresolve ( index, keypath ) {\n\t\tthis.keypaths[ index ] = keypath;\n\t\tthis.bubble();\n\t},\n\n\tcreateEvaluator () {\n\t\tvar computation, valueGetters, signature, keypath, fn;\n\n\t\tkeypath = this.keypath;\n\t\tcomputation = this.root.viewmodel.computations[ keypath.str ];\n\n\t\t// only if it doesn't exist yet!\n\t\tif ( !computation ) {\n\t\t\tfn = getFunctionFromString( this.str, this.refResolvers.length );\n\n\t\t\tvalueGetters = this.keypaths.map( keypath => {\n\t\t\t\tvar value;\n\n\t\t\t\tif ( keypath === 'undefined' ) {\n\t\t\t\t\treturn () => undefined;\n\t\t\t\t}\n\n\t\t\t\t// 'special' keypaths encode a value\n\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\tvalue = keypath.value;\n\t\t\t\t\treturn () => value;\n\t\t\t\t}\n\n\t\t\t\treturn () => {\n\t\t\t\t\tvar value = this.root.viewmodel.get( keypath, { noUnwrap: true, fullRootGet: true });\n\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\tvalue = wrapFunction( value, this.root );\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tsignature = {\n\t\t\t\tdeps: this.keypaths.filter( isValidDependency ),\n\t\t\t\tgetter () {\n\t\t\t\t\tvar args = valueGetters.map( call );\n\t\t\t\t\treturn fn.apply( null, args );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcomputation = this.root.viewmodel.compute( keypath, signature );\n\t\t} else {\n\t\t\tthis.root.viewmodel.mark( keypath );\n\t\t}\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// TODO only bubble once, no matter how many references are affected by the rebind\n\t\tthis.refResolvers.forEach( r => r.rebind( oldKeypath, newKeypath ) );\n\t}\n};\n\nexport default ExpressionResolver;\n\nfunction call ( value ) {\n\treturn value.call();\n}\n\nfunction getUniqueString ( str, keypaths ) {\n\t// get string that is unique to this expression\n\treturn str.replace( /_([0-9]+)/g, function ( match, $1 ) {\n\t\tvar keypath, value;\n\n\t\t// make sure we're not replacing a non-keypath _[0-9]\n\t\tif ( +$1 >= keypaths.length ) {\n\t\t\treturn `_${$1}`;\n\t\t}\n\n\t\tkeypath = keypaths[ $1 ];\n\n\t\tif ( keypath === undefined ) {\n\t\t\treturn 'undefined';\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\tvalue = keypath.value;\n\t\t\treturn typeof value === 'number' ? value : '\"' + value + '\"';\n\t\t}\n\n\t\treturn keypath.str;\n\t});\n}\n\nfunction createExpressionKeypath ( uniqueString ) {\n\t// Sanitize by removing any periods or square brackets. Otherwise\n\t// we can't split the keypath into keys!\n\t// Remove asterisks too, since they mess with pattern observers\n\treturn getKeypath( '${' + uniqueString.replace( /[\\.\\[\\]]/g, '-' ).replace( /\\*/, '#MUL#' ) + '}' );\n}\n\nfunction isValidDependency ( keypath ) {\n\treturn keypath !== undefined && keypath[0] !== '@';\n}\n\nfunction wrapFunction ( fn, ractive ) {\n\tvar wrapped, prop, key;\n\n\tif ( fn.__ractive_nowrap ) {\n\t\treturn fn;\n\t}\n\n\tprop = '__ractive_' + ractive._guid;\n\twrapped = fn[ prop ];\n\n\tif ( wrapped ) {\n\t\treturn wrapped;\n\t}\n\n\telse if ( /this/.test( fn.toString() ) ) {\n\t\tdefineProperty( fn, prop, {\n\t\t\tvalue: bind.call( fn, ractive ),\n\t\t\tconfigurable: true\n\t\t});\n\n\t\t// Add properties/methods to wrapped function\n\t\tfor ( key in fn ) {\n\t\t\tif ( fn.hasOwnProperty( key ) ) {\n\t\t\t\tfn[ prop ][ key ] = fn[ key ];\n\t\t\t}\n\t\t}\n\n\t\tractive._boundFunctions.push({\n\t\t\tfn: fn,\n\t\t\tprop: prop\n\t\t});\n\n\t\treturn fn[ prop ];\n\t}\n\n\tdefineProperty( fn, '__ractive_nowrap', {\n\t\tvalue: fn\n\t});\n\n\treturn fn.__ractive_nowrap;\n}\n","var cache = {};\n\nexport default function getFunctionFromString ( str, i ) {\n\tvar fn, args;\n\n\tif ( cache[ str ] ) {\n\t\treturn cache[ str ];\n\t}\n\n\targs = [];\n\twhile ( i-- ) {\n\t\targs[i] = '_' + i;\n\t}\n\n\tfn = new Function( args.join( ',' ), 'return(' + str + ')' );\n\n\tcache[ str ] = fn;\n\treturn fn;\n}\n","import ReferenceResolver from './ReferenceResolver';\nimport SpecialResolver from './SpecialResolver';\nimport IndexResolver from './IndexResolver';\nimport findIndexRefs from './findIndexRefs';\n\nexport default function createReferenceResolver ( owner, ref, callback ) {\n\tvar indexRef;\n\n\tif ( ref.charAt( 0 ) === '@' ) {\n\t\treturn new SpecialResolver( owner, ref, callback );\n\t}\n\n\tif ( indexRef = findIndexRefs( owner.parentFragment, ref ) ) {\n\t\treturn new IndexResolver( owner, indexRef, callback );\n\t}\n\n\treturn new ReferenceResolver( owner, ref, callback );\n}\n","export default findIndexRefs;\n\nfunction findIndexRefs( fragment, refName ) {\n\tvar result = {}, refs, fragRefs, ref, i, owner, hit = false;\n\n\tif ( !refName ) {\n\t\tresult.refs = refs = {};\n\t}\n\n\twhile ( fragment ) {\n\t\tif ( ( owner = fragment.owner ) && ( fragRefs = owner.indexRefs ) ) {\n\n\t\t\t// we're looking for a particular ref, and it's here\n\t\t\tif ( refName && ( ref = owner.getIndexRef( refName ) ) ) {\n\t\t\t\tresult.ref = {\n\t\t\t\t\tfragment: fragment,\n\t\t\t\t\tref: ref\n\t\t\t\t};\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// we're collecting refs up-tree\n\t\t\telse if ( !refName ) {\n\t\t\t\tfor ( i in fragRefs ) {\n\t\t\t\t\tref = fragRefs[i];\n\n\t\t\t\t\t// don't overwrite existing refs - they should shadow parents\n\t\t\t\t\tif ( !refs[ref.n] ) {\n\t\t\t\t\t\thit = true;\n\t\t\t\t\t\trefs[ref.n] = {\n\t\t\t\t\t\t\tfragment: fragment,\n\t\t\t\t\t\t\tref: ref\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// watch for component boundaries\n\t\tif ( !fragment.parent && fragment.owner &&\n\t\t     fragment.owner.component && fragment.owner.component.parentFragment &&\n\t\t     !fragment.owner.component.instance.isolated ) {\n\t\t\tresult.componentBoundary = true;\n\t\t\tfragment = fragment.owner.component.parentFragment;\n\t\t} else {\n\t\t\tfragment = fragment.parent;\n\t\t}\n\t}\n\n\tif ( !hit ) {\n\t\treturn undefined;\n\t} else {\n\t\treturn result;\n\t}\n}\n\nfindIndexRefs.resolve = function resolve( indices ) {\n\tvar refs = {}, k, ref;\n\n\tfor ( k in indices.refs ) {\n\t\tref = indices.refs[k];\n\t\trefs[ ref.ref.n ] = ref.ref.t === 'k' ? ref.fragment.key : ref.fragment.index;\n\t}\n\n\treturn refs;\n};\n","import { getKeypath } from 'shared/keypaths'; // TODO find a better way than @\n\nvar IndexResolver = function ( owner, ref, callback ) {\n\tthis.parentFragment = owner.parentFragment;\n\tthis.ref = ref;\n\tthis.callback = callback;\n\n\tref.ref.fragment.registerIndexRef( this );\n\n\tthis.rebind();\n};\n\nIndexResolver.prototype = {\n\trebind: function () {\n\t\tvar index, ref = this.ref.ref;\n\n\t\tif ( ref.ref.t === 'k' ) {\n\t\t\tindex = 'k' + ref.fragment.key;\n\t\t} else {\n\t\t\tindex = 'i' + ref.fragment.index;\n\t\t}\n\n\t\tif ( index !== undefined ) {\n\t\t\tthis.callback( getKeypath( '@' + index ) );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tthis.ref.ref.fragment.unregisterIndexRef( this );\n\t}\n};\n\nexport default IndexResolver;\n","import { SECTION_EACH } from 'config/types';\nimport { getKeypath } from 'shared/keypaths'; // TODO maybe we don't need the @ construct now that we have Keypath objects?\n\nvar SpecialResolver = function ( owner, ref, callback ) {\n\tthis.parentFragment = owner.parentFragment;\n\tthis.ref = ref;\n\tthis.callback = callback;\n\n\tthis.rebind();\n};\n\nvar props = {\n\t'@keypath': { prefix: 'c', prop: [ 'context' ] },\n\t'@index': { prefix: 'i', prop: [ 'index' ] },\n\t'@key': { prefix: 'k', prop: [ 'key', 'index' ] }\n};\n\nfunction getProp( target, prop ) {\n\tvar value;\n\tfor ( let i = 0; i < prop.prop.length; i++ ) {\n\t\tif ( ( value = target[prop.prop[i]] ) !== undefined ) {\n\t\t\treturn value;\n\t\t}\n\t}\n}\n\nSpecialResolver.prototype = {\n\trebind: function () {\n\t\tvar ref = this.ref, fragment = this.parentFragment, prop = props[ref], value;\n\n\t\tif ( !prop ) {\n\t\t\tthrow new Error( 'Unknown special reference \"' + ref + '\" - valid references are @index, @key and @keypath' );\n\t\t}\n\n\t\t// have we already found the nearest parent?\n\t\tif ( this.cached ) {\n\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + getProp( this.cached, prop ) ) );\n\t\t}\n\n\t\t// special case for indices, which may cross component boundaries\n\t\tif ( prop.prop.indexOf( 'index' ) !== -1 || prop.prop.indexOf( 'key' ) !== -1 ) {\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( fragment.owner.currentSubtype === SECTION_EACH && ( value = getProp( fragment, prop ) ) !== undefined ) {\n\t\t\t\t\tthis.cached = fragment;\n\n\t\t\t\t\tfragment.registerIndexRef( this );\n\n\t\t\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + value ) );\n\t\t\t\t}\n\n\t\t\t\t// watch for component boundaries\n\t\t\t\tif ( !fragment.parent && fragment.owner &&\n\t\t\t\t     fragment.owner.component && fragment.owner.component.parentFragment &&\n\t\t\t\t     !fragment.owner.component.instance.isolated ) {\n\t\t\t\t\tfragment = fragment.owner.component.parentFragment;\n\t\t\t\t} else {\n\t\t\t\t\tfragment = fragment.parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\twhile ( fragment ) {\n\t\t\t\tif ( ( value = getProp( fragment, prop ) ) !== undefined ) {\n\t\t\t\t\treturn this.callback( getKeypath( '@' + prop.prefix + value.str ) );\n\t\t\t\t}\n\n\t\t\t\tfragment = fragment.parent;\n\t\t\t}\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tif ( this.cached ) {\n\t\t\tthis.cached.unregisterIndexRef( this );\n\t\t}\n\t}\n};\n\nexport default SpecialResolver;\n","import runloop from 'global/runloop';\nimport { getKeypath } from 'shared/keypaths';\nimport resolveRef from 'shared/resolveRef';\n\nvar ReferenceResolver = function ( owner, ref, callback ) {\n\tvar keypath;\n\n\tthis.ref = ref;\n\tthis.resolved = false;\n\n\tthis.root = owner.root;\n\tthis.parentFragment = owner.parentFragment;\n\tthis.callback = callback;\n\n\tkeypath = resolveRef( owner.root, ref, owner.parentFragment );\n\tif ( keypath != undefined ) {\n\t\tthis.resolve( keypath );\n\t}\n\n\telse {\n\t\trunloop.addUnresolved( this );\n\t}\n};\n\nReferenceResolver.prototype = {\n\tresolve: function ( keypath ) {\n\t\tif ( this.keypath && !keypath ) {\n\t\t\t// it was resolved, and now it's not. Can happen if e.g. `bar` in\n\t\t\t// `{{foo[bar]}}` becomes undefined\n\t\t\trunloop.addUnresolved( this );\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\tthis.keypath = keypath;\n\t\tthis.callback( keypath );\n\t},\n\n\tforceResolution: function () {\n\t\tthis.resolve( getKeypath( this.ref ) );\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tvar keypath;\n\n\t\tif ( this.keypath != undefined ) {\n\t\t\tkeypath = this.keypath.replace( oldKeypath, newKeypath );\n\t\t\t// was a new keypath created?\n\t\t\tif ( keypath !== undefined ) {\n\t\t\t\t// resolve it\n\t\t\t\tthis.resolve( keypath );\n\t\t\t}\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tif ( !this.resolved ) {\n\t\t\trunloop.removeUnresolved( this );\n\t\t}\n\t}\n};\n\n\nexport default ReferenceResolver;\n","export default function Mustache$getValue () {\n\treturn this.value;\n}\n","export default function unbind () {\n\tif ( this.registered ) {\n\t\t// this was registered as a dependant\n\t\tthis.root.viewmodel.unregister( this.keypath, this );\n\t}\n\n\tif ( this.resolver ) {\n\t\tthis.resolver.unbind();\n\t}\n}\n","import { TEXT } from 'config/types';\nimport { escapeHtml } from 'utils/html';\nimport detach from './shared/detach';\n\nvar Text = function ( options ) {\n\tthis.type = TEXT;\n\tthis.text = options.template;\n};\n\nText.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createTextNode( this.text );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString ( escape ) {\n\t\treturn escape ? escapeHtml( this.text ) : this.text;\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\treturn this.detach();\n\t\t}\n\t}\n};\n\nexport default Text;\n","import { detachNode } from 'utils/dom';\n\nexport default function () {\n\treturn detachNode( this.node );\n}\n","import parseJSON from 'utils/parseJSON';\nimport processItems from './shared/processItems';\n\nexport default function Fragment$getValue () {\n\tvar values, source, parsed, result;\n\n\tif ( this.dirtyValue ) {\n\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\tparsed = parseJSON( source, values );\n\n\t\tif ( !parsed ) {\n\t\t\tresult = this.toString();\n\t\t} else {\n\t\t\tresult = parsed.value;\n\t\t}\n\n\t\tthis.value = result;\n\t\tthis.dirtyValue = false;\n\t}\n\n\treturn this.value;\n}","export default function Fragment$getNode () {\n\tvar fragment = this;\n\n\tdo  {\n\t\tif ( fragment.pElement ) {\n\t\t\treturn fragment.pElement.node;\n\t\t}\n\t} while ( fragment = fragment.parent );\n\n\treturn this.root.detached || this.root.el;\n}\n","import parseJSON from 'utils/parseJSON';\nimport processItems from './shared/processItems';\n\nexport default function Fragment$getArgsList () {\n\tvar values, source, parsed, result;\n\n\tif ( this.dirtyArgs ) {\n\t\tsource = processItems( this.items, values = {}, this.root._guid );\n\t\tparsed = parseJSON( '[' + source + ']', values );\n\n\t\tif ( !parsed ) {\n\t\t\tresult = [ this.toString() ];\n\t\t} else {\n\t\t\tresult = parsed.value;\n\t\t}\n\n\t\tthis.argsList = result;\n\t\tthis.dirtyArgs = false;\n\t}\n\n\treturn this.argsList;\n}","export default function processItems ( items, values, guid, counter ) {\n\tcounter = counter || 0;\n\n\treturn items.map( function ( item ) {\n\t\tvar placeholderId, wrapped, value;\n\n\t\tif ( item.text ) {\n\t\t\treturn item.text;\n\t\t}\n\n\t\tif ( item.fragments ) {\n\t\t\treturn item.fragments.map( function ( fragment ) {\n\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t\t\t}).join( '' );\n\t\t}\n\n\t\tplaceholderId = guid + '-' + counter++;\n\n\t\tif ( item.keypath && ( wrapped = item.root.viewmodel.wrapped[ item.keypath.str ] ) ) {\n\t\t\tvalue = wrapped.value;\n\t\t} else {\n\t\t\tvalue = item.getValue();\n\t\t}\n\n\t\tvalues[ placeholderId ] = value;\n\n\t\treturn '${' + placeholderId + '}';\n\t}).join( '' );\n}","export default function Fragment$firstNode () {\n\tif ( this.items && this.items[0] ) {\n\t\treturn this.items[0].firstNode();\n\t}\n\n\treturn null;\n}\n","export default function Fragment$findNextNode ( item ) {\n\tvar index = item.index, node;\n\n\tif ( this.items[ index + 1 ] ) {\n\t\tnode = this.items[ index + 1 ].firstNode();\n\t}\n\n\t// if this is the root fragment, and there are no more items,\n\t// it means we're at the end...\n\telse if ( this.owner === this.root ) {\n\t\tif ( !this.owner.component ) {\n\t\t\t// TODO but something else could have been appended to\n\t\t\t// this.root.el, no?\n\t\t\tnode = null;\n\t\t}\n\n\t\t// ...unless this is a component\n\t\telse {\n\t\t\tnode = this.owner.component.findNextNode();\n\t\t}\n\t}\n\n\telse {\n\t\tnode = this.owner.findNextNode( this );\n\t}\n\n\treturn node;\n}\n","export default function Fragment$findComponent ( selector ) {\n\tvar len, i, item, queryResult;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","export default function Fragment$findAllComponents ( selector, query ) {\n\tvar i, len, item;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.findAllComponents ) {\n\t\t\t\titem.findAllComponents( selector, query );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn query;\n}\n","export default function Fragment$findAll ( selector, query ) {\n\tvar i, len, item;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.findAll ) {\n\t\t\t\titem.findAll( selector, query );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn query;\n}\n","export default function Fragment$find ( selector ) {\n\tvar i, len, item, queryResult;\n\n\tif ( this.items ) {\n\t\tlen = this.items.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\titem = this.items[i];\n\n\t\t\tif ( item.find && ( queryResult = item.find( selector ) ) ) {\n\t\t\t\treturn queryResult;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","export default function Fragment$detach () {\n\tvar docFrag;\n\n\tif ( this.items.length === 1 ) {\n\t\treturn this.items[0].detach();\n\t}\n\n\tdocFrag = document.createDocumentFragment();\n\n\tthis.items.forEach( item => {\n\t\tvar node = item.detach();\n\n\t\t// TODO The if {...} wasn't previously required - it is now, because we're\n\t\t// forcibly detaching everything to reorder sections after an update. That's\n\t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n\t\t// - as soon as it's replaced with something more elegant, this should\n\t\t// revert to `docFrag.appendChild( item.detach() )`\n\t\tif ( node ) {\n\t\t\tdocFrag.appendChild( node );\n\t\t}\n\t});\n\n\treturn docFrag;\n}\n","export default function Fragment$bubble () {\n\tthis.dirtyValue = this.dirtyArgs = true;\n\n\tif ( this.bound && typeof this.owner.bubble === 'function' ) {\n\t\tthis.owner.bubble();\n\t}\n}\n","import { warnIfDebug } from 'utils/log';\nimport adaptConfigurator from './custom/adapt';\nimport cssConfigurator from './custom/css/css';\nimport dataConfigurator from './custom/data';\nimport templateConfigurator from './custom/template/template';\nimport defaults from './defaults';\nimport registries from './registries';\nimport wrapPrototype from './wrapPrototypeMethod';\nimport deprecate from './deprecate';\n\nvar config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\ncustom = {\n\tadapt: adaptConfigurator,\n\tcss: cssConfigurator,\n\tdata: dataConfigurator,\n\ttemplate: templateConfigurator\n};\n\ndefaultKeys = Object.keys( defaults );\n\nisStandardKey = makeObj( defaultKeys.filter( key => !custom[ key ] ) );\n\n// blacklisted keys that we don't double extend\nisBlacklisted = makeObj( defaultKeys.concat( registries.map( r => r.name ) ) );\n\norder = [].concat(\n\tdefaultKeys.filter( key => !registries[ key ] && !custom[ key ] ),\n\tregistries,\n\tcustom.data,\n\tcustom.template,\n\tcustom.css\n);\n\nconfig = {\n\textend: ( Parent, proto, options ) => configure( 'extend', Parent, proto, options ),\n\n\tinit: ( Parent, ractive, options ) => configure( 'init', Parent, ractive, options ),\n\n\treset: ractive => {\n\t\treturn order.filter( c => {\n\t\t\treturn c.reset && c.reset( ractive );\n\t\t}).map( c => c.name );\n\t},\n\n\t// this defines the order. TODO this isn't used anywhere in the codebase,\n\t// only in the test suite - should get rid of it\n\torder,\n};\n\nfunction configure ( method, Parent, target, options ) {\n\tdeprecate( options );\n\n\tfor ( let key in options ) {\n\t\tif ( isStandardKey.hasOwnProperty( key ) ) {\n\t\t\tlet value = options[ key ];\n\n\t\t\t// warn the developer if they passed a function and ignore its value\n\n\t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n\t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n\t\t\t// function object as the result of querySelector methods\n\t\t\tif ( key !== 'el' && typeof value === 'function' ) {\n\t\t\t\twarnIfDebug( `${ key } is a Ractive option that does not expect a function and will be ignored`,\n\t\t\t\t\tmethod === 'init' ? target : null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttarget[ key ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\tregistries.forEach( registry => {\n\t\tregistry[ method ]( Parent, target, options );\n\t});\n\n\tadaptConfigurator[ method ]( Parent, target, options );\n\ttemplateConfigurator[ method ]( Parent, target, options );\n\tcssConfigurator[ method ]( Parent, target, options );\n\n\textendOtherMethods( Parent.prototype, target, options );\n}\n\nfunction extendOtherMethods ( parent, target, options ) {\n\tfor ( let key in options ) {\n\t\tif ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {\n\t\t\tlet member = options[ key ];\n\n\t\t\t// if this is a method that overwrites a method, wrap it:\n\t\t\tif ( typeof member === 'function' ) {\n\t\t\t\tmember = wrapPrototype( parent, key, member );\n\t\t\t}\n\n\t\t\ttarget[ key ] = member;\n\t\t}\n\t}\n}\n\nfunction makeObj ( array ) {\n\tvar obj = {};\n\tarray.forEach( x => obj[x] = true );\n\treturn obj;\n}\n\nexport default config;\n","import { warnIfDebug } from 'utils/log';\nimport { isArray } from 'utils/is';\n\nfunction getMessage( deprecated, correct, isError ) {\n\treturn `options.${deprecated} has been deprecated in favour of options.${correct}.`\n\t\t+ ( isError ? ` You cannot specify both options, please use options.${correct}.` : '' );\n}\n\nfunction deprecateOption ( options, deprecatedOption, correct ) {\n\tif ( deprecatedOption in options ) {\n\t\tif( !( correct in options ) ) {\n\t\t\twarnIfDebug( getMessage( deprecatedOption, correct ) );\n\t\t\toptions[ correct ] = options[ deprecatedOption ];\n\t\t} else {\n\t\t\tthrow new Error( getMessage( deprecatedOption, correct, true ) );\n\t\t}\n\t}\n}\n\nexport default function deprecate ( options ) {\n\tdeprecateOption( options, 'beforeInit', 'onconstruct' );\n\tdeprecateOption( options, 'init', 'onrender' );\n\tdeprecateOption( options, 'complete', 'oncomplete' );\n\tdeprecateOption( options, 'eventDefinitions', 'events' );\n\n\t// Using extend with Component instead of options,\n\t// like Human.extend( Spider ) means adaptors as a registry\n\t// gets copied to options. So we have to check if actually an array\n\tif ( isArray( options.adaptors ) ) {\n\t\tdeprecateOption( options, 'adaptors', 'adapt' );\n\t}\n}\n","import noop from 'utils/noop';\n\nexport default function wrap ( parent, name, method ) {\n\tif ( !/_super/.test( method ) ) {\n\t\treturn method;\n\t}\n\n\tvar wrapper = function wrapSuper () {\n\t\tvar superMethod = getSuperMethod( wrapper._parent, name ),\n\t\t\thasSuper = ( '_super' in this ),\n\t\t\toldSuper = this._super,\n\t\t\tresult;\n\n\t\tthis._super = superMethod;\n\n\t\tresult = method.apply( this, arguments );\n\n\t\tif ( hasSuper ) {\n\t\t\tthis._super = oldSuper;\n\t\t} else {\n\t\t\tdelete this._super;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\twrapper._parent = parent;\n\twrapper._method = method;\n\n\treturn wrapper;\n}\n\nfunction getSuperMethod ( parent, name ) {\n\tvar value, method;\n\n\tif ( name in parent ) {\n\t\tvalue = parent[name];\n\n\t\tif ( typeof value === 'function' ) {\n\t\t\tmethod = value;\n\t\t} else {\n\t\t\tmethod = function returnValue () {\n\t\t\t\treturn value;\n\t\t\t};\n\t\t}\n\t} else {\n\t\tmethod = noop;\n\t}\n\n\treturn method;\n}\n","import { create } from 'utils/object';\nimport 'legacy';\n\nvar registryNames, Registry, registries;\n\nregistryNames = [\n\t'adaptors',\n\t'components',\n\t'computed',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nRegistry = function ( name, useDefaults ) {\n\tthis.name = name;\n\tthis.useDefaults = useDefaults;\n};\n\nRegistry.prototype = {\n\tconstructor: Registry,\n\n \textend: function ( Parent, proto, options ) {\n\t\tthis.configure(\n\t\t\tthis.useDefaults ? Parent.defaults : Parent,\n\t\t\tthis.useDefaults ? proto : proto.constructor,\n\t\t\toptions );\n\t},\n\n\tinit: function () {\n\t\t/*this.configure(\n\t\t\tthis.useDefaults ? Parent.defaults : Parent,\n\t\t\tractive,\n\t\t\toptions );*/\n\t},\n\n\tconfigure: function ( Parent, target, options ) {\n\t\tvar name = this.name, option = options[ name ], registry;\n\n\t\tregistry = create( Parent[name] );\n\n\t\tfor ( let key in option ) {\n\t\t\tregistry[ key ] = option[ key ];\n\t\t}\n\n\t\ttarget[ name ] = registry;\n\t},\n\n\treset: function ( ractive ) {\n\t\tvar registry = ractive[ this.name ];\n\t\tvar changed = false;\n\t\tObject.keys( registry ).forEach( key => {\n\t\t\tvar item = registry[key];\n\t\t\tif ( item._fn ) {\n\t\t\t\tif ( item._fn.isOwner ) {\n\t\t\t\t\tregistry[key] = item._fn;\n\t\t\t\t} else {\n\t\t\t\t\tdelete registry[key];\n\t\t\t\t}\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t});\n\t\treturn changed;\n\t}\n};\n\nregistries = registryNames.map( name => new Registry( name, name === 'computed' ) );\n\nexport default registries;\n","import { TEMPLATE_VERSION } from 'config/template';\nimport { create } from 'utils/object';\nimport parser from './parser';\nimport parse from 'parse/_parse';\n\nvar templateConfigurator = {\n\tname: 'template',\n\n\textend: function extend ( Parent, proto, options ) {\n\t\tvar template;\n\n\t\t// only assign if exists\n\t\tif ( 'template' in options ) {\n\t\t\ttemplate = options.template;\n\n\t\t\tif ( typeof template === 'function' ) {\n\t\t\t\tproto.template = template;\n\t\t\t} else {\n\t\t\t\tproto.template = parseIfString( template, proto );\n\t\t\t}\n\t\t}\n\t},\n\n\tinit: function init ( Parent, ractive, options ) {\n\t\tvar template, fn;\n\n\t\t// TODO because of prototypal inheritance, we might just be able to use\n\t\t// ractive.template, and not bother passing through the Parent object.\n\t\t// At present that breaks the test mocks' expectations\n\t\ttemplate = 'template' in options ? options.template : Parent.prototype.template;\n\n\t\tif ( typeof template === 'function' ) {\n\t\t\tfn = template;\n\t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\n\t\t\tractive._config.template = {\n\t\t\t\tfn: fn,\n\t\t\t\tresult: template\n\t\t\t};\n\t\t}\n\n\t\ttemplate = parseIfString( template, ractive );\n\n\t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t\t// it's unnecessary, because the developer never needs to access\n\t\t// ractive.template\n\t\tractive.template = template.t;\n\n\t\tif ( template.p ) {\n\t\t\textendPartials( ractive.partials, template.p );\n\t\t}\n\t},\n\n\treset: function ( ractive ) {\n\t\tvar result = resetValue( ractive ), parsed;\n\n\t\tif ( result ) {\n\t\t\tparsed = parseIfString( result, ractive );\n\n\t\t\tractive.template = parsed.t;\n\t\t\textendPartials( ractive.partials, parsed.p, true );\n\n\t\t\treturn true;\n\t\t}\n\t}\n};\n\nfunction resetValue ( ractive ) {\n\tvar initial = ractive._config.template, result;\n\n\t// If this isn't a dynamic template, there's nothing to do\n\tif ( !initial || !initial.fn ) {\n\t\treturn;\n\t}\n\n\tresult = getDynamicTemplate( ractive, initial.fn );\n\n\t// TODO deep equality check to prevent unnecessary re-rendering\n\t// in the case of already-parsed templates\n\tif ( result !== initial.result ) {\n\t\tinitial.result = result;\n\t\tresult = parseIfString( result, ractive );\n\t\treturn result;\n\t}\n}\n\nfunction getDynamicTemplate ( ractive, fn ) {\n\tvar helper = createHelper( parser.getParseOptions( ractive ) );\n\treturn fn.call( ractive, helper );\n}\n\nfunction createHelper ( parseOptions ) {\n\tvar helper = create( parser );\n\thelper.parse = function ( template, options ){\n\t\treturn parser.parse( template, options || parseOptions );\n\t};\n\treturn helper;\n}\n\nfunction parseIfString ( template, ractive ) {\n\tif ( typeof template === 'string' ) {\n\t\t// ID of an element containing the template?\n\t\tif ( template[0] === '#' ) {\n\t\t\ttemplate = parser.fromId( template );\n\t\t}\n\n\t\ttemplate = parse( template, parser.getParseOptions( ractive ) );\n\t}\n\n\t// Check that the template even exists\n\telse if ( template == undefined ) {\n\t\tthrow new Error( `The template cannot be ${template}.` );\n\t}\n\n\t// Check the parsed template has a version at all\n\telse if ( typeof template.v !== 'number' ) {\n\t\tthrow new Error( 'The template parser was passed a non-string template, but the template doesn\\'t have a version.  Make sure you\\'re passing in the template you think you are.' );\n\t}\n\n\t// Check we're using the correct version\n\telse if ( template.v !== TEMPLATE_VERSION ) {\n\t\tthrow new Error( `Mismatched template version (expected ${TEMPLATE_VERSION}, got ${template.v}) Please ensure you are using the latest version of Ractive.js in your build process as well as in your app` );\n\t}\n\n\treturn template;\n}\n\nfunction extendPartials ( existingPartials, newPartials, overwrite ) {\n\tif ( !newPartials ) return;\n\n\t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t// case, but not initially...\n\n\tfor ( let key in newPartials ) {\n\t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t\t\texistingPartials[ key ] = newPartials[ key ];\n\t\t}\n\t}\n}\n\nexport default templateConfigurator;\n","import { isClient } from 'config/environment';\nimport parse from 'parse/_parse';\nimport { create } from 'utils/object';\n\nvar parseOptions = [\n \t'preserveWhitespace',\n\t'sanitize',\n\t'stripComments',\n\t'delimiters',\n\t'tripleDelimiters',\n\t'interpolate'\n];\n\nvar parser = {\n\tfromId, isHashedId, isParsed, getParseOptions, createHelper,\n\tparse: doParse\n};\n\nfunction createHelper ( parseOptions ) {\n\tvar helper = create( parser );\n\thelper.parse = ( template, options ) => doParse( template, options || parseOptions );\n\treturn helper;\n}\n\nfunction doParse ( template, parseOptions ) {\n\tif ( !parse ) {\n\t\tthrow new Error( 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser' );\n\t}\n\n\treturn parse( template, parseOptions || this.options );\n}\n\nfunction fromId ( id, options ) {\n\tvar template;\n\n\tif ( !isClient ) {\n\t\tif ( options && options.noThrow ) { return; }\n\t\tthrow new Error( `Cannot retrieve template #${id} as Ractive is not running in a browser.` );\n\t}\n\n\tif ( isHashedId( id ) ) {\n\t\tid = id.substring( 1 );\n\t}\n\n\tif ( !( template = document.getElementById( id ) )) {\n\t\tif ( options && options.noThrow ) { return; }\n\t\tthrow new Error( `Could not find template element with id #${id}` );\n\t}\n\n\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t\tif ( options && options.noThrow ) { return; }\n\t\tthrow new Error( `Template element with id #${id}, must be a <script> element` );\n\t}\n\n\treturn ( 'textContent' in template ? template.textContent : template.innerHTML );\n}\n\nfunction isHashedId ( id ) {\n\treturn ( id && id[0] === '#' );\n}\n\nfunction isParsed ( template) {\n\treturn !( typeof template === 'string' );\n}\n\nfunction getParseOptions ( ractive ) {\n\t// Could be Ractive or a Component\n\tif ( ractive.defaults ) { ractive = ractive.defaults; }\n\n\treturn parseOptions.reduce( ( val, key ) => {\n\t\tval[ key ] = ractive[ key ];\n\t\treturn val;\n\t}, {});\n}\n\nexport default parser;\n","import { TEMPLATE_VERSION } from 'config/template';\nimport Parser from './Parser';\nimport readMustache from './converters/readMustache';\nimport readTriple from './converters/mustache/readTriple';\nimport readUnescaped from './converters/mustache/readUnescaped';\nimport readPartial from './converters/mustache/readPartial';\nimport readMustacheComment from './converters/mustache/readMustacheComment';\nimport readInterpolator from './converters/mustache/readInterpolator';\nimport readYielder from './converters/mustache/readYielder';\nimport readSection from './converters/mustache/readSection';\nimport readHtmlComment from './converters/readHtmlComment';\nimport readElement from './converters/readElement';\nimport readText from './converters/readText';\nimport readPartialDefinitionComment from './converters/readPartialDefinitionComment';\nimport readPartialDefinitionSection from './converters/readPartialDefinitionSection';\nimport readTemplate from './converters/readTemplate';\nimport cleanup from './utils/cleanup';\n\n// See https://github.com/ractivejs/template-spec for information\n// about the Ractive template specification\n\nlet STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readMustacheComment ];\nlet TRIPLE_READERS = [ readTriple ];\nlet STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?\n\nlet StandardParser;\n\nexport default function parse ( template, options ) {\n\treturn new StandardParser( template, options || {} ).result;\n}\n\nexport const READERS = [ readMustache, readHtmlComment, readElement, readText ];\nexport const PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];\n\nStandardParser = Parser.extend({\n\tinit ( str, options ) {\n\t\tvar tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],\n\t\t\tstaticDelimiters = options.staticDelimiters || [ '[[', ']]' ],\n\t\t\tstaticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];\n\n\t\tthis.standardDelimiters = options.delimiters || [ '{{', '}}' ];\n\n\t\tthis.tags = [\n\t\t\t{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },\n\t\t\t{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },\n\t\t\t{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },\n\t\t\t{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }\n\t\t];\n\n\t\tthis.sortMustacheTags();\n\n\t\tthis.sectionDepth = 0;\n\t\tthis.elementStack = [];\n\n\t\tthis.interpolate = {\n\t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n\t\t};\n\n\t\tif ( options.sanitize === true ) {\n\t\t\toptions.sanitize = {\n\t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t\t\t\teventAttributes: true\n\t\t\t};\n\t\t}\n\n\t\tthis.stripComments = options.stripComments !== false;\n\t\tthis.preserveWhitespace = options.preserveWhitespace;\n\t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t\tthis.includeLinePositions = options.includeLinePositions;\n\t},\n\n\tpostProcess ( result ) {\n\t\t// special case - empty string\n\t\tif ( !result.length ) {\n\t\t\treturn { t: [], v: TEMPLATE_VERSION };\n\t\t}\n\n\t\tif ( this.sectionDepth > 0 ) {\n\t\t\tthis.error( 'A section was left open' );\n\t\t}\n\n\t\tcleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );\n\n\t\treturn result[0];\n\t},\n\n\tconverters: [\n\t\treadTemplate\n\t],\n\n\tsortMustacheTags () {\n\t\t// Sort in order of descending opening delimiter length (longer first),\n\t\t// to protect against opening delimiters being substrings of each other\n\t\tthis.tags.sort( ( a, b ) => {\n\t\t\treturn b.open.length - a.open.length;\n\t\t});\n\t}\n});\n","import { TEMPLATE_VERSION } from 'config/template';\nimport { create } from 'utils/object';\nimport { READERS, PARTIAL_READERS } from '../_parse';\nimport cleanup from '../utils/cleanup';\n\nexport default function readTemplate ( parser ) {\n\tlet fragment = [];\n\tlet partials = create( null );\n\tlet hasPartials = false;\n\n\tlet preserveWhitespace = parser.preserveWhitespace;\n\n\twhile ( parser.pos < parser.str.length ) {\n\t\tlet pos = parser.pos, item, partial;\n\n\t\tif ( partial = parser.read( PARTIAL_READERS ) ) {\n\t\t\tif ( partials[ partial.n ] ) {\n\t\t\t\tparser.pos = pos;\n\t\t\t\tparser.error( 'Duplicated partial definition' );\n\t\t\t}\n\n\t\t\tcleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\n\t\t\tpartials[ partial.n ] = partial.f;\n\t\t\thasPartials = true;\n\t\t} else if ( item = parser.read( READERS ) ) {\n\t\t\tfragment.push( item );\n\t\t} else  {\n\t\t\tparser.error( 'Unexpected template content' );\n\t\t}\n\t}\n\n\tlet result = {\n\t\tv: TEMPLATE_VERSION,\n\t\tt: fragment\n\t};\n\n\tif ( hasPartials ) {\n\t\tresult.p = partials;\n\t}\n\n\treturn result;\n}\n","import { INLINE_PARTIAL } from 'config/types';\nimport { READERS } from '../_parse';\nimport readClosing from './mustache/section/readClosing';\n\nvar partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n\nexport default function readPartialDefinitionSection ( parser ) {\n\tvar start, name, content, child, closed;\n\n\tstart = parser.pos;\n\n\tlet delimiters = parser.standardDelimiters;\n\n\tif ( !parser.matchString( delimiters[0] ) ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\n\tif ( !name ) {\n\t\tparser.error( 'expected legal partial name' );\n\t}\n\n\tif ( !parser.matchString( delimiters[1] ) ) {\n\t\tparser.error( `Expected closing delimiter '${delimiters[1]}'` );\n\t}\n\n\tcontent = [];\n\n\tdo {\n\t\t// TODO clean this up\n\t\tif ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {\n\t\t\tif ( !child.r === 'partial' ) {\n\t\t\t\tparser.error( `Expected ${delimiters[0]}/partial${delimiters[1]}` );\n\t\t\t}\n\n\t\t\tclosed = true;\n\t\t}\n\n\t\telse {\n\t\t\tchild = parser.read( READERS );\n\n\t\t\tif ( !child ) {\n\t\t\t\tparser.error( `Expected ${delimiters[0]}/partial${delimiters[1]}` );\n\t\t\t}\n\n\t\t\tcontent.push( child );\n\t\t}\n\t} while ( !closed );\n\n\treturn {\n\t\tt: INLINE_PARTIAL,\n\t\tn: name,\n\t\tf: content\n\t};\n}\n","import { INLINE_PARTIAL } from 'config/types';\nimport { warnOnceIfDebug } from 'utils/log';\nimport { READERS } from '../_parse';\nimport escapeRegExp from 'utils/escapeRegExp';\n\nexport default readPartialDefinitionComment;\n\nvar startPattern = /^<!--\\s*/,\n    namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n    finishPattern = /\\s*-->/,\n    child;\n\nfunction readPartialDefinitionComment ( parser ) {\n\tlet firstPos = parser.pos,\n\t    open = parser.standardDelimiters[0],\n\t    close = parser.standardDelimiters[1],\n\t    content,\n\t    closed;\n\n\tif ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {\n\t\tparser.pos = firstPos;\n\t\treturn null;\n\t}\n\n\tlet name = parser.matchPattern( namePattern );\n\n\twarnOnceIfDebug( `Inline partial comments are deprecated.\nUse this...\n  {{#partial ${name}}} ... {{/partial}}\n\n...instead of this:\n  <!-- {{>${name}}} --> ... <!-- {{/${name}}} -->'` );\n\n\t// make sure the rest of the comment is in the correct place\n\tif ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {\n\t\tparser.pos = firstPos;\n\t\treturn null;\n\t}\n\n\tcontent = [];\n\n\tlet endPattern = new RegExp('^<!--\\\\s*' + escapeRegExp( open ) + '\\\\s*\\\\/\\\\s*' + name + '\\\\s*' + escapeRegExp( close ) + '\\\\s*-->');\n\n\tdo {\n\t\tif ( parser.matchPattern( endPattern ) ) {\n\t\t\tclosed = true;\n\t\t}\n\n\t\telse {\n\t\t\tchild = parser.read( READERS );\n\t\t\tif ( !child ) {\n\t\t\t\tparser.error( `expected closing comment ('<!-- ${open}/${name}${close} -->')` );\n\t\t\t}\n\n\t\t\tcontent.push( child );\n\t\t}\n\t} while ( !closed );\n\n\treturn {\n\t\tt: INLINE_PARTIAL,\n\t\tf: content,\n\t\tn: name\n\t};\n}\n","var pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nexport default function escapeRegExp ( str ) {\n\treturn str.replace( pattern, '\\\\$&' );\n}\n","import getLowestIndex from './utils/getLowestIndex';\nimport { decodeCharacterReferences } from 'utils/html';\n\nexport default function readText ( parser ) {\n\tvar index, remaining, disallowed, barrier;\n\n\tremaining = parser.remaining();\n\n\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\n\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t\tindex = remaining.indexOf( barrier );\n\t} else {\n\t\tdisallowed = parser.tags.map( t => t.open );\n\t\tdisallowed = disallowed.concat( parser.tags.map( t => '\\\\' + t.open ) );\n\n\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t\tif ( parser.inAttribute === true ) {\n\t\t\t// we're inside an unquoted attribute value\n\t\t\tdisallowed.push( '\"', \"'\", '=', '<', '>', '`' );\n\t\t} else if ( parser.inAttribute ) {\n\t\t\t// quoted attribute value\n\t\t\tdisallowed.push( parser.inAttribute );\n\t\t} else {\n\t\t\tdisallowed.push( barrier );\n\t\t}\n\n\t\tindex = getLowestIndex( remaining, disallowed );\n\t}\n\n\tif ( !index ) {\n\t\treturn null;\n\t}\n\n\tif ( index === -1 ) {\n\t\tindex = remaining.length;\n\t}\n\n\tparser.pos += index;\n\n\treturn parser.inside ? remaining.substr( 0, index ) : decodeCharacterReferences( remaining.substr( 0, index ) );\n}\n","import { DOCTYPE, ELEMENT } from 'config/types';\nimport { voidElementNames } from 'utils/html';\nimport { create } from 'utils/object';\nimport { READERS, PARTIAL_READERS } from '../_parse';\nimport cleanup from '../utils/cleanup';\nimport readMustache from './readMustache';\nimport readClosing from './mustache/section/readClosing';\nimport readClosingTag from './element/readClosingTag';\nimport readAttribute from './element/readAttribute';\nimport processDirective from './element/processDirective';\n\nvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n\tvalidTagNameFollower = /^[\\s\\n\\/>]/,\n\tonPattern = /^on/,\n\tproxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n\treservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n\tdirectives = { 'intro-outro': 't0', intro: 't1', outro: 't2', decorator: 'o' },\n\texclude = { exclude: true },\n\tdisallowedContents;\n\n// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\ndisallowedContents = {\n\tli: [ 'li' ],\n\tdt: [ 'dt', 'dd' ],\n\tdd: [ 'dt', 'dd' ],\n\tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\trt: [ 'rt', 'rp' ],\n\trp: [ 'rt', 'rp' ],\n\toptgroup: [ 'optgroup' ],\n\toption: [ 'option', 'optgroup' ],\n\tthead: [ 'tbody', 'tfoot' ],\n\ttbody: [ 'tbody', 'tfoot' ],\n\ttfoot: [ 'tbody' ],\n\ttr: [ 'tr', 'tbody' ],\n\ttd: [ 'td', 'th', 'tr' ],\n\tth: [ 'td', 'th', 'tr' ]\n};\n\nexport default readElement;\n\nfunction readElement ( parser ) {\n\tvar start,\n\t\telement,\n\t\tdirectiveName,\n\t\tmatch,\n\t\taddProxyEvent,\n\t\tattribute,\n\t\tdirective,\n\t\tselfClosing,\n\t\tchildren,\n\t\tpartials,\n\t\thasPartials,\n\t\tchild,\n\t\tclosed,\n\t\tpos,\n\t\tremaining,\n\t\tclosingTag;\n\n\tstart = parser.pos;\n\n\tif ( parser.inside || parser.inAttribute ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( '<' ) ) {\n\t\treturn null;\n\t}\n\n\t// if this is a closing tag, abort straight away\n\tif ( parser.nextChar() === '/' ) {\n\t\treturn null;\n\t}\n\n\telement = {};\n\tif ( parser.includeLinePositions ) {\n\t\telement.p = parser.getLinePos( start );\n\t}\n\n\tif ( parser.matchString( '!' ) ) {\n\t\telement.t = DOCTYPE;\n\t\tif ( !parser.matchPattern( /^doctype/i ) ) {\n\t\t\tparser.error( 'Expected DOCTYPE declaration' );\n\t\t}\n\n\t\telement.a = parser.matchPattern( /^(.+?)>/ );\n\t\treturn element;\n\t}\n\n\telement.t = ELEMENT;\n\n\t// element name\n\telement.e = parser.matchPattern( tagNamePattern );\n\tif ( !element.e ) {\n\t\treturn null;\n\t}\n\n\t// next character must be whitespace, closing solidus or '>'\n\tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t\tparser.error( 'Illegal tag name' );\n\t}\n\n\taddProxyEvent = function ( name, directive ) {\n\t\tvar directiveName = directive.n || directive;\n\n\t\tif ( reservedEventNames.test( directiveName ) ) {\n\t\t\tparser.pos -= directiveName.length;\n\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t\t}\n\n\t\telement.v[ name ] = directive;\n\t};\n\n\tparser.allowWhitespace();\n\n\t// directives and attributes\n\twhile ( attribute = readMustache( parser ) || readAttribute( parser ) ) {\n\t\t// regular attributes\n\t\tif ( attribute.name ) {\n\t\t\t// intro, outro, decorator\n\t\t\tif ( directiveName = directives[ attribute.name ] ) {\n\t\t\t\telement[ directiveName ] = processDirective( attribute.value, parser );\n\t\t\t}\n\n\t\t\t// on-click etc\n\t\t\telse if ( match = proxyEventPattern.exec( attribute.name ) ) {\n\t\t\t\tif ( !element.v ) element.v = {};\n\t\t\t\tdirective = processDirective( attribute.value, parser );\n\t\t\t\taddProxyEvent( match[1], directive );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {\n\t\t\t\t\tif ( !element.a ) element.a = {};\n\t\t\t\t\telement.a[ attribute.name ] = attribute.value || ( attribute.value === '' ? '' : 0 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// {{#if foo}}class='foo'{{/if}}\n\t\telse {\n\t\t\tif ( !element.m ) element.m = [];\n\t\t\telement.m.push( attribute );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\t}\n\n\t// allow whitespace before closing solidus\n\tparser.allowWhitespace();\n\n\t// self-closing solidus?\n\tif ( parser.matchString( '/' ) ) {\n\t\tselfClosing = true;\n\t}\n\n\t// closing angle bracket\n\tif ( !parser.matchString( '>' ) ) {\n\t\treturn null;\n\t}\n\n\tlet lowerCaseName = element.e.toLowerCase();\n\tlet preserveWhitespace = parser.preserveWhitespace;\n\n\tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t\tparser.elementStack.push( lowerCaseName );\n\n\t\t// Special case - if we open a script element, further tags should\n\t\t// be ignored unless they're a closing script element\n\t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {\n\t\t\tparser.inside = lowerCaseName;\n\t\t}\n\n\t\tchildren = [];\n\t\tpartials = create( null );\n\n\t\tdo {\n\t\t\tpos = parser.pos;\n\t\t\tremaining = parser.remaining();\n\n\t\t\t// if for example we're in an <li> element, and we see another\n\t\t\t// <li> tag, close the first so they become siblings\n\t\t\tif ( !canContain( lowerCaseName, remaining ) ) {\n\t\t\t\tclosed = true;\n\t\t\t}\n\n\t\t\t// closing tag\n\t\t\telse if ( closingTag = readClosingTag( parser ) ) {\n\t\t\t\tclosed = true;\n\n\t\t\t\tlet closingTagName = closingTag.e.toLowerCase();\n\n\t\t\t\t// if this *isn't* the closing tag for the current element...\n\t\t\t\tif ( closingTagName !== lowerCaseName ) {\n\t\t\t\t\t// rewind parser\n\t\t\t\t\tparser.pos = pos;\n\n\t\t\t\t\t// if it doesn't close a parent tag, error\n\t\t\t\t\tif ( !~parser.elementStack.indexOf( closingTagName ) ) {\n\t\t\t\t\t\tlet errorMessage = 'Unexpected closing tag';\n\n\t\t\t\t\t\t// add additional help for void elements, since component names\n\t\t\t\t\t\t// might clash with them\n\t\t\t\t\t\tif ( voidElementNames.test( closingTagName ) ) {\n\t\t\t\t\t\t\terrorMessage += ` (<${closingTagName}> is a void element - it cannot contain children)`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparser.error( errorMessage );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// implicit close by closing section tag. TODO clean this up\n\t\t\telse if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {\n\t\t\t\tclosed = true;\n\t\t\t\tparser.pos = pos;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif ( child = parser.read( PARTIAL_READERS ) ) {\n\t\t\t\t\tif ( partials[ child.n ] ) {\n\t\t\t\t\t\tparser.pos = pos;\n\t\t\t\t\t\tparser.error( 'Duplicate partial definition' );\n\t\t\t\t\t}\n\n\t\t\t\t\tcleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\n\t\t\t\t\tpartials[ child.n ] = child.f;\n\t\t\t\t\thasPartials = true;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tif ( child = parser.read( READERS ) ) {\n\t\t\t\t\t\tchildren.push( child );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while ( !closed );\n\n\t\tif ( children.length ) {\n\t\t\telement.f = children;\n\t\t}\n\n\t\tif ( hasPartials ) {\n\t\t\telement.p = partials;\n\t\t}\n\n\t\tparser.elementStack.pop();\n\t}\n\n\tparser.inside = null;\n\n\tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t\treturn exclude;\n\t}\n\n\treturn element;\n}\n\nfunction canContain ( name, remaining ) {\n\tvar match, disallowed;\n\n\tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\tdisallowed = disallowedContents[ name ];\n\n\tif ( !match || !disallowed ) {\n\t\treturn true;\n\t}\n\n\treturn !~disallowed.indexOf( match[1].toLowerCase() );\n}\n","import Parser from 'parse/Parser';\nimport readExpression from 'parse/converters/readExpression';\nimport flattenExpression from 'parse/utils/flattenExpression';\nimport parseJSON from 'utils/parseJSON';\n\nvar methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n\tmethodCallExcessPattern = /\\)\\s*$/,\n\tExpressionParser;\n\nExpressionParser = Parser.extend({\n\tconverters: [ readExpression ]\n});\n\n// TODO clean this up, it's shocking\nexport default function processDirective ( tokens, parentParser ) {\n\tvar result,\n\t\tmatch,\n\t\tparser,\n\t\targs,\n\t\ttoken,\n\t\tcolonIndex,\n\t\tdirectiveName,\n\t\tdirectiveArgs,\n\t\tparsed;\n\n\tif ( typeof tokens === 'string' ) {\n\t\tif ( match = methodCallPattern.exec( tokens ) ) {\n\t\t\tlet end = tokens.lastIndexOf(')');\n\n\t\t\t// check for invalid method calls\n\t\t\tif ( !methodCallExcessPattern.test( tokens ) ) {\n\t\t\t\tparentParser.error( `Invalid input after method call expression '${tokens.slice(end + 1)}'` );\n\t\t\t}\n\n\t\t\tresult = { m: match[1] };\n\t\t\targs = '[' + tokens.slice( result.m.length + 1, end ) + ']';\n\n\t\t\tparser = new ExpressionParser( args );\n\t\t\tresult.a = flattenExpression( parser.result[0] );\n\n\t\t\treturn result;\n\t\t}\n\n\t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t\t\treturn tokens.trim();\n\t\t}\n\n\t\ttokens = [ tokens ];\n\t}\n\n\tresult = {};\n\n\tdirectiveName = [];\n\tdirectiveArgs = [];\n\n\tif ( tokens) {\n\t\twhile ( tokens.length ) {\n\t\t\ttoken = tokens.shift();\n\n\t\t\tif ( typeof token === 'string' ) {\n\t\t\t\tcolonIndex = token.indexOf( ':' );\n\n\t\t\t\tif ( colonIndex === -1 ) {\n\t\t\t\t\tdirectiveName.push( token );\n\t\t\t\t} else {\n\n\t\t\t\t\t// is the colon the first character?\n\t\t\t\t\tif ( colonIndex ) {\n\t\t\t\t\t\t// no\n\t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// if there is anything after the colon in this token, treat\n\t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t\t\t\t\t\tdirectiveArgs[0] = token.substring( colonIndex + 1 );\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tdirectiveName.push( token );\n\t\t\t}\n\t\t}\n\n\t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t}\n\n\tif ( !directiveName.length ) {\n\t\tresult = '';\n\t}\n\telse if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t\tresult = {\n\t\t\t// TODO is this really necessary? just use the array\n\t\t\tn: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )\n\t\t};\n\n\t\tif ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {\n\t\t\tparsed = parseJSON( '[' + directiveArgs[0] + ']' );\n\t\t\tresult.a = parsed ? parsed.value : directiveArgs[0].trim();\n\t\t}\n\n\t\telse {\n\t\t\tresult.d = directiveArgs;\n\t\t}\n\t} else {\n\t\tresult = directiveName;\n\t}\n\n\treturn result;\n}\n","import Parser from 'parse/Parser';\nimport readStringLiteral from 'parse/converters/expressions/primary/literal/readStringLiteral';\nimport readKey from 'parse/converters/expressions/shared/readKey';\n\n// simple JSON parser, without the restrictions of JSON parse\n// (i.e. having to double-quote keys).\n//\n// If passed a hash of values as the second argument, ${placeholders}\n// will be replaced with those values\n\nvar JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\nspecials = {\n\t'true': true,\n\t'false': false,\n\t'undefined': undefined,\n\t'null': null\n};\n\nspecialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );\nnumberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\nplaceholderPattern = /\\$\\{([^\\}]+)\\}/g;\nplaceholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\nonlyWhitespace = /^\\s*$/;\n\nJsonParser = Parser.extend({\n\tinit: function ( str, options ) {\n\t\tthis.values = options.values;\n\t\tthis.allowWhitespace();\n\t},\n\n\tpostProcess: function ( result ) {\n\t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { value: result[0].v };\n\t},\n\n\tconverters: [\n\t\tfunction getPlaceholder ( parser ) {\n\t\t\tvar placeholder;\n\n\t\t\tif ( !parser.values ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tplaceholder = parser.matchPattern( placeholderAtStartPattern );\n\n\t\t\tif ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {\n\t\t\t\treturn { v: parser.values[ placeholder ] };\n\t\t\t}\n\t\t},\n\n\t\tfunction getSpecial ( parser ) {\n\t\t\tvar special;\n\n\t\t\tif ( special = parser.matchPattern( specialsPattern ) ) {\n\t\t\t\treturn { v: specials[ special ] };\n\t\t\t}\n\t\t},\n\n\t\tfunction getNumber ( parser ) {\n\t\t\tvar number;\n\n\t\t\tif ( number = parser.matchPattern( numberPattern ) ) {\n\t\t\t\treturn { v: +number };\n\t\t\t}\n\t\t},\n\n\t\tfunction getString ( parser ) {\n\t\t\tvar stringLiteral = readStringLiteral( parser ), values;\n\n\t\t\tif ( stringLiteral && ( values = parser.values ) ) {\n\t\t\t\treturn {\n\t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) {\n\t\t\t\t\t\treturn ( $1 in values ? values[ $1 ] : $1 );\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn stringLiteral;\n\t\t},\n\n\t\tfunction getObject ( parser ) {\n\t\t\tvar result, pair;\n\n\t\t\tif ( !parser.matchString( '{' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tresult = {};\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\treturn { v: result };\n\t\t\t}\n\n\t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t\t\t\tresult[ pair.key ] = pair.value;\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( parser.matchString( '}' ) ) {\n\t\t\t\t\treturn { v: result };\n\t\t\t\t}\n\n\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tfunction getArray ( parser ) {\n\t\t\tvar result, valueToken;\n\n\t\t\tif ( !parser.matchString( '[' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tresult = [];\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\treturn { v: result };\n\t\t\t}\n\n\t\t\twhile ( valueToken = parser.read() ) {\n\t\t\t\tresult.push( valueToken.v );\n\n\t\t\t\tparser.allowWhitespace();\n\n\t\t\t\tif ( parser.matchString( ']' ) ) {\n\t\t\t\t\treturn { v: result };\n\t\t\t\t}\n\n\t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tparser.allowWhitespace();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t]\n});\n\nfunction getKeyValuePair ( parser ) {\n\tvar key, valueToken, pair;\n\n\tparser.allowWhitespace();\n\n\tkey = readKey( parser );\n\n\tif ( !key ) {\n\t\treturn null;\n\t}\n\n\tpair = { key: key };\n\n\tparser.allowWhitespace();\n\tif ( !parser.matchString( ':' ) ) {\n\t\treturn null;\n\t}\n\tparser.allowWhitespace();\n\n\tvalueToken = parser.read();\n\tif ( !valueToken ) {\n\t\treturn null;\n\t}\n\n\tpair.value = valueToken.v;\n\n\treturn pair;\n}\n\nexport default function ( str, values ) {\n\tvar parser = new JsonParser( str, {\n\t\tvalues: values\n\t});\n\n\treturn parser.result;\n}\n","import getLowestIndex from '../utils/getLowestIndex';\nimport readMustache from '../readMustache';\nimport { decodeCharacterReferences } from 'utils/html';\n\nvar attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n\tunquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n\nexport default function readAttribute ( parser ) {\n\tvar attr, name, value;\n\n\tparser.allowWhitespace();\n\n\tname = parser.matchPattern( attributeNamePattern );\n\tif ( !name ) {\n\t\treturn null;\n\t}\n\n\tattr = { name };\n\n\tvalue = readAttributeValue( parser );\n\tif ( value != null ) { // not null/undefined\n\t\tattr.value = value;\n\t}\n\n\treturn attr;\n}\n\nfunction readAttributeValue ( parser ) {\n\tvar start, valueStart, startDepth, value;\n\n\tstart = parser.pos;\n\n\t// next character must be `=`, `/`, `>` or whitespace\n\tif ( !/[=\\/>\\s]/.test( parser.nextChar() ) ) {\n\t\tparser.error( 'Expected `=`, `/`, `>` or whitespace' );\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '=' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\tvalueStart = parser.pos;\n\tstartDepth = parser.sectionDepth;\n\n\tvalue = readQuotedAttributeValue( parser, \"'\" ) ||\n\t\t\treadQuotedAttributeValue( parser, '\"' ) ||\n\t\t\treadUnquotedAttributeValue( parser );\n\n\tif ( value === null ) {\n\t\tparser.error( 'Expected valid attribute value' );\n\t}\n\n\tif ( parser.sectionDepth !== startDepth ) {\n\t\tparser.pos = valueStart;\n\t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t}\n\n\tif ( !value.length ) {\n\t\treturn '';\n\t}\n\n\tif ( value.length === 1 && typeof value[0] === 'string' ) {\n\t\treturn decodeCharacterReferences( value[0] );\n\t}\n\n\treturn value;\n}\n\nfunction readUnquotedAttributeValueToken ( parser ) {\n\tvar start, text, haystack, needles, index;\n\n\tstart = parser.pos;\n\n\ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\n\tif ( !text ) {\n\t\treturn null;\n\t}\n\n\thaystack = text;\n\tneedles = parser.tags.map( t => t.open ); // TODO refactor... we do this in readText.js as well\n\n\tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t\ttext = text.substr( 0, index );\n\t\tparser.pos = start + text.length;\n\t}\n\n\treturn text;\n}\n\nfunction readUnquotedAttributeValue ( parser ) {\n\tvar tokens, token;\n\n\tparser.inAttribute = true;\n\n\ttokens = [];\n\n\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\twhile ( token !== null ) {\n\t\ttokens.push( token );\n\t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t}\n\n\tif ( !tokens.length ) {\n\t\treturn null;\n\t}\n\n\tparser.inAttribute = false;\n\treturn tokens;\n}\n\nfunction readQuotedAttributeValue ( parser, quoteMark ) {\n\tvar start, tokens, token;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( quoteMark ) ) {\n\t\treturn null;\n\t}\n\n\tparser.inAttribute = quoteMark;\n\n\ttokens = [];\n\n\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\twhile ( token !== null ) {\n\t\ttokens.push( token );\n\t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t}\n\n\tif ( !parser.matchString( quoteMark ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tparser.inAttribute = false;\n\n\treturn tokens;\n}\n\nfunction readQuotedStringToken ( parser, quoteMark ) {\n\tvar start, index, haystack, needles;\n\n\tstart = parser.pos;\n\thaystack = parser.remaining();\n\n\tneedles = parser.tags.map( t => t.open ); // TODO refactor... we do this in readText.js as well\n\tneedles.push( quoteMark );\n\n\tindex = getLowestIndex( haystack, needles );\n\n\tif ( index === -1 ) {\n\t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t}\n\n\tif ( !index ) {\n\t\treturn null;\n\t}\n\n\tparser.pos += index;\n\treturn haystack.substr( 0, index );\n}\n","export default function ( haystack, needles ) {\n\tvar i, index, lowest;\n\n\ti = needles.length;\n\twhile ( i-- ) {\n\t\tindex = haystack.indexOf( needles[i] );\n\n\t\t// short circuit\n\t\tif ( !index ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( index === -1 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( !lowest || ( index < lowest ) ) {\n\t\t\tlowest = index;\n\t\t}\n\t}\n\n\treturn lowest || -1;\n}\n","import { CLOSING_TAG } from 'config/types';\n\nvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\nexport default function readClosingTag ( parser ) {\n\tvar start, tag;\n\n\tstart = parser.pos;\n\n\t// are we looking at a closing tag?\n\tif ( !parser.matchString( '</' ) ) {\n\t\treturn null;\n\t}\n\n\tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t\tif ( parser.inside && tag !== parser.inside ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: CLOSING_TAG,\n\t\t\te: tag\n\t\t};\n\t}\n\n\t// We have an illegal closing tag, report it\n\tparser.pos -= 2;\n\tparser.error( 'Illegal closing tag' );\n}\n","import { COMMENT, ELEMENT } from 'config/types';\nimport { isArray } from 'utils/is';\nimport stripStandalones from './stripStandalones';\nimport trimWhitespace from './trimWhitespace';\n\nlet contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\nlet preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\nlet leadingWhitespace = /^[ \\t\\f\\r\\n]+/;\nlet trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\nlet leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\nlet trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\nexport default function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {\n\tvar i,\n\t\titem,\n\t\tpreviousItem,\n\t\tnextItem,\n\t\tpreserveWhitespaceInsideFragment,\n\t\tremoveLeadingWhitespaceInsideFragment,\n\t\tremoveTrailingWhitespaceInsideFragment,\n\t\tkey;\n\n\t// First pass - remove standalones and comments etc\n\tstripStandalones( items );\n\n\ti = items.length;\n\twhile ( i-- ) {\n\t\titem = items[i];\n\n\t\t// Remove delimiter changes, unsafe elements etc\n\t\tif ( item.exclude ) {\n\t\t\titems.splice( i, 1 );\n\t\t}\n\n\t\t// Remove comments, unless we want to keep them\n\t\telse if ( stripComments && item.t === COMMENT ) {\n\t\t\titems.splice( i, 1 );\n\t\t}\n\t}\n\n\t// If necessary, remove leading and trailing whitespace\n\ttrimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null );\n\n\ti = items.length;\n\twhile ( i-- ) {\n\t\titem = items[i];\n\n\t\t// Recurse\n\t\tif ( item.f ) {\n\t\t\tlet isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );\n\t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n\t\t\tif ( !preserveWhitespace && isPreserveWhitespaceElement ) {\n\t\t\t\ttrimWhitespace( item.f, leadingNewLine, trailingNewLine );\n\t\t\t}\n\n\t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t\t\t\tpreviousItem = items[ i - 1 ];\n\t\t\t\tnextItem = items[ i + 1 ];\n\n\t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t\t\t\t// remove leading whitespace inside the fragment\n\t\t\t\tif ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {\n\t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t\t\t\t}\n\n\t\t\t\t// and vice versa\n\t\t\t\tif ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) ) {\n\t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t}\n\n\t\t// Split if-else blocks into two (an if, and an unless)\n\t\tif ( item.l ) {\n\t\t\tcleanup( item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\n\t\t\titems.splice( i + 1, 0, item.l );\n\t\t\tdelete item.l; // TODO would be nice if there was a way around this\n\t\t}\n\n\t\t// Clean up element attributes\n\t\tif ( item.a ) {\n\t\t\tfor ( key in item.a ) {\n\t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Clean up conditional attributes\n\t\tif ( item.m ) {\n\t\t\tcleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t}\n\n\t\t// Clean up event handlers\n\t\tif ( item.v ) {\n\t\t\tfor ( key in item.v ) {\n\t\t\t\tif ( item.v.hasOwnProperty( key ) ) {\n\t\t\t\t\t// clean up names\n\t\t\t\t\tif ( isArray( item.v[ key ].n ) ) {\n\t\t\t\t\t\tcleanup( item.v[ key ].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\t}\n\n\t\t\t\t\t// clean up params\n\t\t\t\t\tif ( isArray( item.v[ key ].d ) ) {\n\t\t\t\t\t\tcleanup( item.v[ key ].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// final pass - fuse text nodes together\n\ti = items.length;\n\twhile ( i-- ) {\n\t\tif ( typeof items[i] === 'string' ) {\n\t\t\tif ( typeof items[i+1] === 'string' ) {\n\t\t\t\titems[i] = items[i] + items[i+1];\n\t\t\t\titems.splice( i + 1, 1 );\n\t\t\t}\n\n\t\t\tif ( !preserveWhitespace ) {\n\t\t\t\titems[i] = items[i].replace( contiguousWhitespace, ' ' );\n\t\t\t}\n\n\t\t\tif ( items[i] === '' ) {\n\t\t\t\titems.splice( i, 1 );\n\t\t\t}\n\t\t}\n\t}\n}\n","import { lastItem } from 'utils/array';\n\nexport default function ( items, leadingPattern, trailingPattern ) {\n\tvar item;\n\n\tif ( leadingPattern ) {\n\t\titem = items[0];\n\t\tif ( typeof item === 'string' ) {\n\t\t\titem = item.replace( leadingPattern, '' );\n\n\t\t\tif ( !item ) {\n\t\t\t\titems.shift();\n\t\t\t} else {\n\t\t\t\titems[0] = item;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( trailingPattern ) {\n\t\titem = lastItem( items );\n\t\tif ( typeof item === 'string' ) {\n\t\t\titem = item.replace( trailingPattern, '' );\n\n\t\t\tif ( !item ) {\n\t\t\t\titems.pop();\n\t\t\t} else {\n\t\t\t\titems[ items.length - 1 ] = item;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { COMMENT, DELIMCHANGE, SECTION, INVERTED } from 'config/types';\nimport { lastItem } from 'utils/array';\n\nvar leadingLinebreak = /^\\s*\\r?\\n/,\n\ttrailingLinebreak = /\\r?\\n\\s*$/;\n\nexport default function ( items ) {\n\tvar i, current, backOne, backTwo, lastSectionItem;\n\n\tfor ( i=1; i<items.length; i+=1 ) {\n\t\tcurrent = items[i];\n\t\tbackOne = items[i-1];\n\t\tbackTwo = items[i-2];\n\n\t\t// if we're at the end of a [text][comment][text] sequence...\n\t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\n\t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\n\t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t\t\t\titems[i-2] = backTwo.replace( trailingLinebreak, '\\n' );\n\n\t\t\t\t// and the leading line break of the second text token\n\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t}\n\t\t}\n\n\t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t\t// its first item is a linebreak...\n\t\tif ( isSection( current ) && isString( backOne ) ) {\n\t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {\n\t\t\t\titems[i-1] = backOne.replace( trailingLinebreak, '\\n' );\n\t\t\t\tcurrent.f[0] = current.f[0].replace( leadingLinebreak, '' );\n\t\t\t}\n\t\t}\n\n\t\t// if the last item was a section, and it is followed by a linebreak, and\n\t\t// its last item is a linebreak...\n\t\tif ( isString( current ) && isSection( backOne ) ) {\n\t\t\tlastSectionItem = lastItem( backOne.f );\n\n\t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn items;\n}\n\nfunction isString ( item ) {\n\treturn typeof item === 'string';\n}\n\nfunction isComment ( item ) {\n\treturn item.t === COMMENT || item.t === DELIMCHANGE;\n}\n\nfunction isSection ( item ) {\n\treturn ( item.t === SECTION || item.t === INVERTED ) && item.f;\n}\n","import 'legacy';\n\nvar booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\nbooleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\nvoidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\nhtmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\ncontrolCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];\nentityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\nfunction decodeCharacterReferences ( html ) {\n\treturn html.replace( entityPattern, function ( match, entity ) {\n\t\tvar code;\n\n\t\t// Handle named entities\n\t\tif ( entity[0] !== '#' ) {\n\t\t\tcode = htmlEntities[ entity ];\n\t\t} else if ( entity[1] === 'x' ) {\n\t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t\t} else {\n\t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t\t}\n\n\t\tif ( !code ) {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn String.fromCharCode( validateCode( code ) );\n\t});\n}\n\n// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n// to replace them ourselves\n//\n// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\nfunction validateCode ( code ) {\n\tif ( !code ) {\n\t\treturn 65533;\n\t}\n\n\t// line feed becomes generic whitespace\n\tif ( code === 10 ) {\n\t\treturn 32;\n\t}\n\n\t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\tif ( code < 128 ) {\n\t\treturn code;\n\t}\n\n\t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t// to correct the mistake or we'll end up with missing  signs and so on\n\tif ( code <= 159 ) {\n\t\treturn controlCharacters[ code - 128 ];\n\t}\n\n\t// basic multilingual plane\n\tif ( code < 55296 ) {\n\t\treturn code;\n\t}\n\n\t// UTF-16 surrogate halves\n\tif ( code <= 57343 ) {\n\t\treturn 65533;\n\t}\n\n\t// rest of the basic multilingual plane\n\tif ( code <= 65535 ) {\n\t\treturn code;\n\t}\n\n\treturn 65533;\n}\n\nlessThan = /</g;\ngreaterThan = />/g;\namp = /&/g;\n\nfunction escapeHtml ( str ) {\n\treturn str\n\t\t.replace( amp, '&amp;' )\n\t\t.replace( lessThan, '&lt;' )\n\t\t.replace( greaterThan, '&gt;' );\n}\n\nexport { booleanAttributes, decodeCharacterReferences, escapeHtml, voidElementNames };\n","import { COMMENT } from 'config/types';\n\nvar OPEN_COMMENT = '<!--',\n\tCLOSE_COMMENT = '-->';\n\nexport default function readHtmlComment ( parser ) {\n\tvar start, content, remaining, endIndex, comment;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( OPEN_COMMENT ) ) {\n\t\treturn null;\n\t}\n\n\tremaining = parser.remaining();\n\tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\n\tif ( endIndex === -1 ) {\n\t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t}\n\n\tcontent = remaining.substr( 0, endIndex );\n\tparser.pos += endIndex + 3;\n\n\tcomment = {\n\t\tt: COMMENT,\n\t\tc: content\n\t};\n\n\tif ( parser.includeLinePositions ) {\n\t\tcomment.p = parser.getLinePos( start );\n\t}\n\n\treturn comment;\n}\n","import { SECTION, SECTION_IF, SECTION_UNLESS, SECTION_WITH, SECTION_IF_WITH, PREFIX_OPERATOR, INFIX_OPERATOR, BRACKETED } from 'config/types';\nimport { READERS } from '../../_parse';\nimport readClosing from './section/readClosing';\nimport readElse from './section/readElse';\nimport readElseIf from './section/readElseIf';\nimport handlebarsBlockCodes from './handlebarsBlockCodes';\nimport readExpression from 'parse/converters/readExpression';\nimport flattenExpression from 'parse/utils/flattenExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\tkeyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n\thandlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' );\n\nexport default function readSection ( parser, tag ) {\n\tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n\tstart = parser.pos;\n\n\tif ( parser.matchString( '^' ) ) {\n\t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n\t} else if ( parser.matchString( '#' ) ) {\n\t\tsection = { t: SECTION, f: [] };\n\n\t\tif ( parser.matchString( 'partial' ) ) {\n\t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n\t\t\tparser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );\n\t\t}\n\n\t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t\t\texpectedClose = block;\n\t\t\tsection.n = handlebarsBlockCodes[ block ];\n\t\t}\n\t} else {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\texpression = readExpression( parser );\n\n\tif ( !expression ) {\n\t\tparser.error( 'Expected expression' );\n\t}\n\n\t// optional index and key references\n\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t\tlet extra;\n\n\t\tif ( extra = parser.matchPattern( keyIndexRefPattern ) ) {\n\t\t\tsection.i = i + ',' + extra;\n\t\t} else {\n\t\t\tsection.i = i;\n\t\t}\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\tparser.sectionDepth += 1;\n\tchildren = section.f;\n\n\tconditions = [];\n\n\tdo {\n\t\tif ( child = readClosing( parser, tag ) ) {\n\t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t\t\t\tparser.error( `Expected ${tag.open}/${expectedClose}${tag.close}` );\n\t\t\t}\n\n\t\t\tparser.sectionDepth -= 1;\n\t\t\tclosed = true;\n\t\t}\n\n\t\telse if ( child = readElseIf( parser, tag ) ) {\n\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t}\n\n\t\t\tif ( hasElse ) {\n\t\t\t\tparser.error( 'illegal {{elseif...}} after {{else}}' );\n\t\t\t}\n\n\t\t\tif ( !unlessBlock ) {\n\t\t\t\tunlessBlock = createUnlessBlock( expression, section.n );\n\t\t\t}\n\n\t\t\tunlessBlock.f.push({\n\t\t\t\tt: SECTION,\n\t\t\t\tn: SECTION_IF,\n\t\t\t\tx: flattenExpression( combine( conditions.concat( child.x ) ) ),\n\t\t\t\tf: children = []\n\t\t\t});\n\n\t\t\tconditions.push( invert( child.x ) );\n\t\t}\n\n\t\telse if ( child = readElse( parser, tag ) ) {\n\t\t\tif ( section.n === SECTION_UNLESS ) {\n\t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t\t\t}\n\n\t\t\tif ( hasElse ) {\n\t\t\t\tparser.error( 'there can only be one {{else}} block, at the end of a section' );\n\t\t\t}\n\n\t\t\thasElse = true;\n\n\t\t\t// use an unless block if there's no elseif\n\t\t\tif ( !unlessBlock ) {\n\t\t\t\tunlessBlock = createUnlessBlock( expression, section.n );\n\t\t\t\tchildren = unlessBlock.f;\n\t\t\t} else {\n\t\t\t\tunlessBlock.f.push({\n\t\t\t\t\tt: SECTION,\n\t\t\t\t\tn: SECTION_IF,\n\t\t\t\t\tx: flattenExpression( combine( conditions ) ),\n\t\t\t\t\tf: children = []\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tchild = parser.read( READERS );\n\n\t\t\tif ( !child ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchildren.push( child );\n\t\t}\n\t} while ( !closed );\n\n\tif ( unlessBlock ) {\n\t\t// special case - `with` should become `if-with` (TODO is this right?\n\t\t// seems to me that `with` ought to behave consistently, regardless\n\t\t// of the presence/absence of `else`. In other words should always\n\t\t// be `if-with`\n\t\tif ( section.n === SECTION_WITH ) {\n\t\t\tsection.n = SECTION_IF_WITH;\n\t\t}\n\n\t\tsection.l = unlessBlock;\n\t}\n\n\trefineExpression( expression, section );\n\n\t// TODO if a section is empty it should be discarded. Don't do\n\t// that here though - we need to clean everything up first, as\n\t// it may contain removeable whitespace. As a temporary measure,\n\t// to pass the existing tests, remove empty `f` arrays\n\tif ( !section.f.length ) {\n\t\tdelete section.f;\n\t}\n\n\treturn section;\n}\n\nfunction createUnlessBlock ( expression, sectionType ) {\n\tvar unlessBlock;\n\n\tif ( sectionType === SECTION_WITH ) {\n\t\t// special case - a `{{#with foo}}` section will render if `foo` is\n\t\t// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n\t\t// rather than adhering to the normal `{{#unless foo}}` logic (which\n\t\t// treats empty arrays/objects as falsy)\n\t\tunlessBlock = {\n\t\t\tt: SECTION,\n\t\t\tn: SECTION_IF,\n\t\t\tf: []\n\t\t};\n\n\t\trefineExpression( invert( expression ), unlessBlock );\n\t} else {\n\t\tunlessBlock = {\n\t\t\tt: SECTION,\n\t\t\tn: SECTION_UNLESS,\n\t\t\tf: []\n\t\t};\n\n\t\trefineExpression( expression, unlessBlock );\n\t}\n\n\treturn unlessBlock;\n}\n\nfunction invert ( expression ) {\n\tif ( expression.t === PREFIX_OPERATOR && expression.s === '!' ) {\n\t\treturn expression.o;\n\t}\n\n\treturn {\n\t\tt: PREFIX_OPERATOR,\n\t\ts: '!',\n\t\to: parensIfNecessary( expression )\n\t};\n}\n\nfunction combine ( expressions ) {\n\tif ( expressions.length === 1 ) {\n\t\treturn expressions[0];\n\t}\n\n\treturn {\n\t\tt: INFIX_OPERATOR,\n\t\ts: '&&',\n\t\to: [\n\t\t\tparensIfNecessary( expressions[0] ),\n\t\t\tparensIfNecessary( combine( expressions.slice( 1 ) ) )\n\t\t]\n\t};\n}\n\nfunction parensIfNecessary ( expression ) {\n\t// TODO only wrap if necessary\n\treturn {\n\t\tt: BRACKETED,\n\t\tx: expression\n\t};\n}\n","import { SECTION_EACH, SECTION_IF, SECTION_IF_WITH, SECTION_WITH, SECTION_UNLESS } from 'config/types';\n\nexport default {\n\t'each':    SECTION_EACH,\n\t'if':      SECTION_IF,\n\t'if-with': SECTION_IF_WITH,\n\t'with':    SECTION_WITH,\n\t'unless':  SECTION_UNLESS\n};\n","import { ELSEIF } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\n\nvar elsePattern = /^\\s*elseif\\s+/;\n\nexport default function readElse ( parser, tag ) {\n\tvar start = parser.pos, expression;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchPattern( elsePattern ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\texpression = readExpression( parser );\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\treturn {\n\t\tt: ELSEIF,\n\t\tx: expression\n\t};\n}","import { ELSE } from 'config/types';\n\nvar elsePattern = /^\\s*else\\s*/;\n\nexport default function readElse ( parser, tag ) {\n\tvar start = parser.pos;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchPattern( elsePattern ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\treturn {\n\t\tt: ELSE\n\t};\n}","import { CLOSING } from 'config/types';\n\nexport default function readClosing ( parser, tag ) {\n\tvar start, remaining, index, closing;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '/' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\tremaining = parser.remaining();\n\tindex = remaining.indexOf( tag.close );\n\n\tif ( index !== -1 ) {\n\t\tclosing = {\n\t\t\tt: CLOSING,\n\t\t\tr: remaining.substr( 0, index ).split( ' ' )[0]\n\t\t};\n\n\t\tparser.pos += index;\n\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t\t}\n\n\t\treturn closing;\n\t}\n\n\tparser.pos = start;\n\treturn null;\n}\n","import { YIELDER } from 'config/types';\n\nvar yieldPattern = /^yield\\s*/;\n\nexport default function readYielder ( parser, tag ) {\n\tvar start, name, yielder;\n\n\tif ( !parser.matchPattern( yieldPattern ) ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `expected legal partial name` );\n\t}\n\n\tyielder = { t: YIELDER };\n\n\tif ( name ) {\n\t\tyielder.n = name;\n\t}\n\n\treturn yielder;\n}","import { INTERPOLATOR } from 'config/types';\nimport readExpressionOrReference from 'parse/converters/readExpressionOrReference';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readInterpolator ( parser, tag ) {\n\tvar start, expression, interpolator, err;\n\n\tstart = parser.pos;\n\n\t// TODO would be good for perf if we could do away with the try-catch\n\ttry {\n\t\texpression = readExpressionOrReference( parser, [ tag.close ]);\n\t} catch ( e ) {\n\t\terr = e;\n\t}\n\n\tif ( !expression ) {\n\t\tif ( parser.str.charAt( start ) === '!' ) {\n\t\t\t// special case - comment\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}' after reference` );\n\n\t\tif ( !expression ) {\n\t\t\t// special case - comment\n\t\t\tif ( parser.nextChar() === '!' ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparser.error( `Expected expression or legal reference` );\n\t\t}\n\t}\n\n\tinterpolator = { t: INTERPOLATOR };\n\trefineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious\n\n\treturn interpolator;\n}\n","import readExpression from './readExpression';\nimport readReference from './expressions/primary/readReference';\n\nexport default function readExpressionOrReference ( parser, expectedFollowers ) {\n\tvar start, expression, i;\n\n\tstart = parser.pos;\n\texpression = readExpression( parser );\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tfor ( i = 0; i < expectedFollowers.length; i += 1 ) {\n\t\tif ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {\n\t\t\treturn expression;\n\t\t}\n\t}\n\n\tparser.pos = start;\n\treturn readReference( parser );\n}","import { COMMENT } from 'config/types';\n\nexport default function readComment ( parser, tag ) {\n\tvar index;\n\n\tif ( !parser.matchString( '!' ) ) {\n\t\treturn null;\n\t}\n\n\tindex = parser.remaining().indexOf( tag.close );\n\n\tif ( index !== -1 ) {\n\t\tparser.pos += index + tag.close.length;\n\t\treturn { t: COMMENT };\n\t}\n}\n","import { PARTIAL, SECTION, SECTION_WITH } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readPartial ( parser, tag ) {\n\tvar start, nameStart, expression, context, partial;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( '>' ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\tnameStart = parser.pos;\n\n\t// Partial names can include hyphens, so we can't use readExpression\n\t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n\t// `foo-bar` should be read as a single name, rather than 'subtract\n\t// bar from foo'\n\tparser.relaxedNames = true;\n\texpression = readExpression( parser );\n\tparser.relaxedNames = false;\n\n\tparser.allowWhitespace();\n\tcontext = readExpression( parser );\n\tparser.allowWhitespace();\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tpartial = { t: PARTIAL };\n\trefineExpression( expression, partial ); // TODO...\n\n\tparser.allowWhitespace();\n\n\t// if we have another expression - e.g. `{{>foo bar}}` - then\n\t// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n\tif ( context ) {\n\t\tpartial = {\n\t\t\tt: SECTION,\n\t\t\tn: SECTION_WITH,\n\t\t\tf: [ partial ]\n\t\t};\n\n\t\trefineExpression( context, partial );\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\treturn partial;\n}","import { TRIPLE } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readUnescaped ( parser, tag ) {\n\tvar expression, triple;\n\n\tif ( !parser.matchString( '&' ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\texpression = readExpression( parser );\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\ttriple = { t: TRIPLE };\n\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n\treturn triple;\n}","import { TRIPLE } from 'config/types';\nimport readExpression from 'parse/converters/readExpression';\nimport refineExpression from 'parse/utils/refineExpression';\n\nexport default function readTriple ( parser, tag ) {\n\tvar expression = readExpression( parser ), triple;\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tif ( !parser.matchString( tag.close ) ) {\n\t\tparser.error( `Expected closing delimiter '${tag.close}'` );\n\t}\n\n\ttriple = { t: TRIPLE };\n\trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n\treturn triple;\n}","import { REFERENCE, BRACKETED, NUMBER_LITERAL, MEMBER, REFINEMENT } from 'config/types';\nimport flattenExpression from './flattenExpression';\n\nvar arrayMemberPattern = /^[0-9][1-9]*$/;\n\nexport default function refineExpression ( expression, mustache ) {\n\tvar referenceExpression;\n\n\tif ( expression ) {\n\t\twhile ( expression.t === BRACKETED && expression.x ) {\n\t\t\texpression = expression.x;\n\t\t}\n\n\t\t// special case - integers should be treated as array members references,\n\t\t// rather than as expressions in their own right\n\t\tif ( expression.t === REFERENCE ) {\n\t\t\tmustache.r = expression.n;\n\t\t} else {\n\t\t\tif ( expression.t === NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {\n\t\t\t\tmustache.r = expression.v;\n\t\t\t} else if ( referenceExpression = getReferenceExpression( expression ) ) {\n\t\t\t\tmustache.rx = referenceExpression;\n\t\t\t} else {\n\t\t\t\tmustache.x = flattenExpression( expression );\n\t\t\t}\n\t\t}\n\n\t\treturn mustache;\n\t}\n}\n\n// TODO refactor this! it's bewildering\nfunction getReferenceExpression ( expression ) {\n\tvar members = [], refinement;\n\n\twhile ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {\n\t\trefinement = expression.r;\n\n\t\tif ( refinement.x ) {\n\t\t\tif ( refinement.x.t === REFERENCE ) {\n\t\t\t\tmembers.unshift( refinement.x );\n\t\t\t} else {\n\t\t\t\tmembers.unshift( flattenExpression( refinement.x ) );\n\t\t\t}\n\t\t} else {\n\t\t\tmembers.unshift( refinement.n );\n\t\t}\n\n\t\texpression = expression.x;\n\t}\n\n\tif ( expression.t !== REFERENCE ) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tr: expression.n,\n\t\tm: members\n\t};\n}","import { REFERENCE, BOOLEAN_LITERAL, GLOBAL, NUMBER_LITERAL, REGEXP_LITERAL, STRING_LITERAL, ARRAY_LITERAL, OBJECT_LITERAL, KEY_VALUE_PAIR, PREFIX_OPERATOR, INFIX_OPERATOR, INVOCATION, BRACKETED, MEMBER, REFINEMENT, CONDITIONAL } from 'config/types';\nimport { isObject } from 'utils/is';\n\nexport default function flattenExpression ( expression ) {\n\tvar refs;\n\n\textractRefs( expression, refs = [] );\n\n\treturn {\n\t\tr: refs,\n\t\ts: stringify( expression )\n\t};\n\n\tfunction stringify ( node ) {\n\t\tswitch ( node.t ) {\n\t\t\tcase BOOLEAN_LITERAL:\n\t\t\tcase GLOBAL:\n\t\t\tcase NUMBER_LITERAL:\n\t\t\tcase REGEXP_LITERAL:\n\t\t\treturn node.v;\n\n\t\t\tcase STRING_LITERAL:\n\t\t\treturn JSON.stringify( String( node.v ) );\n\n\t\t\tcase ARRAY_LITERAL:\n\t\t\treturn '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';\n\n\t\t\tcase OBJECT_LITERAL:\n\t\t\treturn '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';\n\n\t\t\tcase KEY_VALUE_PAIR:\n\t\t\treturn node.k + ':' + stringify( node.v );\n\n\t\t\tcase PREFIX_OPERATOR:\n\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );\n\n\t\t\tcase INFIX_OPERATOR:\n\t\t\treturn stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );\n\n\t\t\tcase INVOCATION:\n\t\t\treturn stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';\n\n\t\t\tcase BRACKETED:\n\t\t\treturn '(' + stringify( node.x ) + ')';\n\n\t\t\tcase MEMBER:\n\t\t\treturn stringify( node.x ) + stringify( node.r );\n\n\t\t\tcase REFINEMENT:\n\t\t\treturn ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );\n\n\t\t\tcase CONDITIONAL:\n\t\t\treturn stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );\n\n\t\t\tcase REFERENCE:\n\t\t\treturn '_' + refs.indexOf( node.n );\n\n\t\t\tdefault:\n\t\t\tthrow new Error( 'Expected legal JavaScript' );\n\t\t}\n\t}\n}\n\n// TODO maybe refactor this?\nfunction extractRefs ( node, refs ) {\n\tvar i, list;\n\n\tif ( node.t === REFERENCE ) {\n\t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t\t\trefs.unshift( node.n );\n\t\t}\n\t}\n\n\tlist = node.o || node.m;\n\tif ( list ) {\n\t\tif ( isObject( list ) ) {\n\t\t\textractRefs( list, refs );\n\t\t} else {\n\t\t\ti = list.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\textractRefs( list[i], refs );\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( node.x ) {\n\t\textractRefs( node.x, refs );\n\t}\n\n\tif ( node.r ) {\n\t\textractRefs( node.r, refs );\n\t}\n\n\tif ( node.v ) {\n\t\textractRefs( node.v, refs );\n\t}\n}\n\n","import readConditional from './expressions/readConditional';\n\nexport default function readExpression ( parser ) {\n\t// The conditional operator is the lowest precedence operator (except yield,\n\t// assignment operators, and commas, none of which are supported), so we\n\t// start there. If it doesn't match, it 'falls through' to progressively\n\t// higher precedence operators, until it eventually matches (or fails to\n\t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\treturn readConditional( parser );\n}","import { CONDITIONAL } from 'config/types';\nimport readLogicalOr from './readLogicalOr';\nimport { expectedExpression } from './shared/errors';\nimport readExpression from 'parse/converters/readExpression';\n\n// The conditional operator is the lowest precedence operator, so we start here\nexport default function getConditional ( parser ) {\n\tvar start, expression, ifTrue, ifFalse;\n\n\texpression = readLogicalOr( parser );\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '?' ) ) {\n\t\tparser.pos = start;\n\t\treturn expression;\n\t}\n\n\tparser.allowWhitespace();\n\n\tifTrue = readExpression( parser );\n\tif ( !ifTrue ) {\n\t\tparser.error( expectedExpression );\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( ':' ) ) {\n\t\tparser.error( 'Expected \":\"' );\n\t}\n\n\tparser.allowWhitespace();\n\n\tifFalse = readExpression( parser );\n\tif ( !ifFalse ) {\n\t\tparser.error( expectedExpression );\n\t}\n\n\treturn {\n\t\tt: CONDITIONAL,\n\t\to: [ expression, ifTrue, ifFalse ]\n\t};\n}\n","import { INFIX_OPERATOR } from 'config/types';\nimport readTypeof from './readTypeof';\n\nvar readLogicalOr, makeInfixSequenceMatcher;\n\nmakeInfixSequenceMatcher = function ( symbol, fallthrough ) {\n\treturn function ( parser ) {\n\t\tvar start, left, right;\n\n\t\tleft = fallthrough( parser );\n\t\tif ( !left ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t\t// to parse `left` because that would be infinite regress.\n\t\twhile ( true ) {\n\t\t\tstart = parser.pos;\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t   parser.allowWhitespace();\n\n\t\t\t// right operand must also consist of only higher-precedence operators\n\t\t\tright = fallthrough( parser );\n\t\t\tif ( !right ) {\n\t\t\t\tparser.pos = start;\n\t\t\t\treturn left;\n\t\t\t}\n\n\t\t\tleft = {\n\t\t\t\tt: INFIX_OPERATOR,\n\t\t\t\ts: symbol,\n\t\t\t\to: [ left, right ]\n\t\t\t};\n\n\t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n\t\t\t// we'll return left.\n\t\t}\n\t};\n};\n\n// create all infix sequence matchers, and return readLogicalOr\n(function() {\n\tvar i, len, matcher, infixOperators, fallthrough;\n\n\t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t// Each sequence matcher will initially fall through to its higher precedence\n\t// neighbour, and only attempt to match if one of the higher precedence operators\n\t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\n\t// A typeof operator is higher precedence than multiplication\n\tfallthrough = readTypeof;\n\tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\n\t\tfallthrough = matcher;\n\t}\n\n\t// Logical OR is the fallthrough for the conditional matcher\n\treadLogicalOr = fallthrough;\n}());\n\nexport default readLogicalOr;\n","import { PREFIX_OPERATOR } from 'config/types';\nimport { expectedExpression } from './shared/errors';\nimport readMemberOrInvocation from './readMemberOrInvocation';\nimport readExpression from 'parse/converters/readExpression';\n\nvar readTypeOf, makePrefixSequenceMatcher;\n\nmakePrefixSequenceMatcher = function ( symbol, fallthrough ) {\n\treturn function ( parser ) {\n\t\tvar expression;\n\n\t\tif ( expression = fallthrough( parser ) ) {\n\t\t\treturn expression;\n\t\t}\n\n\t\tif ( !parser.matchString( symbol ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\texpression = readExpression( parser );\n\t\tif ( !expression ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\treturn {\n\t\t\ts: symbol,\n\t\t\to: expression,\n\t\t\tt: PREFIX_OPERATOR\n\t\t};\n\t};\n};\n\n// create all prefix sequence matchers, return readTypeOf\n(function() {\n\tvar i, len, matcher, prefixOperators, fallthrough;\n\n\tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\n\tfallthrough = readMemberOrInvocation;\n\tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\n\t\tfallthrough = matcher;\n\t}\n\n\t// typeof operator is higher precedence than multiplication, so provides the\n\t// fallthrough for the multiplication sequence matcher we're about to create\n\t// (we're skipping void and delete)\n\treadTypeOf = fallthrough;\n}());\n\nexport default readTypeOf;\n","import { MEMBER, INVOCATION } from 'config/types';\nimport readPrimary from './readPrimary';\nimport readExpressionList from './shared/readExpressionList';\nimport readRefinement from './shared/readRefinement';\nimport { expectedParen } from './shared/errors';\n\nexport default function ( parser ) {\n\tvar current, expression, refinement, expressionList;\n\n\texpression = readPrimary( parser );\n\n\tif ( !expression ) {\n\t\treturn null;\n\t}\n\n\twhile ( expression ) {\n\t\tcurrent = parser.pos;\n\n\t\tif ( refinement = readRefinement( parser ) ) {\n\t\t\texpression = {\n\t\t\t\tt: MEMBER,\n\t\t\t\tx: expression,\n\t\t\t\tr: refinement\n\t\t\t};\n\t\t}\n\n\t\telse if ( parser.matchString( '(' ) ) {\n\t\t\tparser.allowWhitespace();\n\t\t\texpressionList = readExpressionList( parser );\n\n\t\t\tparser.allowWhitespace();\n\n\t\t\tif ( !parser.matchString( ')' ) ) {\n\t\t\t\tparser.error( expectedParen );\n\t\t\t}\n\n\t\t\texpression = {\n\t\t\t\tt: INVOCATION,\n\t\t\t\tx: expression\n\t\t\t};\n\n\t\t\tif ( expressionList ) {\n\t\t\t\texpression.o = expressionList;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn expression;\n}\n","import { REFINEMENT } from 'config/types';\nimport { expectedExpression } from './errors';\nimport { name as namePattern } from './patterns';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readRefinement ( parser ) {\n\tvar start, name, expr;\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\t// \".\" name\n\tif ( parser.matchString( '.' ) ) {\n\t\tparser.allowWhitespace();\n\n\t\tif ( name = parser.matchPattern( namePattern ) ) {\n\t\t\treturn {\n\t\t\t\tt: REFINEMENT,\n\t\t\t\tn: name\n\t\t\t};\n\t\t}\n\n\t\tparser.error( 'Expected a property name' );\n\t}\n\n\t// \"[\" expression \"]\"\n\tif ( parser.matchString( '[' ) ) {\n\t\tparser.allowWhitespace();\n\n\t\texpr = readExpression( parser );\n\t\tif ( !expr ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\tparser.allowWhitespace();\n\n\t\tif ( !parser.matchString( ']' ) ) {\n\t\t\tparser.error( 'Expected \\']\\'' );\n\t\t}\n\n\t\treturn {\n\t\t\tt: REFINEMENT,\n\t\t\tx: expr\n\t\t};\n\t}\n\n\treturn null;\n}\n","import readLiteral from './primary/readLiteral';\nimport readReference from './primary/readReference';\nimport readBracketedExpression from './primary/readBracketedExpression';\n\nexport default function ( parser ) {\n\treturn readLiteral( parser )\n\t\t|| readReference( parser )\n\t\t|| readBracketedExpression( parser );\n}\n","import { BRACKETED } from 'config/types';\nimport { expectedExpression, expectedParen } from '../shared/errors';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readBracketedExpression ( parser ) {\n\tvar start, expr;\n\n\tstart = parser.pos;\n\n\tif ( !parser.matchString( '(' ) ) {\n\t\treturn null;\n\t}\n\n\tparser.allowWhitespace();\n\n\texpr = readExpression( parser );\n\tif ( !expr ) {\n\t\tparser.error( expectedExpression );\n\t}\n\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( ')' ) ) {\n\t\tparser.error( expectedParen );\n\t}\n\n\treturn {\n\t\tt: BRACKETED,\n\t\tx: expr\n\t};\n}\n","import { GLOBAL, REFERENCE } from 'config/types';\nimport { normalise } from 'shared/keypaths';\n\nvar prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n\tglobals,\n\tkeywords;\n\n// if a reference is a browser global, we don't deference it later, so it needs special treatment\nglobals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n// keywords are not valid references, with the exception of `this`\nkeywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\nvar legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\nvar relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n\nexport default function readReference ( parser ) {\n\tvar startPos, prefix, name, global, reference, lastDotIndex;\n\n\tstartPos = parser.pos;\n\n\tname = parser.matchPattern( /^@(?:keypath|index|key)/ );\n\n\tif ( !name ) {\n\t\tprefix = parser.matchPattern( prefixPattern ) || '';\n\t\tname = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||\n\t\t       parser.matchPattern( legalReference );\n\n\t\tif ( !name && prefix === '.' ) {\n\t\t\tprefix = '';\n\t\t\tname = '.';\n\t\t}\n\t}\n\n\tif ( !name ) {\n\t\treturn null;\n\t}\n\n\t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n\tif ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {\n\t\tparser.pos = startPos;\n\t\treturn null;\n\t}\n\n\t// if this is a browser global, stop here\n\tif ( !prefix && globals.test( name ) ) {\n\t\tglobal = globals.exec( name )[0];\n\t\tparser.pos = startPos + global.length;\n\n\t\treturn {\n\t\t\tt: GLOBAL,\n\t\t\tv: global\n\t\t};\n\t}\n\n\treference = ( prefix || '' ) + normalise( name );\n\n\tif ( parser.matchString( '(' ) ) {\n\t\t// if this is a method invocation (as opposed to a function) we need\n\t\t// to strip the method name from the reference combo, else the context\n\t\t// will be wrong\n\t\tlastDotIndex = reference.lastIndexOf( '.' );\n\t\tif ( lastDotIndex !== -1 ) {\n\t\t\treference = reference.substr( 0, lastDotIndex );\n\t\t\tparser.pos = startPos + reference.length;\n\t\t} else {\n\t\t\tparser.pos -= 1;\n\t\t}\n\t}\n\n\treturn {\n\t\tt: REFERENCE,\n\t\tn: reference.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t};\n}\n","import readNumberLiteral from './literal/readNumberLiteral';\nimport readBooleanLiteral from './literal/readBooleanLiteral';\nimport readStringLiteral from './literal/readStringLiteral';\nimport readObjectLiteral from './literal/readObjectLiteral';\nimport readArrayLiteral from './literal/readArrayLiteral';\nimport readRegexpLiteral from './literal/readRegexpLiteral';\n\nexport default function readLiteral ( parser ) {\n\treturn readNumberLiteral( parser )  ||\n\t       readBooleanLiteral( parser ) ||\n\t       readStringLiteral( parser )  ||\n\t       readObjectLiteral( parser )  ||\n\t       readArrayLiteral( parser )   ||\n\t       readRegexpLiteral( parser );\n}\n","import { ARRAY_LITERAL } from 'config/types';\nimport readExpressionList from '../../shared/readExpressionList';\n\nexport default function ( parser ) {\n\tvar start, expressionList;\n\n\tstart = parser.pos;\n\n\t// allow whitespace before '['\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '[' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\texpressionList = readExpressionList( parser );\n\n\tif ( !parser.matchString( ']' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tt: ARRAY_LITERAL,\n\t\tm: expressionList\n\t};\n}\n","import { expectedExpression } from './errors';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readExpressionList ( parser ) {\n\tvar start, expressions, expr, next;\n\n\tstart = parser.pos;\n\n\tparser.allowWhitespace();\n\n\texpr = readExpression( parser );\n\n\tif ( expr === null ) {\n\t\treturn null;\n\t}\n\n\texpressions = [ expr ];\n\n\t// allow whitespace between expression and ','\n\tparser.allowWhitespace();\n\n\tif ( parser.matchString( ',' ) ) {\n\t\tnext = readExpressionList( parser );\n\t\tif ( next === null ) {\n\t\t\tparser.error( expectedExpression );\n\t\t}\n\n\t\tnext.forEach( append );\n\t}\n\n\tfunction append ( expression ) {\n\t\texpressions.push( expression );\n\t}\n\n\treturn expressions;\n}\n","import { OBJECT_LITERAL } from 'config/types';\nimport readKeyValuePairs from './objectLiteral/keyValuePairs';\n\nexport default function ( parser ) {\n\tvar start, keyValuePairs;\n\n\tstart = parser.pos;\n\n\t// allow whitespace\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '{' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\tkeyValuePairs = readKeyValuePairs( parser );\n\n\t// allow whitespace between final value and '}'\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '}' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tt: OBJECT_LITERAL,\n\t\tm: keyValuePairs\n\t};\n}\n","import getKeyValuePair from './keyValuePair';\n\nexport default function readKeyValuePairs ( parser ) {\n\tvar start, pairs, pair, keyValuePairs;\n\n\tstart = parser.pos;\n\n\tpair = getKeyValuePair( parser );\n\tif ( pair === null ) {\n\t\treturn null;\n\t}\n\n\tpairs = [ pair ];\n\n\tif ( parser.matchString( ',' ) ) {\n\t\tkeyValuePairs = readKeyValuePairs( parser );\n\n\t\tif ( !keyValuePairs ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn pairs.concat( keyValuePairs );\n\t}\n\n\treturn pairs;\n}\n","import { KEY_VALUE_PAIR } from 'config/types';\nimport readKey from '../../../shared/readKey';\nimport readExpression from 'parse/converters/readExpression';\n\nexport default function readKeyValuePair ( parser ) {\n\tvar start, key, value;\n\n\tstart = parser.pos;\n\n\t// allow whitespace between '{' and key\n\tparser.allowWhitespace();\n\n\tkey = readKey( parser );\n\tif ( key === null ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace between key and ':'\n\tparser.allowWhitespace();\n\n\t// next character must be ':'\n\tif ( !parser.matchString( ':' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace between ':' and value\n\tparser.allowWhitespace();\n\n\t// next expression must be a, well... expression\n\tvalue = readExpression( parser );\n\tif ( value === null ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tt: KEY_VALUE_PAIR,\n\t\tk: key,\n\t\tv: value\n\t};\n}\n","import readStringLiteral from '../primary/literal/readStringLiteral';\nimport readNumberLiteral from '../primary/literal/readNumberLiteral';\nimport { name as namePattern } from './patterns';\n\nvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n// http://mathiasbynens.be/notes/javascript-properties\n// can be any name, string literal, or number literal\nexport default function readKey ( parser ) {\n\tvar token;\n\n\tif ( token = readStringLiteral( parser ) ) {\n\t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t}\n\n\tif ( token = readNumberLiteral( parser ) ) {\n\t\treturn token.v;\n\t}\n\n\tif ( token = parser.matchPattern( namePattern ) ) {\n\t\treturn token;\n\t}\n}\n","export var name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n","import { STRING_LITERAL } from 'config/types';\nimport makeQuotedStringMatcher from './stringLiteral/makeQuotedStringMatcher';\n\nvar getSingleQuotedString = makeQuotedStringMatcher( '\"' );\nvar getDoubleQuotedString = makeQuotedStringMatcher( \"'\" );\n\nexport default function ( parser ) {\n\tvar start, string;\n\n\tstart = parser.pos;\n\n\tif ( parser.matchString( '\"' ) ) {\n\t\tstring = getDoubleQuotedString( parser );\n\n\t\tif ( !parser.matchString( '\"' ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: STRING_LITERAL,\n\t\t\tv: string\n\t\t};\n\t}\n\n\tif ( parser.matchString( \"'\" ) ) {\n\t\tstring = getSingleQuotedString( parser );\n\n\t\tif ( !parser.matchString( \"'\" ) ) {\n\t\t\tparser.pos = start;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tt: STRING_LITERAL,\n\t\t\tv: string\n\t\t};\n\t}\n\n\treturn null;\n}\n","var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n// Match one or more characters until: \", ', \\, or EOL/EOF.\n// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\nstringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n// Match one escape sequence, including the backslash.\nescapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n// Match one ES5 line continuation (backslash + line terminator).\nlineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n// Helper for defining getDoubleQuotedString and getSingleQuotedString.\nexport default function ( okQuote ) {\n\treturn function ( parser ) {\n\t\tvar start, literal, done, next;\n\n\t\tstart = parser.pos;\n\t\tliteral = '\"';\n\t\tdone = false;\n\n\t\twhile ( !done ) {\n\t\t\tnext = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||\n\t\t\t\tparser.matchString( okQuote ) );\n\t\t\tif ( next ) {\n\t\t\t\tif ( next === '\"' ) {\n\t\t\t\t\tliteral += '\\\\\"';\n\t\t\t\t} else if ( next === \"\\\\'\" ) {\n\t\t\t\t\tliteral += \"'\";\n\t\t\t\t} else {\n\t\t\t\t\tliteral += next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t\t\t\tif ( next ) {\n\t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );\n\t\t\t\t} else {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tliteral += '\"';\n\n\t\t// use JSON.parse to interpret escapes\n\t\treturn JSON.parse( literal );\n\t};\n}","import { BOOLEAN_LITERAL } from 'config/types';\n\nexport default function readBooleanLiteral ( parser ) {\n\tvar remaining = parser.remaining();\n\n\tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t\tparser.pos += 4;\n\t\treturn {\n\t\t\tt: BOOLEAN_LITERAL,\n\t\t\tv: 'true'\n\t\t};\n\t}\n\n\tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t\tparser.pos += 5;\n\t\treturn {\n\t\t\tt: BOOLEAN_LITERAL,\n\t\t\tv: 'false'\n\t\t};\n\t}\n\n\treturn null;\n}\n","import { NUMBER_LITERAL } from 'config/types';\n\n// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\nvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\nexport default function readNumberLiteral ( parser ) {\n\tvar result;\n\n\tif ( result = parser.matchPattern( numberPattern ) ) {\n\t\treturn {\n\t\t\tt: NUMBER_LITERAL,\n\t\t\tv: result\n\t\t};\n\t}\n\n\treturn null;\n}\n","export var expectedExpression = 'Expected a JavaScript expression';\nexport var expectedParen = 'Expected closing paren';\n","import { DELIMCHANGE } from 'config/types';\nimport readDelimiterChange from './mustache/readDelimiterChange';\nimport readRegexpLiteral from './expressions/primary/literal/readRegexpLiteral';\n\nvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\nexport default function readMustache ( parser ) {\n\tvar mustache, i;\n\n\t// If we're inside a <script> or <style> tag, and we're not\n\t// interpolating, bug out\n\tif ( parser.interpolate[ parser.inside ] === false ) {\n\t\treturn null;\n\t}\n\n\tfor ( i = 0; i < parser.tags.length; i += 1 ) {\n\t\tif ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {\n\t\t\treturn mustache;\n\t\t}\n\t}\n}\n\nfunction readMustacheOfType ( parser, tag ) {\n\tvar start, mustache, reader, i;\n\n\tstart = parser.pos;\n\n\tif ( parser.matchString( '\\\\' + tag.open ) ) {\n\t\tif ( start === 0 || parser.str[ start - 1 ] !== '\\\\' ) {\n\t\t\treturn tag.open;\n\t\t}\n\t} else if ( !parser.matchString( tag.open ) ) {\n\t\treturn null;\n\t}\n\n\t// delimiter change?\n\tif ( mustache = readDelimiterChange( parser ) ) {\n\t\t// find closing delimiter or abort...\n\t\tif ( !parser.matchString( tag.close ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// ...then make the switch\n\t\ttag.open = mustache[0];\n\t\ttag.close = mustache[1];\n\t\tparser.sortMustacheTags();\n\n\t\treturn delimiterChangeToken;\n\t}\n\n\tparser.allowWhitespace();\n\n\t// illegal section closer\n\tif ( parser.matchString( '/' ) ) {\n\t\tparser.pos -= 1;\n\t\tlet rewind = parser.pos;\n\t\tif ( !readRegexpLiteral( parser ) ) {\n\t\t\tparser.pos = rewind - ( tag.close.length );\n\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t\t} else {\n\t\t\tparser.pos = rewind;\n\t\t}\n\t}\n\n\tfor ( i = 0; i < tag.readers.length; i += 1 ) {\n\t\treader = tag.readers[i];\n\n\t\tif ( mustache = reader( parser, tag ) ) {\n\t\t\tif ( tag.isStatic ) {\n\t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n\t\t\t}\n\n\t\t\tif ( parser.includeLinePositions ) {\n\t\t\t\tmustache.p = parser.getLinePos( start );\n\t\t\t}\n\n\t\t\treturn mustache;\n\t\t}\n\t}\n\n\tparser.pos = start;\n\treturn null;\n}\n","import { REGEXP_LITERAL } from 'config/types';\n\nvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\nexport default function readNumberLiteral ( parser ) {\n\tvar result;\n\n\tif ( result = parser.matchPattern( regexpPattern ) ) {\n\t\treturn {\n\t\t\tt: REGEXP_LITERAL,\n\t\t\tv: result\n\t\t};\n\t}\n\n\treturn null;\n}\n","var delimiterChangePattern = /^[^\\s=]+/, whitespacePattern = /^\\s+/;\n\nexport default function readDelimiterChange ( parser ) {\n\tvar start, opening, closing;\n\n\tif ( !parser.matchString( '=' ) ) {\n\t\treturn null;\n\t}\n\n\tstart = parser.pos;\n\n\t// allow whitespace before new opening delimiter\n\tparser.allowWhitespace();\n\n\topening = parser.matchPattern( delimiterChangePattern );\n\tif ( !opening ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace (in fact, it's necessary...)\n\tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t\treturn null;\n\t}\n\n\tclosing = parser.matchPattern( delimiterChangePattern );\n\tif ( !closing ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\t// allow whitespace before closing '='\n\tparser.allowWhitespace();\n\n\tif ( !parser.matchString( '=' ) ) {\n\t\tparser.pos = start;\n\t\treturn null;\n\t}\n\n\treturn [ opening, closing ];\n}\n","export var TEXT              = 1;\nexport var INTERPOLATOR      = 2;\nexport var TRIPLE            = 3;\nexport var SECTION           = 4;\nexport var INVERTED          = 5;\nexport var CLOSING           = 6;\nexport var ELEMENT           = 7;\nexport var PARTIAL           = 8;\nexport var COMMENT           = 9;\nexport var DELIMCHANGE       = 10;\nexport var ATTRIBUTE         = 13;\nexport var CLOSING_TAG       = 14;\nexport var COMPONENT         = 15;\nexport var YIELDER           = 16;\nexport var INLINE_PARTIAL    = 17;\nexport var DOCTYPE           = 18;\n\nexport var NUMBER_LITERAL    = 20;\nexport var STRING_LITERAL    = 21;\nexport var ARRAY_LITERAL     = 22;\nexport var OBJECT_LITERAL    = 23;\nexport var BOOLEAN_LITERAL   = 24;\nexport var REGEXP_LITERAL    = 25;\n\nexport var GLOBAL            = 26;\nexport var KEY_VALUE_PAIR    = 27;\n\n\nexport var REFERENCE         = 30;\nexport var REFINEMENT        = 31;\nexport var MEMBER            = 32;\nexport var PREFIX_OPERATOR   = 33;\nexport var BRACKETED         = 34;\nexport var CONDITIONAL       = 35;\nexport var INFIX_OPERATOR    = 36;\n\nexport var INVOCATION        = 40;\n\nexport var SECTION_IF        = 50;\nexport var SECTION_UNLESS    = 51;\nexport var SECTION_EACH      = 52;\nexport var SECTION_WITH      = 53;\nexport var SECTION_IF_WITH   = 54;\n\nexport var ELSE              = 60;\nexport var ELSEIF            = 61;\n","import { create, hasOwn } from 'utils/object';\n\nvar Parser, ParseError, leadingWhitespace = /^\\s+/;\n\nParseError = function ( message ) {\n\tthis.name = 'ParseError';\n\tthis.message = message;\n\ttry {\n\t\tthrow new Error(message);\n\t} catch (e) {\n\t\tthis.stack = e.stack;\n\t}\n};\n\nParseError.prototype = Error.prototype;\n\nParser = function ( str, options ) {\n\tvar items, item, lineStart = 0;\n\n\tthis.str = str;\n\tthis.options = options || {};\n\tthis.pos = 0;\n\n\tthis.lines = this.str.split( '\\n' );\n\tthis.lineEnds = this.lines.map( line => {\n\t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n\t\tlineStart = lineEnd;\n\t\treturn lineEnd;\n\t}, 0 );\n\n\t// Custom init logic\n\tif ( this.init ) this.init( str, options );\n\n\titems = [];\n\n\twhile ( ( this.pos < this.str.length ) && ( item = this.read() ) ) {\n\t\titems.push( item );\n\t}\n\n\tthis.leftover = this.remaining();\n\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n};\n\nParser.prototype = {\n\tread: function ( converters ) {\n\t\tvar pos, i, len, item;\n\n\t\tif ( !converters ) converters = this.converters;\n\n\t\tpos = this.pos;\n\n\t\tlen = converters.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.pos = pos; // reset for each attempt\n\n\t\t\tif ( item = converters[i]( this ) ) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tgetLinePos: function ( char ) {\n\t\tvar lineNum = 0, lineStart = 0, columnNum;\n\n\t\twhile ( char >= this.lineEnds[ lineNum ] ) {\n\t\t\tlineStart = this.lineEnds[ lineNum ];\n\t\t\tlineNum += 1;\n\t\t}\n\n\t\tcolumnNum = char - lineStart;\n\t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n\t},\n\n\terror: function ( message ) {\n\t\tlet pos = this.getLinePos( this.pos );\n\t\tlet lineNum = pos[0];\n\t\tlet columnNum = pos[1];\n\n\t\tlet line = this.lines[ pos[0] - 1 ];\n\t\tlet numTabs = 0;\n\t\tlet annotation = line.replace( /\\t/g, ( match, char ) => {\n\t\t\tif ( char < pos[1] ) {\n\t\t\t\tnumTabs += 1;\n\t\t\t}\n\n\t\t\treturn '  ';\n\t\t}) + '\\n' + new Array( pos[1] + numTabs ).join( ' ' ) + '^----';\n\n\t\tlet error = new ParseError( `${message} at line ${lineNum} character ${columnNum}:\\n${annotation}` );\n\n\t\terror.line = pos[0];\n\t\terror.character = pos[1];\n\t\terror.shortMessage = message;\n\n\t\tthrow error;\n\t},\n\n\tmatchString: function ( string ) {\n\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\tthis.pos += string.length;\n\t\t\treturn string;\n\t\t}\n\t},\n\n\tmatchPattern: function ( pattern ) {\n\t\tvar match;\n\n\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\tthis.pos += match[0].length;\n\t\t\treturn match[1] || match[0];\n\t\t}\n\t},\n\n\tallowWhitespace: function () {\n\t\tthis.matchPattern( leadingWhitespace );\n\t},\n\n\tremaining: function () {\n\t\treturn this.str.substring( this.pos );\n\t},\n\n\tnextChar: function () {\n\t\treturn this.str.charAt( this.pos );\n\t}\n};\n\nParser.extend = function ( proto ) {\n\tvar Parent = this, Child, key;\n\n\tChild = function ( str, options ) {\n\t\tParser.call( this, str, options );\n\t};\n\n\tChild.prototype = create( Parent.prototype );\n\n\tfor ( key in proto ) {\n\t\tif ( hasOwn.call( proto, key ) ) {\n\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t}\n\t}\n\n\tChild.extend = Parser.extend;\n\treturn Child;\n};\n\nexport default Parser;\n","import { fatal, warnIfDebug, warnOnceIfDebug } from 'utils/log';\nimport { isObject, isArray } from 'utils/is';\n\nfunction validate ( data ) {\n\t// Warn if userOptions.data is a non-POJO\n\tif ( data && data.constructor !== Object ) {\n\t\tif ( typeof data === 'function' ) {\n\t\t\t// TODO do we need to support this in the new Ractive() case?\n\t\t} else if ( typeof data !== 'object' ) {\n\t\t\tfatal( `data option must be an object or a function, \\`${data}\\` is not valid` );\n\t\t} else {\n\t\t\twarnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );\n\t\t}\n\t}\n}\n\nvar dataConfigurator = {\n\tname: 'data',\n\n\textend: ( Parent, proto, options ) => {\n\t\tlet key, value;\n\n\t\t// check for non-primitives, which could cause mutation-related bugs\n\t\tif ( options.data && isObject( options.data ) ) {\n\t\t\tfor ( key in options.data ) {\n\t\t\t\tvalue = options.data[ key ];\n\n\t\t\t\tif ( value && typeof value === 'object' ) {\n\t\t\t\t\tif ( isObject( value ) || isArray( value ) ) {\n\t\t\t\t\t\twarnIfDebug( `Passing a \\`data\\` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\n\n  // this...\n  data: function () {\n    return {\n      myObject: {}\n    };\n  })\n\n  // instead of this:\n  data: {\n    myObject: {}\n  }` );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tproto.data = combine( proto.data, options.data );\n\t},\n\n\tinit: ( Parent, ractive, options ) => {\n\t\tvar result = combine( Parent.prototype.data, options.data );\n\n\t\tif ( typeof result === 'function' ) {\n\t\t\tresult = result.call( ractive );\n\t\t}\n\n\t\treturn result || {};\n\t},\n\n\treset: function ( ractive ) {\n\t\tvar result = this.init( ractive.constructor, ractive, ractive.viewmodel );\n\n\t\tractive.viewmodel.reset( result );\n\t\treturn true;\n\t}\n};\n\nexport default dataConfigurator;\n\nfunction combine ( parentValue, childValue ) {\n\tvalidate( childValue );\n\n\tlet parentIsFn = typeof parentValue === 'function';\n\tlet childIsFn = typeof childValue === 'function';\n\n\t// Very important, otherwise child instance can become\n\t// the default data object on Ractive or a component.\n\t// then ractive.set() ends up setting on the prototype!\n\tif ( !childValue && !parentIsFn ) {\n\t\tchildValue = {};\n\t}\n\n\t// Fast path, where we just need to copy properties from\n\t// parent to child\n\tif ( !parentIsFn && !childIsFn ) {\n\t\treturn fromProperties( childValue, parentValue );\n\t}\n\n\treturn function () {\n\t\tlet child = childIsFn ? callDataFunction( childValue, this ) : childValue;\n\t\tlet parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;\n\n\t\treturn fromProperties( child, parent );\n\t};\n}\n\nfunction callDataFunction ( fn, context ) {\n\tlet data = fn.call( context );\n\n\tif ( !data ) return;\n\n\tif ( typeof data !== 'object' ) {\n\t\tfatal( 'Data function must return an object' );\n\t}\n\n\tif ( data.constructor !== Object ) {\n\t\twarnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );\n\t}\n\n\treturn data;\n}\n\nfunction fromProperties ( primary, secondary ) {\n\tif ( primary && secondary ) {\n\t\tfor ( let key in secondary ) {\n\t\t\tif ( !( key in primary ) ) {\n\t\t\t\tprimary[ key ] = secondary[ key ];\n\t\t\t}\n\t\t}\n\n\t\treturn primary;\n\t}\n\n\treturn primary || secondary;\n}\n","import css from 'global/css';\nimport transformCss from './transform';\n\nlet uid = 1;\n\nvar cssConfigurator = {\n\tname: 'css',\n\n\textend: ( Parent, proto, options ) => {\n\t\tif ( options.css ) {\n\t\t\tlet id = uid++;\n\t\t\tlet styles = options.noCssTransform ? options.css : transformCss( options.css, id );\n\n\t\t\tproto.cssId = id;\n\t\t\tcss.add({ id, styles });\n\t\t}\n\t},\n\n\tinit: () => {}\n};\n\nexport default cssConfigurator;\n","var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n\tcommentsPattern = /\\/\\*.*?\\*\\//g,\n\tselectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n\tmediaQueryPattern = /^@media/,\n\tdataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\nexport default function transformCss( css, id ) {\n\tvar transformed, dataAttr, addGuid;\n\n\tdataAttr = `[data-ractive-css~=\"{${id}}\"]`;\n\n\taddGuid = function ( selector ) {\n\t\tvar selectorUnits, match, unit, base, prepended, appended, i, transformed = [];\n\n\t\tselectorUnits = [];\n\n\t\twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t\t\tselectorUnits.push({\n\t\t\t\tstr: match[0],\n\t\t\t\tbase: match[1],\n\t\t\t\tmodifiers: match[2]\n\t\t\t});\n\t\t}\n\n\t\t// For each simple selector within the selector, we need to create a version\n\t\t// that a) combines with the id, and b) is inside the id\n\t\tbase = selectorUnits.map( extractString );\n\n\t\ti = selectorUnits.length;\n\t\twhile ( i-- ) {\n\t\t\tappended = base.slice();\n\n\t\t\t// Pseudo-selectors should go after the attribute selector\n\t\t\tunit = selectorUnits[i];\n\t\t\tappended[i] = unit.base + dataAttr + unit.modifiers || '';\n\n\t\t\tprepended = base.slice();\n\t\t\tprepended[i] = dataAttr + ' ' + prepended[i];\n\n\t\t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t\t}\n\n\t\treturn transformed.join( ', ' );\n\t};\n\n\tif ( dataRvcGuidPattern.test( css ) ) {\n\t\ttransformed = css.replace( dataRvcGuidPattern, dataAttr );\n\t} else {\n\t\ttransformed = css\n\t\t.replace( commentsPattern, '' )\n\t\t.replace( selectorsPattern, function ( match, $1 ) {\n\t\t\tvar selectors, transformed;\n\n\t\t\t// don't transform media queries!\n\t\t\tif ( mediaQueryPattern.test( $1 ) ) return match;\n\n\t\t\tselectors = $1.split( ',' ).map( trim );\n\t\t\ttransformed = selectors.map( addGuid ).join( ', ' ) + ' ';\n\n\t\t\treturn match.replace( $1, transformed );\n\t\t});\n\t}\n\n\treturn transformed;\n}\n\nfunction trim ( str ) {\n\tif ( str.trim ) {\n\t\treturn str.trim();\n\t}\n\n\treturn str.replace( /^\\s+/, '' ).replace( /\\s+$/, '' );\n}\n\nfunction extractString ( unit ) {\n\treturn unit.str;\n}\n","import { ensureArray } from 'utils/array';\n\nvar adaptConfigurator = {\n\textend: ( Parent, proto, options ) => {\n\t\tproto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );\n\t},\n\n\tinit () {}\n};\n\nexport default adaptConfigurator;\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}","import css from 'global/css';\nimport Hook from './shared/hooks/Hook';\nimport { getElement } from 'utils/dom';\nimport { teardown } from 'shared/methodCallers';\nimport runloop from 'global/runloop';\n\nvar renderHook = new Hook( 'render' ),\n\tcompleteHook = new Hook( 'complete' );\n\nexport default function Ractive$render ( target, anchor ) {\n\tvar promise, instances, transitionsEnabled;\n\n\t// if `noIntro` is `true`, temporarily disable transitions\n\ttransitionsEnabled = this.transitionsEnabled;\n\tif ( this.noIntro ) {\n\t\tthis.transitionsEnabled = false;\n\t}\n\n\tpromise = runloop.start( this, true );\n\trunloop.scheduleTask( () => renderHook.fire( this ), true );\n\n\tif ( this.fragment.rendered ) {\n\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t}\n\n\ttarget = getElement( target ) || this.el;\n\tanchor = getElement( anchor ) || this.anchor;\n\n\tthis.el = target;\n\tthis.anchor = anchor;\n\n\tif ( !this.append && target ) {\n\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t// avoids certain weird bugs\n\t\tlet others = target.__ractive_instances__;\n\t\tif ( others && others.length ) {\n\t\t\tremoveOtherInstances( others );\n\t\t}\n\n\t\t// make sure we are the only occupants\n\t\ttarget.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n\t}\n\n\tif ( this.cssId ) {\n\t\t// ensure encapsulated CSS is up-to-date\n\t\tcss.apply();\n\t}\n\n\tif ( target ) {\n\t\tif ( !( instances = target.__ractive_instances__ ) ) {\n\t\t\ttarget.__ractive_instances__ = [ this ];\n\t\t} else {\n\t\t\tinstances.push( this );\n\t\t}\n\n\t\tif ( anchor ) {\n\t\t\ttarget.insertBefore( this.fragment.render(), anchor );\n\t\t} else {\n\t\t\ttarget.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\trunloop.end();\n\n\tthis.transitionsEnabled = transitionsEnabled;\n\n\treturn promise.then( () => completeHook.fire( this ) );\n}\n\nfunction removeOtherInstances ( others ) {\n\tothers.splice( 0, others.length ).forEach( teardown );\n}\n","import { isClient } from 'config/environment';\nimport noop from 'utils/noop';\n\nvar css,\n\tupdate,\n\tstyleElement,\n\thead,\n\tstyleSheet,\n\tinDom,\n\tprefix = '/* Ractive.js component styles */\\n',\n\tstyles = [],\n\tdirty = false;\n\nif ( !isClient ) {\n\t// TODO handle encapsulated CSS in server-rendered HTML!\n\tcss = {\n\t\tadd: noop,\n\t\tapply: noop\n\t};\n} else {\n\tstyleElement = document.createElement( 'style' );\n\tstyleElement.type = 'text/css';\n\n\thead = document.getElementsByTagName( 'head' )[0];\n\n\tinDom = false;\n\n\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n\t// use styleSheet.cssText instead\n\tstyleSheet = styleElement.styleSheet;\n\n\tupdate = function () {\n\t\tlet css = prefix + styles.map( s => `\\n/* {${s.id}} */\\n${s.styles}` ).join( '\\n' );\n\n\t\tif ( styleSheet ) {\n\t\t\tstyleSheet.cssText = css;\n\t\t} else {\n\t\t\tstyleElement.innerHTML = css;\n\t\t}\n\n\t\tif ( !inDom ) {\n\t\t\thead.appendChild( styleElement );\n\t\t\tinDom = true;\n\t\t}\n\t};\n\n\tcss = {\n\t\tadd ( s ) {\n\t\t\tstyles.push( s );\n\t\t\tdirty = true;\n\t\t},\n\n\t\tapply () {\n\t\t\tif ( dirty ) {\n\t\t\t\tupdate();\n\t\t\t\tdirty = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport default css;\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'push' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'pop' );\n","import { isArray } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\nimport getNewIndices from 'shared/getNewIndices';\n\nvar arrayProto = Array.prototype;\n\nexport default function ( methodName ) {\n\treturn function ( keypath, ...args ) {\n\t\tvar array, newIndices = [], len, promise, result;\n\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\n\t\tarray = this.viewmodel.get( keypath );\n\t\tlen = array.length;\n\n\t\tif ( !isArray( array ) ) {\n\t\t\tthrow new Error( 'Called ractive.' + methodName + '(\\'' + keypath.str + '\\'), but \\'' + keypath.str + '\\' does not refer to an array' );\n\t\t}\n\n\t\tnewIndices = getNewIndices( array, methodName, args );\n\n\t\tresult = arrayProto[ methodName ].apply( array, args );\n\t\tpromise = runloop.start( this, true ).then( () => result );\n\n\t\tif ( !!newIndices ) {\n\t\t\tthis.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t} else {\n\t\t\tthis.viewmodel.mark( keypath );\n\t\t}\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t};\n}\n","// This function takes an array, the name of a mutator method, and the\n// arguments to call that mutator method with, and returns an array that\n// maps the old indices to their new indices.\n\n// So if you had something like this...\n//\n//     array = [ 'a', 'b', 'c', 'd' ];\n//     array.push( 'e' );\n//\n// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n// have changed. If you then did this...\n//\n//     array.unshift( 'z' );\n//\n// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n// one higher to make room for the 'z'. If you removed an item, the new index\n// would be -1...\n//\n//     array.splice( 2, 2 );\n//\n// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n//\n// This information is used to enable fast, non-destructive shuffling of list\n// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\nexport default function getNewIndices ( array, methodName, args ) {\n\tvar spliceArguments, len, newIndices = [], removeStart, removeEnd, balance, i;\n\n\tspliceArguments = getSpliceEquivalent( array, methodName, args );\n\n\tif ( !spliceArguments ) {\n\t\treturn null; // TODO support reverse and sort?\n\t}\n\n\tlen = array.length;\n\tbalance = ( spliceArguments.length - 2 ) - spliceArguments[1];\n\n\tremoveStart = Math.min( len, spliceArguments[0] );\n\tremoveEnd = removeStart + spliceArguments[1];\n\n\tfor ( i = 0; i < removeStart; i += 1 ) {\n\t\tnewIndices.push( i );\n\t}\n\n\tfor ( ; i < removeEnd; i += 1 ) {\n\t\tnewIndices.push( -1 );\n\t}\n\n\tfor ( ; i < len; i += 1 ) {\n\t\tnewIndices.push( i + balance );\n\t}\n\n\t// there is a net shift for the rest of the array starting with index + balance\n\tif ( balance !== 0 ) {\n\t\tnewIndices.touchedFrom = spliceArguments[0];\n\t} else {\n\t\tnewIndices.touchedFrom = array.length;\n\t}\n\n\treturn newIndices;\n}\n\n\n// The pop, push, shift an unshift methods can all be represented\n// as an equivalent splice\nfunction getSpliceEquivalent ( array, methodName, args ) {\n\tswitch ( methodName ) {\n\t\tcase 'splice':\n\t\t\tif ( args[0] !== undefined && args[0] < 0 ) {\n\t\t\t\targs[0] = array.length + Math.max( args[0], -array.length );\n\t\t\t}\n\n\t\t\twhile ( args.length < 2 ) {\n\t\t\t\targs.push( 0 );\n\t\t\t}\n\n\t\t\t// ensure we only remove elements that exist\n\t\t\targs[1] = Math.min( args[1], array.length - args[0] );\n\n\t\t\treturn args;\n\n\t\tcase 'sort':\n\t\tcase 'reverse':\n\t\t\treturn null;\n\n\t\tcase 'pop':\n\t\t\tif ( array.length ) {\n\t\t\t\treturn [ array.length - 1, 1 ];\n\t\t\t}\n\t\t\treturn [ 0, 0 ];\n\n\t\tcase 'push':\n\t\t\treturn [ array.length, 0 ].concat( args );\n\n\t\tcase 'shift':\n\t\t\treturn [ 0, array.length ? 1 : 0 ];\n\n\t\tcase 'unshift':\n\t\t\treturn [ 0, 0 ].concat( args );\n\t}\n}\n","export default function Ractive$once ( eventName, handler ) {\n\n\tvar listener = this.on( eventName, function () {\n\t\thandler.apply( this, arguments );\n\t\tlistener.cancel();\n\t});\n\n\t// so we can still do listener.cancel() manually\n\treturn listener;\n}\n","import trim from './shared/trim';\nimport notEmptyString from './shared/notEmptyString';\n\nexport default function Ractive$on ( eventName, callback ) {\n\tvar listeners, n, eventNames;\n\n\t// allow mutliple listeners to be bound in one go\n\tif ( typeof eventName === 'object' ) {\n\t\tlisteners = [];\n\n\t\tfor ( n in eventName ) {\n\t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcancel: function () {\n\t\t\t\tvar listener;\n\n\t\t\t\twhile ( listener = listeners.pop() ) {\n\t\t\t\t\tlistener.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Handle multiple space-separated event names\n\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n\teventNames.forEach( eventName => {\n\t\t( this._subs[ eventName ] || ( this._subs[ eventName ] = [] ) ).push( callback );\n\t});\n\n\treturn {\n\t\tcancel: () => this.off( eventName, callback )\n\t};\n}\n","import trim from './shared/trim';\nimport notEmptyString from './shared/notEmptyString';\n\nexport default function Ractive$off ( eventName, callback ) {\n\tvar eventNames;\n\n\t// if no arguments specified, remove all callbacks\n\tif ( !eventName ) {\n\t\t// TODO use this code instead, once the following issue has been resolved\n\t\t// in PhantomJS (tests are unpassable otherwise!)\n\t\t// https://github.com/ariya/phantomjs/issues/11856\n\t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t\tfor ( eventName in this._subs ) {\n\t\t\tdelete this._subs[ eventName ];\n\t\t}\n\t}\n\n\telse {\n\t\t// Handle multiple space-separated event names\n\t\teventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n\t\teventNames.forEach( eventName => {\n\t\t\tvar subscribers, index;\n\n\t\t\t// If we have subscribers for this event...\n\t\t\tif ( subscribers = this._subs[ eventName ] ) {\n\t\t\t\t// ...if a callback was specified, only remove that\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tindex = subscribers.indexOf( callback );\n\t\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ...otherwise remove all callbacks\n\t\t\t\telse {\n\t\t\t\t\tthis._subs[ eventName ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\treturn this;\n}\n","export default str => str !== '';\n","export default str => str.trim();\n","export default function Ractive$observeOnce ( property, callback, options ) {\n\n\tvar observer = this.observe( property, function () {\n\t\tcallback.apply( this, arguments );\n\t\tobserver.cancel();\n\t}, { init: false, defer: options && options.defer });\n\n\treturn observer;\n}\n","import { isObject } from 'utils/is';\nimport getObserverFacade from './observe/getObserverFacade';\n\nexport default function Ractive$observe ( keypath, callback, options ) {\n\n\tvar observers, map, keypaths, i;\n\n\t// Allow a map of keypaths to handlers\n\tif ( isObject( keypath ) ) {\n\t\toptions = callback;\n\t\tmap = keypath;\n\n\t\tobservers = [];\n\n\t\tfor ( keypath in map ) {\n\t\t\tif ( map.hasOwnProperty( keypath ) ) {\n\t\t\t\tcallback = map[ keypath ];\n\t\t\t\tobservers.push( this.observe( keypath, callback, options ) );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcancel: function () {\n\t\t\t\twhile ( observers.length ) {\n\t\t\t\t\tobservers.pop().cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Allow `ractive.observe( callback )` - i.e. observe entire model\n\tif ( typeof keypath === 'function' ) {\n\t\toptions = callback;\n\t\tcallback = keypath;\n\t\tkeypath = '';\n\n\t\treturn getObserverFacade( this, keypath, callback, options );\n\t}\n\n\tkeypaths = keypath.split( ' ' );\n\n\t// Single keypath\n\tif ( keypaths.length === 1 ) {\n\t\treturn getObserverFacade( this, keypath, callback, options );\n\t}\n\n\t// Multiple space-separated keypaths\n\tobservers = [];\n\n\ti = keypaths.length;\n\twhile ( i-- ) {\n\t\tkeypath = keypaths[i];\n\n\t\tif ( keypath ) {\n\t\t\tobservers.push( getObserverFacade( this, keypath, callback, options ) );\n\t\t}\n\t}\n\n\treturn {\n\t\tcancel: function () {\n\t\t\twhile ( observers.length ) {\n\t\t\t\tobservers.pop().cancel();\n\t\t\t}\n\t\t}\n\t};\n}\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport Observer from './Observer';\nimport PatternObserver from './PatternObserver';\n\nlet emptyObject = {};\n\nexport default function getObserverFacade ( ractive, keypath, callback, options ) {\n\tvar observer, isPatternObserver, cancelled;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\toptions = options || emptyObject;\n\n\t// pattern observers are treated differently\n\tif ( keypath.isPattern ) {\n\t\tobserver = new PatternObserver( ractive, keypath, callback, options );\n\t\tractive.viewmodel.patternObservers.push( observer );\n\t\tisPatternObserver = true;\n\t} else {\n\t\tobserver = new Observer( ractive, keypath, callback, options );\n\t}\n\n\tobserver.init( options.init );\n\tractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );\n\n\t// This flag allows observers to initialise even with undefined values\n\tobserver.ready = true;\n\n\tlet facade = {\n\t\tcancel () {\n\t\t\tvar index;\n\n\t\t\tif ( cancelled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isPatternObserver ) {\n\t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf( observer );\n\n\t\t\t\tractive.viewmodel.patternObservers.splice( index, 1 );\n\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'patternObservers' );\n\t\t\t} else {\n\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'observers' );\n\t\t\t}\n\t\t\tcancelled = true;\n\t\t}\n\t};\n\n\tractive._observers.push( facade );\n\treturn facade;\n}\n","import runloop from 'global/runloop';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\nimport getPattern from './getPattern';\n\nvar PatternObserver, slice = Array.prototype.slice;\n\nPatternObserver = function ( ractive, keypath, callback, options ) {\n\tthis.root = ractive;\n\n\tthis.callback = callback;\n\tthis.defer = options.defer;\n\n\tthis.keypath = keypath;\n\tthis.regex = new RegExp( '^' + keypath.str.replace( /\\./g, '\\\\.' ).replace( /\\*/g, '([^\\\\.]+)' ) + '$' );\n\tthis.values = {};\n\n\tif ( this.defer ) {\n\t\tthis.proxies = [];\n\t}\n\n\t// default to root as context, but allow it to be overridden\n\tthis.context = ( options && options.context ? options.context : ractive );\n};\n\nPatternObserver.prototype = {\n\tinit: function ( immediate ) {\n\t\tvar values, keypath;\n\n\t\tvalues = getPattern( this.root, this.keypath );\n\n\t\tif ( immediate !== false ) {\n\t\t\tfor ( keypath in values ) {\n\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\tthis.update( getKeypath( keypath ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.values = values;\n\t\t}\n\t},\n\n\tupdate: function ( keypath ) {\n\t\tvar values;\n\n\t\tif ( keypath.isPattern ) {\n\t\t\tvalues = getPattern( this.root, keypath );\n\n\t\t\tfor ( keypath in values ) {\n\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\tthis.update( getKeypath( keypath ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - array mutation should not trigger `array.*`\n\t\t// pattern observer with `array.length`\n\t\tif ( this.root.viewmodel.implicitChanges[ keypath.str ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.defer && this.ready ) {\n\t\t\trunloop.scheduleTask( () => this.getProxy( keypath ).update() );\n\t\t\treturn;\n\t\t}\n\n\t\tthis.reallyUpdate( keypath );\n\t},\n\n\treallyUpdate: function ( keypath ) {\n\t\tvar keypathStr, value, keys, args;\n\n\t\tkeypathStr = keypath.str;\n\t\tvalue = this.root.viewmodel.get( keypath );\n\n\t\t// Prevent infinite loops\n\t\tif ( this.updating ) {\n\t\t\tthis.values[ keypathStr ] = value;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updating = true;\n\n\t\tif ( !isEqual( value, this.values[ keypathStr ] ) || !this.ready ) {\n\t\t\tkeys = slice.call( this.regex.exec( keypathStr ), 1 );\n\t\t\targs = [ value, this.values[ keypathStr ], keypathStr ].concat( keys );\n\n\t\t\tthis.values[ keypathStr ] = value;\n\t\t\tthis.callback.apply( this.context, args );\n\t\t}\n\n\t\tthis.updating = false;\n\t},\n\n\tgetProxy: function ( keypath ) {\n\t\tif ( !this.proxies[ keypath.str ] ) {\n\t\t\tthis.proxies[ keypath.str ] = {\n\t\t\t\tupdate: () => this.reallyUpdate( keypath )\n\t\t\t};\n\t\t}\n\n\t\treturn this.proxies[ keypath.str ];\n\t}\n};\n\nexport default PatternObserver;\n","import { getMatchingKeypaths } from 'shared/keypaths';\n\nexport default function getPattern ( ractive, pattern ) {\n\tvar matchingKeypaths, values;\n\n\tmatchingKeypaths = getMatchingKeypaths( ractive, pattern );\n\n\tvalues = {};\n\tmatchingKeypaths.forEach( keypath => {\n\t\tvalues[ keypath.str ] = ractive.get( keypath.str );\n\t});\n\n\treturn values;\n}\n","import runloop from 'global/runloop';\nimport { isEqual } from 'utils/is';\n\nvar Observer = function ( ractive, keypath, callback, options ) {\n\tthis.root = ractive;\n\tthis.keypath = keypath;\n\tthis.callback = callback;\n\tthis.defer = options.defer;\n\n\t// default to root as context, but allow it to be overridden\n\tthis.context = ( options && options.context ? options.context : ractive );\n};\n\nObserver.prototype = {\n\tinit: function ( immediate ) {\n\t\tthis.value = this.root.get( this.keypath.str );\n\n\t\tif ( immediate !== false ) {\n\t\t\tthis.update();\n\t\t} else {\n\t\t\tthis.oldValue = this.value;\n\t\t}\n\t},\n\n\tsetValue: function ( value ) {\n\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\tthis.value = value;\n\n\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\trunloop.scheduleTask( () => this.update() );\n\t\t\t} else {\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\t// Prevent infinite loops\n\t\tif ( this.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updating = true;\n\n\t\tthis.callback.call( this.context, this.value, this.oldValue, this.keypath.str );\n\t\tthis.oldValue = this.value;\n\n\t\tthis.updating = false;\n\t}\n};\n\nexport default Observer;\n","import { isArray } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\n\nexport default function Ractive$merge ( keypath, array, options ) {\n\tvar currentArray,\n\t\tpromise;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\tcurrentArray = this.viewmodel.get( keypath );\n\n\t// If either the existing value or the new value isn't an\n\t// array, just do a regular set\n\tif ( !isArray( currentArray ) || !isArray( array ) ) {\n\t\treturn this.set( keypath, array, options && options.complete );\n\t}\n\n\t// Manage transitions\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.merge( keypath, currentArray, array, options );\n\trunloop.end();\n\n\treturn promise;\n}\n","import Hook from './shared/hooks/Hook';\nimport { getElement } from 'utils/dom';\n\nvar insertHook = new Hook( 'insert' );\n\nexport default function Ractive$insert ( target, anchor ) {\n\tif ( !this.fragment.rendered ) {\n\t\t// TODO create, and link to, documentation explaining this\n\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t}\n\n\ttarget = getElement( target );\n\tanchor = getElement( anchor ) || null;\n\n\tif ( !target ) {\n\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t}\n\n\ttarget.insertBefore( this.detach(), anchor );\n\tthis.el = target;\n\n\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\tthis.detached = null;\n\n\tfireInsertHook( this );\n}\n\nfunction fireInsertHook( ractive ) {\n\tinsertHook.fire( ractive );\n\n\tractive.findAllComponents('*').forEach( child => {\n\t\tfireInsertHook( child.instance );\n\t});\n}\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport resolveRef from 'shared/resolveRef';\n\nvar options = {\n\tcapture: true, // top-level calls should be intercepted\n\tnoUnwrap: true, // wrapped values should NOT be unwrapped\n\tfullRootGet: true // root get should return mappings\n};\n\nexport default function Ractive$get ( keypath ) {\n\tvar value;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\tvalue = this.viewmodel.get( keypath, options );\n\n\t// Create inter-component binding, if necessary\n\tif ( value === undefined && this.parent && !this.isolated ) {\n\t\tif ( resolveRef( this, keypath.str, this.component.parentFragment ) ) { // creates binding as side-effect, if appropriate\n\t\t\tvalue = this.viewmodel.get( keypath );\n\t\t}\n\t}\n\n\treturn value;\n}\n","import fireEvent from 'Ractive/prototype/shared/fireEvent';\n\nexport default function Ractive$fire ( eventName ) {\n\n\tvar options = {\n\t\targs: Array.prototype.slice.call( arguments, 1 )\n\t};\n\n\tfireEvent( this, eventName, options );\n}\n","import { getKeypath } from 'shared/keypaths'; // TODO bit of a hack, using getKeypath - should maybe have dedicated utility for this\nimport eventStack from './eventStack';\n\nexport default function fireEvent ( ractive, eventName, options = {} ) {\n\tif ( !eventName ) { return; }\n\n\tif ( !options.event ) {\n\t\toptions.event = {\n\t\t\tname: eventName,\n\t\t\t// until event not included as argument default\n\t\t\t_noArg: true\n\t\t};\n\t} else {\n\t\toptions.event.name = eventName;\n\t}\n\n\tvar eventNames = getKeypath( eventName ).wildcardMatches();\n\tfireEventAs( ractive, eventNames, options.event, options.args, true );\n}\n\nfunction fireEventAs  ( ractive, eventNames, event, args, initialFire = false ) {\n\n\tvar subscribers, i, bubble = true;\n\n\teventStack.enqueue( ractive, event );\n\n\tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\n\t\tif ( subscribers ) {\n\t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t\t}\n\t}\n\n\teventStack.dequeue( ractive );\n\n\tif ( ractive.parent && bubble ) {\n\n\t\tif ( initialFire && ractive.component ) {\n\t\t\tlet fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];\n\t\t\teventNames = getKeypath( fullName ).wildcardMatches();\n\n\t\t\tif( event ) {\n\t\t\t\tevent.component = ractive;\n\t\t\t}\n\t\t}\n\n\t\tfireEventAs( ractive.parent, eventNames, event, args );\n\t}\n}\n\nfunction notifySubscribers ( ractive, subscribers, event, args ) {\n\tvar originalEvent = null, stopEvent = false;\n\n\tif ( event && !event._noArg ) {\n\t\targs = [ event ].concat( args );\n\t}\n\n\t// subscribers can be modified inflight, e.g. \"once\" functionality\n\t// so we need to copy to make sure everyone gets called\n\tsubscribers = subscribers.slice();\n\n\tfor ( let i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t\tif ( subscribers[ i ].apply( ractive, args ) === false ) {\n\t\t\tstopEvent = true;\n\t\t}\n\t}\n\n\tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t}\n\n\treturn !stopEvent;\n}\n","var eventStack = {\n\tenqueue: function( ractive, event ) {\n\t\tif ( ractive.event ) {\n\t\t\tractive._eventQueue = ractive._eventQueue || [];\n\t\t\tractive._eventQueue.push( ractive.event );\n\t\t}\n\t\tractive.event = event;\n\t},\n\tdequeue: function( ractive ) {\n\t\tif ( ractive._eventQueue && ractive._eventQueue.length ) {\n\t\t\tractive.event = ractive._eventQueue.pop();\n\t\t} else {\n\t\t\tdelete ractive.event;\n\t\t}\n\t}\n};\n\nexport default eventStack;\n","export default function Ractive$findParent ( selector ) {\n\n\tif ( this.parent ) {\n\t\tif ( this.parent.component && this.parent.component.name === selector ) {\n\t\t\treturn this.parent;\n\t\t} else {\n\t\t\treturn this.parent.findParent ( selector );\n\t\t}\n\t}\n\n\treturn null;\n}\n","export default function Ractive$findContainer ( selector ) {\n\tif ( this.container ) {\n\t\tif ( this.container.component && this.container.component.name === selector ) {\n\t\t\treturn this.container;\n\t\t} else {\n\t\t\treturn this.container.findContainer( selector );\n\t\t}\n\t}\n\n\treturn null;\n}","export default function Ractive$findComponent ( selector ) {\n\treturn this.fragment.findComponent( selector );\n}\n","import makeQuery from './shared/makeQuery/_makeQuery';\n\nexport default function Ractive$findAllComponents ( selector, options ) {\n\tvar liveQueries, query;\n\n\toptions = options || {};\n\tliveQueries = this._liveComponentQueries;\n\n\t// Shortcut: if we're maintaining a live query with this\n\t// selector, we don't need to traverse the parallel DOM\n\tif ( query = liveQueries[ selector ] ) {\n\n\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\treturn ( options && options.live ) ? query : query.slice();\n\t}\n\n\tquery = makeQuery( this, selector, !!options.live, true );\n\n\t// Add this to the list of live queries Ractive needs to maintain,\n\t// if applicable\n\tif ( query.live ) {\n\t\tliveQueries.push( selector );\n\t\tliveQueries[ '_' + selector ] = query;\n\t}\n\n\tthis.fragment.findAllComponents( selector, query );\n\treturn query;\n}\n","import makeQuery from './shared/makeQuery/_makeQuery';\n\nexport default function Ractive$findAll ( selector, options ) {\n\tvar liveQueries, query;\n\n\tif ( !this.el ) {\n\t\treturn [];\n\t}\n\n\toptions = options || {};\n\tliveQueries = this._liveQueries;\n\n\t// Shortcut: if we're maintaining a live query with this\n\t// selector, we don't need to traverse the parallel DOM\n\tif ( query = liveQueries[ selector ] ) {\n\n\t\t// Either return the exact same query, or (if not live) a snapshot\n\t\treturn ( options && options.live ) ? query : query.slice();\n\t}\n\n\tquery = makeQuery( this, selector, !!options.live, false );\n\n\t// Add this to the list of live queries Ractive needs to maintain,\n\t// if applicable\n\tif ( query.live ) {\n\t\tliveQueries.push( selector );\n\t\tliveQueries[ '_' + selector ] = query;\n\t}\n\n\tthis.fragment.findAll( selector, query );\n\treturn query;\n}\n","import { defineProperties } from 'utils/object';\nimport test from './test';\nimport cancel from './cancel';\nimport sort from './sort';\nimport dirty from './dirty';\nimport remove from './remove';\n\nexport default function makeQuery ( ractive, selector, live, isComponentQuery ) {\n\tvar query = [];\n\n\tdefineProperties( query, {\n\t\tselector: { value: selector },\n\t\tlive: { value: live },\n\n\t\t_isComponentQuery: { value: isComponentQuery },\n\t\t_test: { value: test }\n\t});\n\n\tif ( !live ) {\n\t\treturn query;\n\t}\n\n\tdefineProperties( query, {\n\t\tcancel: { value: cancel },\n\n\t\t_root: { value: ractive },\n\t\t_sort: { value: sort },\n\t\t_makeDirty: { value: dirty },\n\t\t_remove: { value: remove },\n\n\t\t_dirty: { value: false, writable: true }\n\t});\n\n\treturn query;\n}\n","export default function ( nodeOrComponent ) {\n\tvar index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\n\tif ( index !== -1 ) {\n\t\tthis.splice( index, 1 );\n\t}\n}\n","import runloop from 'global/runloop';\n\nexport default function () {\n\tif ( !this._dirty ) {\n\t\tthis._dirty = true;\n\n\t\t// Once the DOM has been updated, ensure the query\n\t\t// is correctly ordered\n\t\trunloop.scheduleTask( () => {\n\t\t\tthis._sort();\n\t\t});\n\t}\n}\n","import sortByDocumentPosition from './sortByDocumentPosition';\nimport sortByItemPosition from './sortByItemPosition';\n\nexport default function () {\n\tthis.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\tthis._dirty = false;\n}\n","import sortByItemPosition from './sortByItemPosition';\n\nexport default function ( node, otherNode ) {\n\tvar bitmask;\n\n\tif ( node.compareDocumentPosition ) {\n\t\tbitmask = node.compareDocumentPosition( otherNode );\n\t\treturn ( bitmask & 2 ) ? 1 : -1;\n\t}\n\n\t// In old IE, we can piggy back on the mechanism for\n\t// comparing component positions\n\treturn sortByItemPosition( node, otherNode );\n}\n","import { lastItem } from 'utils/array';\n\nexport default function ( a, b ) {\n\tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n\tancestryA = getAncestry( a.component || a._ractive.proxy );\n\tancestryB = getAncestry( b.component || b._ractive.proxy );\n\n\toldestA = lastItem( ancestryA );\n\toldestB = lastItem( ancestryB );\n\n\t// remove items from the end of both ancestries as long as they are identical\n\t// - the final one removed is the closest mutual ancestor\n\twhile ( oldestA && ( oldestA === oldestB ) ) {\n\t\tancestryA.pop();\n\t\tancestryB.pop();\n\n\t\tmutualAncestor = oldestA;\n\n\t\toldestA = lastItem( ancestryA );\n\t\toldestB = lastItem( ancestryB );\n\t}\n\n\t// now that we have the mutual ancestor, we can find which is earliest\n\toldestA = oldestA.component || oldestA;\n\toldestB = oldestB.component || oldestB;\n\n\tfragmentA = oldestA.parentFragment;\n\tfragmentB = oldestB.parentFragment;\n\n\t// if both items share a parent fragment, our job is easy\n\tif ( fragmentA === fragmentB ) {\n\t\tindexA = fragmentA.items.indexOf( oldestA );\n\t\tindexB = fragmentB.items.indexOf( oldestB );\n\n\t\t// if it's the same index, it means one contains the other,\n\t\t// so we see which has the longest ancestry\n\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t}\n\n\t// if mutual ancestor is a section, we first test to see which section\n\t// fragment comes first\n\tif ( fragments = mutualAncestor.fragments ) {\n\t\tindexA = fragments.indexOf( fragmentA );\n\t\tindexB = fragments.indexOf( fragmentB );\n\n\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t}\n\n\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );\n}\n\nfunction getParent ( item ) {\n\tvar parentFragment;\n\n\tif ( parentFragment = item.parentFragment ) {\n\t\treturn parentFragment.owner;\n\t}\n\n\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\treturn parentFragment.owner;\n\t}\n}\n\nfunction getAncestry ( item ) {\n\tvar ancestry, ancestor;\n\n\tancestry = [ item ];\n\n\tancestor = getParent( item );\n\n\twhile ( ancestor ) {\n\t\tancestry.push( ancestor );\n\t\tancestor = getParent( ancestor );\n\t}\n\n\treturn ancestry;\n}\n","export default function () {\n\tvar liveQueries, selector, index;\n\n\tliveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\tselector = this.selector;\n\n\tindex = liveQueries.indexOf( selector );\n\n\tif ( index !== -1 ) {\n\t\tliveQueries.splice( index, 1 );\n\t\tliveQueries[ selector ] = null;\n\t}\n}\n","import { matches } from 'utils/dom';\n\nexport default function Query$test ( item, noDirty ) {\n\tvar itemMatches;\n\n\tif ( this._isComponentQuery ) {\n\t\titemMatches = !this.selector || item.name === this.selector;\n\t} else {\n\t\titemMatches = item.node ? matches( item.node, this.selector ) : null;\n\t}\n\n\tif ( itemMatches ) {\n\t\tthis.push( item.node || item.instance );\n\n\t\tif ( !noDirty ) {\n\t\t\tthis._makeDirty();\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","export default function Ractive$find ( selector ) {\n\tif ( !this.el ) {\n\t\treturn null;\n\t}\n\n\treturn this.fragment.find( selector );\n}\n","import Hook from './shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Ractive$detach () {\n\tif ( this.detached ) {\n\t\treturn this.detached;\n\t}\n\n\tif ( this.el ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\tthis.detached = this.fragment.detach();\n\tdetachHook.fire( this );\n\treturn this.detached;\n}\n","import animations from 'shared/animations';\nimport Animation from './animate/Animation';\nimport { isEqual } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport Promise from 'utils/Promise';\nimport noop from 'utils/noop';\n\nvar noAnimation = { stop: noop };\n\nexport default function Ractive$animate ( keypath, to, options ) {\n\tvar promise,\n\t\tfulfilPromise,\n\t\tk,\n\t\tanimation,\n\t\tanimations,\n\t\teasing,\n\t\tduration,\n\t\tstep,\n\t\tcomplete,\n\t\tmakeValueCollector,\n\t\tcurrentValues,\n\t\tcollectValue,\n\t\tdummy,\n\t\tdummyOptions;\n\n\tpromise = new Promise( fulfil => fulfilPromise = fulfil );\n\n\t// animate multiple keypaths\n\tif ( typeof keypath === 'object' ) {\n\t\toptions = to || {};\n\t\teasing = options.easing;\n\t\tduration = options.duration;\n\n\t\tanimations = [];\n\n\t\t// we don't want to pass the `step` and `complete` handlers, as they will\n\t\t// run for each animation! So instead we'll store the handlers and create\n\t\t// our own...\n\t\tstep = options.step;\n\t\tcomplete = options.complete;\n\n\t\tif ( step || complete ) {\n\t\t\tcurrentValues = {};\n\n\t\t\toptions.step = null;\n\t\t\toptions.complete = null;\n\n\t\t\tmakeValueCollector = function ( keypath ) {\n\t\t\t\treturn function ( t, value ) {\n\t\t\t\t\tcurrentValues[ keypath ] = value;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\n\t\tfor ( k in keypath ) {\n\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\tif ( step || complete ) {\n\t\t\t\t\tcollectValue = makeValueCollector( k );\n\t\t\t\t\toptions = { easing, duration };\n\n\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\toptions.step = collectValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toptions.complete = complete ? collectValue : noop;\n\t\t\t\tanimations.push( animate( this, k, keypath[k], options ) );\n\t\t\t}\n\t\t}\n\n\t\t// Create a dummy animation, to facilitate step/complete\n\t\t// callbacks, and Promise fulfilment\n\t\tdummyOptions = { easing, duration };\n\n\t\tif ( step ) {\n\t\t\tdummyOptions.step = t => step( t, currentValues );\n\t\t}\n\n\t\tif ( complete ) {\n\t\t\tpromise.then( t => complete( t, currentValues ) );\n\t\t}\n\n\t\tdummyOptions.complete = fulfilPromise;\n\n\t\tdummy = animate( this, null, null, dummyOptions );\n\t\tanimations.push( dummy );\n\n\t\tpromise.stop = () => {\n\t\t\tvar animation;\n\n\t\t\twhile ( animation = animations.pop() ) {\n\t\t\t\tanimation.stop();\n\t\t\t}\n\n\t\t\tif ( dummy ) {\n\t\t\t\tdummy.stop();\n\t\t\t}\n\t\t};\n\n\t\treturn promise;\n\t}\n\n\t// animate a single keypath\n\toptions = options || {};\n\n\tif ( options.complete ) {\n\t\tpromise.then( options.complete );\n\t}\n\n\toptions.complete = fulfilPromise;\n\tanimation = animate( this, keypath, to, options );\n\n\tpromise.stop = () => animation.stop();\n\treturn promise;\n}\n\nfunction animate ( root, keypath, to, options ) {\n\tvar easing, duration, animation, from;\n\n\tif ( keypath ) {\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\t}\n\n\tif ( keypath !== null ) {\n\t\tfrom = root.viewmodel.get( keypath );\n\t}\n\n\t// cancel any existing animation\n\t// TODO what about upstream/downstream keypaths?\n\tanimations.abort( keypath, root );\n\n\t// don't bother animating values that stay the same\n\tif ( isEqual( from, to ) ) {\n\t\tif ( options.complete ) {\n\t\t\toptions.complete( options.to );\n\t\t}\n\n\t\treturn noAnimation;\n\t}\n\n\t// easing function\n\tif ( options.easing ) {\n\t\tif ( typeof options.easing === 'function' ) {\n\t\t\teasing = options.easing;\n\t\t}\n\n\t\telse {\n\t\t\teasing = root.easing[ options.easing ];\n\t\t}\n\n\t\tif ( typeof easing !== 'function' ) {\n\t\t\teasing = null;\n\t\t}\n\t}\n\n\t// duration\n\tduration = ( options.duration === undefined ? 400 : options.duration );\n\n\t// TODO store keys, use an internal set method\n\tanimation = new Animation({\n\t\tkeypath,\n\t\tfrom,\n\t\tto,\n\t\troot,\n\t\tduration,\n\t\teasing,\n\t\tinterpolator: options.interpolator,\n\n\t\t// TODO wrap callbacks if necessary, to use instance as context\n\t\tstep: options.step,\n\t\tcomplete: options.complete\n\t});\n\n\tanimations.add( animation );\n\troot._animations.push( animation );\n\n\treturn animation;\n}\n","import { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport interpolate from 'shared/interpolate';\n\nvar Animation = function ( options ) {\n\tvar key;\n\n\tthis.startTime = Date.now();\n\n\t// from and to\n\tfor ( key in options ) {\n\t\tif ( options.hasOwnProperty( key ) ) {\n\t\t\tthis[ key ] = options[ key ];\n\t\t}\n\t}\n\n\tthis.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );\n\tthis.running = true;\n\n\tthis.tick();\n};\n\nAnimation.prototype = {\n\ttick: function () {\n\t\tvar elapsed, t, value, timeNow, index, keypath;\n\n\t\tkeypath = this.keypath;\n\n\t\tif ( this.running ) {\n\t\t\ttimeNow = Date.now();\n\t\t\telapsed = timeNow - this.startTime;\n\n\t\t\tif ( elapsed >= this.duration ) {\n\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\tthis.root.viewmodel.set( keypath, this.to );\n\t\t\t\t\trunloop.end();\n\t\t\t\t}\n\n\t\t\t\tif ( this.step ) {\n\t\t\t\t\tthis.step( 1, this.to );\n\t\t\t\t}\n\n\t\t\t\tthis.complete( this.to );\n\n\t\t\t\tindex = this.root._animations.indexOf( this );\n\n\t\t\t\t// TODO investigate why this happens\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\twarnIfDebug( 'Animation was not found' );\n\t\t\t\t}\n\n\t\t\t\tthis.root._animations.splice( index, 1 );\n\n\t\t\t\tthis.running = false;\n\t\t\t\treturn false; // remove from the stack\n\t\t\t}\n\n\t\t\tt = this.easing ? this.easing ( elapsed / this.duration ) : ( elapsed / this.duration );\n\n\t\t\tif ( keypath !== null ) {\n\t\t\t\tvalue = this.interpolator( t );\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\trunloop.end();\n\t\t\t}\n\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( t, value );\n\t\t\t}\n\n\t\t\treturn true; // keep in the stack\n\t\t}\n\n\t\treturn false; // remove from the stack\n\t},\n\n\tstop: function () {\n\t\tvar index;\n\n\t\tthis.running = false;\n\n\t\tindex = this.root._animations.indexOf( this );\n\n\t\t// TODO investigate why this happens\n\t\tif ( index === -1 ) {\n\t\t\twarnIfDebug( 'Animation was not found' );\n\t\t}\n\n\t\tthis.root._animations.splice( index, 1 );\n\t}\n};\n\nexport default Animation;\n","import rAF from 'utils/requestAnimationFrame';\nimport getTime from 'utils/getTime';\nimport runloop from 'global/runloop';\n\nvar queue = [];\n\nvar animations = {\n\ttick: function () {\n\t\tvar i, animation, now;\n\n\t\tnow = getTime();\n\n\t\trunloop.start();\n\n\t\tfor ( i=0; i<queue.length; i+=1 ) {\n\t\t\tanimation = queue[i];\n\n\t\t\tif ( !animation.tick( now ) ) {\n\t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n\t\t\t\tqueue.splice( i--, 1 );\n\t\t\t}\n\t\t}\n\n\t\trunloop.end();\n\n\t\tif ( queue.length ) {\n\t\t\trAF( animations.tick );\n\t\t} else {\n\t\t\tanimations.running = false;\n\t\t}\n\t},\n\n\tadd: function ( animation ) {\n\t\tqueue.push( animation );\n\n\t\tif ( !animations.running ) {\n\t\t\tanimations.running = true;\n\t\t\trAF( animations.tick );\n\t\t}\n\t},\n\n\t// TODO optimise this\n\tabort: function ( keypath, root ) {\n\t\tvar i = queue.length, animation;\n\n\t\twhile ( i-- ) {\n\t\t\tanimation = queue[i];\n\n\t\t\tif ( animation.root === root && animation.keypath === keypath ) {\n\t\t\t\tanimation.stop();\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport default animations;\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { addToArray, removeFromArray } from 'utils/array';\nimport Promise from 'utils/Promise';\nimport resolveRef from 'shared/resolveRef';\nimport TransitionManager from './TransitionManager';\n\nvar batch, runloop, unresolved = [], changeHook = new Hook( 'change' );\n\nrunloop = {\n\tstart: function ( instance, returnPromise ) {\n\t\tvar promise, fulfilPromise;\n\n\t\tif ( returnPromise ) {\n\t\t\tpromise = new Promise( f => ( fulfilPromise = f ) );\n\t\t}\n\n\t\tbatch = {\n\t\t\tpreviousBatch: batch,\n\t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t\t\tviews: [],\n\t\t\ttasks: [],\n\t\t\tractives: [],\n\t\t\tinstance: instance\n\t\t};\n\n\t\tif ( instance ) {\n\t\t\tbatch.ractives.push( instance );\n\t\t}\n\n\t\treturn promise;\n\t},\n\n\tend: function () {\n\t\tflushChanges();\n\n\t\tbatch.transitionManager.init();\n\t\tif ( !batch.previousBatch && !!batch.instance ) batch.instance.viewmodel.changes = [];\n\t\tbatch = batch.previousBatch;\n\t},\n\n\taddRactive: function ( ractive ) {\n\t\tif ( batch ) {\n\t\t\taddToArray( batch.ractives, ractive );\n\t\t}\n\t},\n\n\tregisterTransition: function ( transition ) {\n\t\ttransition._manager = batch.transitionManager;\n\t\tbatch.transitionManager.add( transition );\n\t},\n\n\tregisterDecorator: function ( decorator ) {\n\t\tbatch.transitionManager.addDecorator( decorator );\n\t},\n\n\taddView: function ( view ) {\n\t\tbatch.views.push( view );\n\t},\n\n\taddUnresolved: function ( thing ) {\n\t\tunresolved.push( thing );\n\t},\n\n\tremoveUnresolved: function ( thing ) {\n\t\tremoveFromArray( unresolved, thing );\n\t},\n\n\t// synchronise node detachments with transition ends\n\tdetachWhenReady: function ( thing ) {\n\t\tbatch.transitionManager.detachQueue.push( thing );\n\t},\n\n\tscheduleTask: function ( task, postRender ) {\n\t\tvar _batch;\n\n\t\tif ( !batch ) {\n\t\t\ttask();\n\t\t} else {\n\t\t\t_batch = batch;\n\t\t\twhile ( postRender && _batch.previousBatch ) {\n\t\t\t\t// this can't happen until the DOM has been fully updated\n\t\t\t\t// otherwise in some situations (with components inside elements)\n\t\t\t\t// transitions and decorators will initialise prematurely\n\t\t\t\t_batch = _batch.previousBatch;\n\t\t\t}\n\n\t\t\t_batch.tasks.push( task );\n\t\t}\n\t}\n};\n\nexport default runloop;\n\nfunction flushChanges () {\n\tvar i, thing, changeHash;\n\n\twhile ( batch.ractives.length ) {\n\t\tthing = batch.ractives.pop();\n\t\tchangeHash = thing.viewmodel.applyChanges();\n\n\t\tif ( changeHash ) {\n\t\t\tchangeHook.fire( thing, changeHash );\n\t\t}\n\t}\n\n\tattemptKeypathResolution();\n\n\t// Now that changes have been fully propagated, we can update the DOM\n\t// and complete other tasks\n\tfor ( i = 0; i < batch.views.length; i += 1 ) {\n\t\tbatch.views[i].update();\n\t}\n\tbatch.views.length = 0;\n\n\tfor ( i = 0; i < batch.tasks.length; i += 1 ) {\n\t\tbatch.tasks[i]();\n\t}\n\tbatch.tasks.length = 0;\n\n\t// If updating the view caused some model blowback - e.g. a triple\n\t// containing <option> elements caused the binding on the <select>\n\t// to update - then we start over\n\tif ( batch.ractives.length ) return flushChanges();\n}\n\nfunction attemptKeypathResolution () {\n\tvar i, item, keypath, resolved;\n\n\ti = unresolved.length;\n\n\t// see if we can resolve any unresolved references\n\twhile ( i-- ) {\n\t\titem = unresolved[i];\n\n\t\tif ( item.keypath ) {\n\t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n\t\t\t// weird that we'd still end up here\n\t\t\tunresolved.splice( i, 1 );\n\t\t\tcontinue; // avoid removing the wrong thing should the next condition be true\n\t\t}\n\n\t\tif ( keypath = resolveRef( item.root, item.ref, item.parentFragment ) ) {\n\t\t\t( resolved || ( resolved = [] ) ).push({\n\t\t\t\titem: item,\n\t\t\t\tkeypath: keypath\n\t\t\t});\n\n\t\t\tunresolved.splice( i, 1 );\n\t\t}\n\t}\n\n\tif ( resolved ) {\n\t\tresolved.forEach( resolve );\n\t}\n}\n\nfunction resolve ( resolved ) {\n\tresolved.item.resolve( resolved.keypath );\n}\n","import { removeFromArray } from 'utils/array';\nimport { teardown } from 'shared/methodCallers';\n\nvar TransitionManager = function ( callback, parent ) {\n\tthis.callback = callback;\n\tthis.parent = parent;\n\n\tthis.intros = [];\n\tthis.outros = [];\n\n\tthis.children = [];\n\tthis.totalChildren = this.outroChildren = 0;\n\n\tthis.detachQueue = [];\n\tthis.decoratorQueue = [];\n\tthis.outrosComplete = false;\n\n\tif ( parent ) {\n\t\tparent.addChild( this );\n\t}\n};\n\nTransitionManager.prototype = {\n\taddChild: function ( child ) {\n\t\tthis.children.push( child );\n\n\t\tthis.totalChildren += 1;\n\t\tthis.outroChildren += 1;\n\t},\n\n\tdecrementOutros: function () {\n\t\tthis.outroChildren -= 1;\n\t\tcheck( this );\n\t},\n\n\tdecrementTotal: function () {\n\t\tthis.totalChildren -= 1;\n\t\tcheck( this );\n\t},\n\n\tadd: function ( transition ) {\n\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\tlist.push( transition );\n\t},\n\n\taddDecorator: function ( decorator ) {\n\t\tthis.decoratorQueue.push( decorator );\n\t},\n\n\tremove: function ( transition ) {\n\t\tvar list = transition.isIntro ? this.intros : this.outros;\n\t\tremoveFromArray( list, transition );\n\t\tcheck( this );\n\t},\n\n\tinit: function () {\n\t\tthis.ready = true;\n\t\tcheck( this );\n\t},\n\n\tdetachNodes: function () {\n\t\tthis.decoratorQueue.forEach( teardown );\n\t\tthis.detachQueue.forEach( detach );\n\t\tthis.children.forEach( detachNodes );\n\t}\n};\n\nfunction detach ( element ) {\n\telement.detach();\n}\n\nfunction detachNodes ( tm ) {\n\ttm.detachNodes();\n}\n\nfunction check ( tm ) {\n\tif ( !tm.ready || tm.outros.length || tm.outroChildren ) return;\n\n\t// If all outros are complete, and we haven't already done this,\n\t// we notify the parent if there is one, otherwise\n\t// start detaching nodes\n\tif ( !tm.outrosComplete ) {\n\t\tif ( tm.parent ) {\n\t\t\ttm.parent.decrementOutros( tm );\n\t\t} else {\n\t\t\ttm.detachNodes();\n\t\t}\n\n\t\ttm.outrosComplete = true;\n\t}\n\n\t// Once everything is done, we can notify parent transition\n\t// manager and call the callback\n\tif ( !tm.intros.length && !tm.totalChildren ) {\n\t\tif ( typeof tm.callback === 'function' ) {\n\t\t\ttm.callback();\n\t\t}\n\n\t\tif ( tm.parent ) {\n\t\t\ttm.parent.decrementTotal();\n\t\t}\n\t}\n}\n\nexport default TransitionManager;\n","export function teardown ( x ) { x.teardown(); }\nexport function unbind   ( x ) { x.unbind(); }\nexport function unrender ( x ) { x.unrender(); }\nexport function cancel   ( x ) { x.cancel(); }","import { getKeypath, normalise } from 'shared/keypaths';\nimport getInnerContext from 'shared/getInnerContext';\n\nexport default function resolveRef ( ractive, ref, fragment ) {\n\tvar keypath;\n\n\tref = normalise( ref );\n\n\t// If a reference begins '~/', it's a top-level reference\n\tif ( ref.substr( 0, 2 ) === '~/' ) {\n\t\tkeypath = getKeypath( ref.substring( 2 ) );\n\t\tcreateMappingIfNecessary( ractive, keypath.firstKey, fragment );\n\t}\n\n\t// If a reference begins with '.', it's either a restricted reference or\n\t// an ancestor reference...\n\telse if ( ref[0] === '.' ) {\n\t\tkeypath = resolveAncestorRef( getInnerContext( fragment ), ref );\n\n\t\tif ( keypath ) {\n\t\t\tcreateMappingIfNecessary( ractive, keypath.firstKey, fragment );\n\t\t}\n\t}\n\n\t// ...otherwise we need to figure out the keypath based on context\n\telse {\n\t\tkeypath = resolveAmbiguousReference( ractive, getKeypath( ref ), fragment );\n\t}\n\n\treturn keypath;\n}\n\nfunction resolveAncestorRef ( baseContext, ref ) {\n\tvar contextKeys;\n\n\t// TODO...\n\tif ( baseContext != undefined && typeof baseContext !== 'string' ) {\n\t\tbaseContext = baseContext.str;\n\t}\n\n\t// {{.}} means 'current context'\n\tif ( ref === '.' ) return getKeypath( baseContext );\n\n\tcontextKeys = baseContext ? baseContext.split( '.' ) : [];\n\n\t// ancestor references (starting \"../\") go up the tree\n\tif ( ref.substr( 0, 3 ) === '../' ) {\n\t\twhile ( ref.substr( 0, 3 ) === '../' ) {\n\t\t\tif ( !contextKeys.length ) {\n\t\t\t\tthrow new Error( 'Could not resolve reference - too many \"../\" prefixes' );\n\t\t\t}\n\n\t\t\tcontextKeys.pop();\n\t\t\tref = ref.substring( 3 );\n\t\t}\n\n\t\tcontextKeys.push( ref );\n\t\treturn getKeypath( contextKeys.join( '.' ) );\n\t}\n\n\t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n\tif ( !baseContext ) {\n\t\treturn getKeypath( ref.replace( /^\\.\\/?/, '' ) );\n\t}\n\n\treturn getKeypath( baseContext + ref.replace( /^\\.\\//, '.' ) );\n}\n\nfunction resolveAmbiguousReference ( ractive, ref, fragment, isParentLookup ) {\n\tvar context,\n\t\tkey,\n\t\tparentValue,\n\t\thasContextChain,\n\t\tparentKeypath;\n\n\tif ( ref.isRoot ) {\n\t\treturn ref;\n\t}\n\n\tkey = ref.firstKey;\n\n\twhile ( fragment ) {\n\t\tcontext = fragment.context;\n\t\tfragment = fragment.parent;\n\n\t\tif ( !context ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\thasContextChain = true;\n\t\tparentValue = ractive.viewmodel.get( context );\n\n\t\tif ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {\n\t\t\treturn context.join( ref.str );\n\t\t}\n\t}\n\n\t// Root/computed/mapped property?\n\tif ( isRootProperty( ractive.viewmodel, key ) ) {\n\t\treturn ref;\n\t}\n\n\t// If this is an inline component, and it's not isolated, we\n\t// can try going up the scope chain\n\tif ( ractive.parent && !ractive.isolated ) {\n\t\thasContextChain = true;\n\t\tfragment = ractive.component.parentFragment;\n\n\t\tkey = getKeypath( key );\n\n\t\tif ( parentKeypath = resolveAmbiguousReference( ractive.parent, key, fragment, true ) ) {\n\t\t\t// We need to create an inter-component binding\n\t\t\tractive.viewmodel.map( key, {\n\t\t\t\torigin: ractive.parent.viewmodel,\n\t\t\t\tkeypath: parentKeypath\n\t\t\t});\n\n\t\t\treturn ref;\n\t\t}\n\t}\n\n\t// If there's no context chain, and the instance is either a) isolated or\n\t// b) an orphan, then we know that the keypath is identical to the reference\n\tif ( !isParentLookup && !hasContextChain ) {\n\t\t// the data object needs to have a property by this name,\n\t\t// to prevent future failed lookups\n\t\tractive.viewmodel.set( ref, undefined );\n\t\treturn ref;\n\t}\n}\n\nfunction createMappingIfNecessary ( ractive, key ) {\n\tvar parentKeypath;\n\n\tif ( !ractive.parent || ractive.isolated || isRootProperty( ractive.viewmodel, key ) ) {\n\t\treturn;\n\t}\n\n\tkey = getKeypath( key );\n\n\tif ( parentKeypath = resolveAmbiguousReference( ractive.parent, key, ractive.component.parentFragment, true ) ) {\n\t\tractive.viewmodel.map( key, {\n\t\t\torigin: ractive.parent.viewmodel,\n\t\t\tkeypath: parentKeypath\n\t\t});\n\t}\n}\n\nfunction isRootProperty ( viewmodel, key ) {\n\t// special case for reference to root\n\treturn key === '' || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n}\n","import { rootKeypath } from 'shared/keypaths';\n\nexport default function ( fragment ) {\n\tdo {\n\t\tif ( fragment.context !== undefined ) {\n\t\t\treturn fragment.context;\n\t\t}\n\t} while ( fragment = fragment.parent );\n\n\treturn rootKeypath;\n}\n","var _Promise,\n\tPENDING = {},\n\tFULFILLED = {},\n\tREJECTED = {};\n\nif ( typeof Promise === 'function' ) {\n\t// use native Promise\n\t_Promise = Promise;\n} else {\n\t_Promise = function ( callback ) {\n\t\tvar fulfilledHandlers = [],\n\t\t\trejectedHandlers = [],\n\t\t\tstate = PENDING,\n\n\t\t\tresult,\n\t\t\tdispatchHandlers,\n\t\t\tmakeResolver,\n\t\t\tfulfil,\n\t\t\treject,\n\n\t\t\tpromise;\n\n\t\tmakeResolver = function ( newState ) {\n\t\t\treturn function ( value ) {\n\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult = value;\n\t\t\t\tstate = newState;\n\n\t\t\t\tdispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );\n\n\t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t\t\t\twait( dispatchHandlers );\n\t\t\t};\n\t\t};\n\n\t\tfulfil = makeResolver( FULFILLED );\n\t\treject = makeResolver( REJECTED );\n\n\t\ttry {\n\t\t\tcallback( fulfil, reject );\n\t\t} catch ( err ) {\n\t\t\treject( err );\n\t\t}\n\n\t\tpromise = {\n\t\t\t// `then()` returns a Promise - 2.2.7\n\t\t\tthen: function ( onFulfilled, onRejected ) {\n\t\t\t\tvar promise2 = new _Promise( function ( fulfil, reject ) {\n\n\t\t\t\t\tvar processResolutionHandler = function ( handler, handlers, forward ) {\n\n\t\t\t\t\t\t// 2.2.1.1\n\t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t\t\t\t\t\t\thandlers.push( function ( p1result ) {\n\t\t\t\t\t\t\t\tvar x;\n\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t\t\t\t\t\t\t\t} catch ( err ) {\n\t\t\t\t\t\t\t\t\treject( err );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t\t\t\t\t\t\t// are not given\n\t\t\t\t\t\t\thandlers.push( forward );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// 2.2\n\t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\n\t\t\t\t\tif ( state !== PENDING ) {\n\t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t\t\t\t\t\twait( dispatchHandlers );\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\treturn promise2;\n\t\t\t}\n\t\t};\n\n\t\tpromise[ 'catch' ] = function ( onRejected ) {\n\t\t\treturn this.then( null, onRejected );\n\t\t};\n\n\t\treturn promise;\n\t};\n\n\t_Promise.all = function ( promises ) {\n\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\tvar result = [], pending, i, processPromise;\n\n\t\t\tif ( !promises.length ) {\n\t\t\t\tfulfil( result );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocessPromise = ( promise, i ) => {\n\t\t\t\tif ( promise && typeof promise.then === 'function' ) {\n\t\t\t\t\tpromise.then( value => {\n\t\t\t\t\t\tresult[i] = value;\n\t\t\t\t\t\t--pending || fulfil( result );\n\t\t\t\t\t}, reject );\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresult[i] = promise;\n\t\t\t\t\t--pending || fulfil( result );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tpending = i = promises.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprocessPromise( promises[i], i );\n\t\t\t}\n\t\t});\n\t};\n\n\t_Promise.resolve = function ( value ) {\n\t\treturn new _Promise( function ( fulfil ) {\n\t\t\tfulfil( value );\n\t\t});\n\t};\n\n\t_Promise.reject = function ( reason ) {\n\t\treturn new _Promise( function ( fulfil, reject ) {\n\t\t\treject( reason );\n\t\t});\n\t};\n}\n\nexport default _Promise;\n\n// TODO use MutationObservers or something to simulate setImmediate\nfunction wait ( callback ) {\n\tsetTimeout( callback, 0 );\n}\n\nfunction makeDispatcher ( handlers, result ) {\n\treturn function () {\n\t\tvar handler;\n\n\t\twhile ( handler = handlers.shift() ) {\n\t\t\thandler( result );\n\t\t}\n\t};\n}\n\nfunction resolve ( promise, x, fulfil, reject ) {\n\t// Promise Resolution Procedure\n\tvar then;\n\n\t// 2.3.1\n\tif ( x === promise ) {\n\t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t}\n\n\t// 2.3.2\n\tif ( x instanceof _Promise ) {\n\t\tx.then( fulfil, reject );\n\t}\n\n\t// 2.3.3\n\telse if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t\ttry {\n\t\t\tthen = x.then; // 2.3.3.1\n\t\t} catch ( e ) {\n\t\t\treject( e ); // 2.3.3.2\n\t\t\treturn;\n\t\t}\n\n\t\t// 2.3.3.3\n\t\tif ( typeof then === 'function' ) {\n\t\t\tvar called, resolvePromise, rejectPromise;\n\n\t\t\tresolvePromise = function ( y ) {\n\t\t\t\tif ( called ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\tresolve( promise, y, fulfil, reject );\n\t\t\t};\n\n\t\t\trejectPromise = function ( r ) {\n\t\t\t\tif ( called ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\treject( r );\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t\t\t} catch ( e ) {\n\t\t\t\tif ( !called ) { // 2.3.3.3.4.1\n\t\t\t\t\treject( e ); // 2.3.3.3.4.2\n\t\t\t\t\tcalled = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tfulfil( x );\n\t\t}\n\t}\n\n\telse {\n\t\tfulfil( x );\n\t}\n}\n","import { isArray } from 'utils/is';\n\nexport function addToArray ( array, value ) {\n\tvar index = array.indexOf( value );\n\n\tif ( index === -1 ) {\n\t\tarray.push( value );\n\t}\n}\n\nexport function arrayContains ( array, value ) {\n\tfor ( let i = 0, c = array.length; i < c; i++ ) {\n\t\tif ( array[i] == value ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n    return false;\n}\n\nexport function arrayContentsMatch ( a, b ) {\n\tvar i;\n\n\tif ( !isArray( a ) || !isArray( b ) ) {\n\t\treturn false;\n\t}\n\n\tif ( a.length !== b.length ) {\n\t\treturn false;\n\t}\n\n\ti = a.length;\n\twhile ( i-- ) {\n\t\tif ( a[i] !== b[i] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function ensureArray ( x ) {\n\tif ( typeof x === 'string' ) {\n\t\treturn [ x ];\n\t}\n\n\tif ( x === undefined ) {\n\t\treturn [];\n\t}\n\n\treturn x;\n}\n\nexport function lastItem ( array ) {\n\treturn array[ array.length - 1 ];\n}\n\nexport function removeFromArray ( array, member ) {\n\tvar index = array.indexOf( member );\n\n\tif ( index !== -1 ) {\n\t\tarray.splice( index, 1 );\n\t}\n}\n\nexport function toArray ( arrayLike ) {\n\tvar array = [], i = arrayLike.length;\n\twhile ( i-- ) {\n\t\tarray[i] = arrayLike[i];\n\t}\n\n\treturn array;\n}\n","import { warnIfDebug } from 'utils/log';\n\n// TODO: deprecate in future release\nvar deprecations = {\n\tconstruct: {\n\t\tdeprecated: 'beforeInit',\n\t\treplacement: 'onconstruct'\n\t},\n\trender: {\n\t\tdeprecated: 'init',\n\t\tmessage: 'The \"init\" method has been deprecated ' +\n\t\t\t'and will likely be removed in a future release. ' +\n\t\t\t'You can either use the \"oninit\" method which will fire ' +\n\t\t\t'only once prior to, and regardless of, any eventual ractive ' +\n\t\t\t'instance being rendered, or if you need to access the ' +\n\t\t\t'rendered DOM, use \"onrender\" instead. ' +\n\t\t\t'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t},\n\tcomplete: {\n\t\tdeprecated: 'complete',\n\t\treplacement: 'oncomplete'\n\t}\n};\n\nfunction Hook ( event ) {\n\tthis.event = event;\n\tthis.method = 'on' + event;\n\tthis.deprecate = deprecations[ event ];\n}\n\nHook.prototype.fire = function ( ractive, arg ) {\n\tfunction call ( method ) {\n\t\tif ( ractive[ method ] ) {\n\t\t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t\t\treturn true;\n\t\t}\n\t}\n\n\