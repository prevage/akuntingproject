{"version":3,"file":"ractive.min.js","sources":["../src/virtualdom/items/Comment.js","../src/virtualdom/items/Yielder.js","../src/virtualdom/items/Doctype.js","../src/virtualdom/Fragment/prototype/render.js","../src/virtualdom/Fragment/prototype/toString.js","../src/virtualdom/Fragment/prototype/unbind.js","../src/virtualdom/Fragment/prototype/unrender.js","../src/virtualdom/Fragment.js","../src/Ractive.js","../src/Ractive/prototype/reset.js","../src/Ractive/prototype/resetPartial.js","../src/Ractive/prototype/reverse.js","../src/Ractive/prototype/shift.js","../src/Ractive/prototype/sort.js","../src/Ractive/prototype/splice.js","../src/Ractive/prototype/teardown.js","../src/Ractive/prototype/toHTML.js","../src/Ractive/prototype/unrender.js","../src/Ractive/prototype/unshift.js","../src/Ractive/prototype/update.js","../src/Ractive/prototype.js","../src/utils/wrapMethod.js","../src/extend/_extend.js","../src/Ractive/static/getNodeInfo.js","../src/virtualdom/items/Element/Attribute/prototype/render.js","../src/virtualdom/items/Element/Attribute/prototype/toString.js","../src/virtualdom/items/Element/Attribute/prototype/unbind.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js","../src/virtualdom/items/Element/Attribute/_Attribute.js","../src/virtualdom/items/Element/ConditionalAttribute/_ConditionalAttribute.js","../src/virtualdom/items/Element/prototype/init/createAttributes.js","../src/virtualdom/items/Element/prototype/init/createConditionalAttributes.js","../src/virtualdom/items/Element/Binding/Binding.js","../src/virtualdom/items/Element/Binding/GenericBinding.js","../src/virtualdom/items/Element/Binding/ContentEditableBinding.js","../src/virtualdom/items/Element/Binding/shared/getSiblings.js","../src/virtualdom/items/Element/Binding/RadioBinding.js","../src/virtualdom/items/Element/Binding/RadioNameBinding.js","../src/virtualdom/items/Element/Binding/CheckboxNameBinding.js","../src/virtualdom/items/Element/Binding/CheckboxBinding.js","../src/virtualdom/items/Element/Binding/SelectBinding.js","../src/virtualdom/items/Element/Binding/MultipleSelectBinding.js","../src/virtualdom/items/Element/Binding/FileListBinding.js","../src/virtualdom/items/Element/Binding/NumericBinding.js","../src/virtualdom/items/Element/EventHandler/prototype/bubble.js","../src/virtualdom/items/Element/EventHandler/prototype/getAction.js","../src/virtualdom/items/Element/EventHandler/prototype/init.js","../src/virtualdom/items/Element/EventHandler/prototype/listen.js","../src/virtualdom/items/Element/EventHandler/prototype/rebind.js","../src/virtualdom/items/Element/EventHandler/prototype/render.js","../src/virtualdom/items/Element/EventHandler/prototype/resolve.js","../src/virtualdom/items/Element/EventHandler/_EventHandler.js","../src/virtualdom/items/Element/prototype/init/createEventHandlers.js","../src/virtualdom/items/Element/Decorator/_Decorator.js","../src/virtualdom/items/Element/Transition/helpers/prefix.js","../src/utils/camelCase.js","../src/virtualdom/items/Element/Transition/prototype/getStyle.js","../src/virtualdom/items/Element/Transition/prototype/setStyle.js","../src/shared/Ticker.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js","../src/virtualdom/items/Element/Transition/helpers/unprefix.js","../src/virtualdom/items/Element/Transition/helpers/hyphenate.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js","../src/virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js","../src/virtualdom/items/Element/Transition/prototype/processParams.js","../src/virtualdom/items/Element/Transition/prototype/start.js","../src/virtualdom/items/Element/Transition/_Transition.js","../src/virtualdom/items/Element/prototype/render.js","../src/virtualdom/items/Element/prototype/toString.js","../src/virtualdom/items/Element/_Element.js","../src/virtualdom/items/Partial/deIndent.js","../src/virtualdom/items/Partial/applyIndent.js","../src/virtualdom/items/Partial/_Partial.js","../src/Ractive/static/adaptors/array/patch.js","../src/virtualdom/items/Component/prototype/detach.js","../src/virtualdom/items/Component/prototype/find.js","../src/virtualdom/items/Component/prototype/findAll.js","../src/virtualdom/items/Component/prototype/findAllComponents.js","../src/virtualdom/items/Component/prototype/findComponent.js","../src/virtualdom/items/Component/prototype/findNextNode.js","../src/virtualdom/items/Component/prototype/firstNode.js","../src/Ractive/static/adaptors/array/processWrapper.js","../src/Ractive/static/adaptors/array/index.js","../src/Ractive/static/adaptors/magic.js","../src/utils/createBranch.js","../src/Ractive/static/adaptors/magicArray.js","../src/viewmodel/prototype/adapt.js","../src/viewmodel/prototype/applyChanges/notifyPatternObservers.js","../src/viewmodel/prototype/capture.js","../src/viewmodel/prototype/clearCache.js","../src/viewmodel/Computation/UnresolvedDependency.js","../src/viewmodel/Computation/Computation.js","../src/viewmodel/prototype/get.js","../src/viewmodel/prototype/init.js","../src/viewmodel/prototype/map.js","../src/viewmodel/prototype/mark.js","../src/viewmodel/prototype/merge/mapOldToNewIndex.js","../src/viewmodel/prototype/merge.js","../src/viewmodel/prototype/register.js","../src/viewmodel/prototype/release.js","../src/viewmodel/prototype/reset.js","../src/viewmodel/prototype/smartUpdate.js","../src/viewmodel/prototype/teardown.js","../src/viewmodel/Viewmodel.js","../src/Ractive/prototype/shared/hooks/HookQueue.js","../src/Ractive/helpers/getComputationSignatures.js","../src/Ractive/initialise.js","../src/virtualdom/items/Component/initialise/ComplexParameter.js","../src/virtualdom/items/Component/initialise/createInstance.js","../src/virtualdom/items/Component/initialise/updateLiveQueries.js","../src/virtualdom/items/Component/prototype/rebind.js","../src/virtualdom/items/Component/prototype/render.js","../src/virtualdom/items/Component/prototype/toString.js","../src/virtualdom/items/Component/prototype/unbind.js","../src/virtualdom/items/Component/prototype/unrender.js","../src/virtualdom/items/Component/_Component.js","../src/Ractive/prototype/animate/Animation.js","../src/Ractive/prototype/animate.js","../src/Ractive/prototype/detach.js","../src/Ractive/prototype/find.js","../src/Ractive/prototype/shared/makeQuery/cancel.js","../src/Ractive/prototype/shared/makeQuery/sortByItemPosition.js","../src/Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js","../src/Ractive/prototype/shared/makeQuery/sort.js","../src/Ractive/prototype/shared/makeQuery/dirty.js","../src/Ractive/prototype/shared/makeQuery/remove.js","../src/Ractive/prototype/findComponent.js","../src/Ractive/prototype/findParent.js","../src/Ractive/prototype/shared/eventStack.js","../src/Ractive/prototype/get.js","../src/Ractive/prototype/insert.js","../src/Ractive/prototype/observe/Observer.js","../src/Ractive/prototype/observe/PatternObserver.js","../src/global/css.js","../src/Ractive/prototype/observe/getObserverFacade.js","../src/Ractive/prototype/observeOnce.js","../src/Ractive/prototype/shared/trim.js","../src/Ractive/prototype/shared/notEmptyString.js","../src/Ractive/prototype/once.js","../src/Ractive/prototype/shared/makeArrayMethod.js","../src/Ractive/prototype/pop.js","../src/Ractive/prototype/push.js","../src/parse/Parser.js","../src/Ractive/prototype/render.js","../src/Ractive/config/custom/adapt.js","../src/Ractive/config/custom/css/transform.js","../src/Ractive/config/custom/css/css.js","../src/Ractive/config/custom/data.js","../src/parse/converters/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js","../src/config/types.js","../src/parse/converters/mustache/readDelimiterChange.js","../src/parse/converters/expressions/primary/literal/readRegexpLiteral.js","../src/parse/converters/readMustache.js","../src/parse/converters/expressions/shared/errors.js","../src/parse/converters/expressions/primary/literal/readNumberLiteral.js","../src/parse/converters/expressions/primary/readReference.js","../src/parse/converters/expressions/primary/literal/readStringLiteral.js","../src/parse/converters/expressions/shared/patterns.js","../src/parse/converters/expressions/shared/readKey.js","../src/parse/converters/expressions/primary/literal/readObjectLiteral.js","../src/parse/converters/expressions/primary/literal/readArrayLiteral.js","../src/parse/converters/expressions/readTypeof.js","../src/parse/converters/expressions/readPrimary.js","../src/parse/converters/expressions/readMemberOrInvocation.js","../src/parse/converters/expressions/readLogicalOr.js","../src/utils/html.js","../src/parse/utils/refineExpression.js","../src/parse/converters/mustache/readTriple.js","../src/parse/converters/mustache/readYielder.js","../src/parse/converters/mustache/section/readElse.js","../src/parse/converters/mustache/section/readElseIf.js","../src/parse/converters/mustache/handlebarsBlockCodes.js","../src/parse/converters/mustache/readSection.js","../src/parse/converters/readHtmlComment.js","../src/parse/utils/stripStandalones.js","../src/utils/parseJSON.js","../src/parse/utils/trimWhitespace.js","../src/parse/utils/cleanup.js","../src/parse/converters/element/readClosingTag.js","../src/parse/converters/utils/getLowestIndex.js","../src/parse/converters/element/readAttribute.js","../src/parse/converters/element/processDirective.js","../src/parse/converters/readElement.js","../src/parse/converters/readPartialDefinitionComment.js","../src/utils/escapeRegExp.js","../src/parse/converters/readPartialDefinitionSection.js","../src/parse/_parse.js","../src/Ractive/config/custom/template/parser.js","../src/Ractive/config/registries.js","../src/Ractive/config/custom/template/template.js","../src/Ractive/config/config.js","../src/virtualdom/Fragment/prototype/bubble.js","../src/virtualdom/Fragment/prototype/detach.js","../src/virtualdom/Fragment/prototype/find.js","../src/virtualdom/Fragment/prototype/findAll.js","../src/virtualdom/Fragment/prototype/findAllComponents.js","../src/virtualdom/Fragment/prototype/findComponent.js","../src/virtualdom/Fragment/prototype/findNextNode.js","../src/virtualdom/Fragment/prototype/firstNode.js","../src/virtualdom/Fragment/prototype/shared/processItems.js","../src/virtualdom/Fragment/prototype/getNode.js","../src/virtualdom/items/shared/detach.js","../src/virtualdom/items/Text.js","../src/virtualdom/items/shared/Mustache/getValue.js","../src/virtualdom/items/shared/Resolvers/ReferenceResolver.js","../src/virtualdom/items/shared/Resolvers/SpecialResolver.js","../src/virtualdom/items/shared/Resolvers/IndexResolver.js","../src/virtualdom/items/shared/Resolvers/findIndexRefs.js","../src/virtualdom/items/shared/Resolvers/ExpressionResolver.js","../src/shared/getFunctionFromString.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js","../src/virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js","../src/virtualdom/items/shared/Mustache/resolve.js","../src/virtualdom/items/shared/Mustache/rebind.js","../src/virtualdom/items/shared/Mustache/_Mustache.js","../src/virtualdom/items/Interpolator.js","../src/virtualdom/items/Section/prototype/bubble.js","../src/virtualdom/items/Section/prototype/detach.js","../src/virtualdom/items/Section/prototype/find.js","../src/virtualdom/items/Section/prototype/findAll.js","../src/virtualdom/items/Section/prototype/findComponent.js","../src/virtualdom/items/Section/prototype/findNextNode.js","../src/virtualdom/items/Section/prototype/firstNode.js","../src/virtualdom/items/Section/prototype/rebind.js","../src/virtualdom/items/Section/prototype/render.js","../src/virtualdom/items/Section/prototype/toString.js","../src/virtualdom/items/Section/prototype/unrender.js","../src/virtualdom/items/Section/prototype/update.js","../src/virtualdom/items/Section/_Section.js","../src/virtualdom/items/Triple/helpers/insertHtml.js","../src/virtualdom/items/Triple/prototype/detach.js","../src/virtualdom/items/Triple/prototype/firstNode.js","../src/virtualdom/items/Triple/_Triple.js","../src/virtualdom/items/Element/shared/enforceCase.js","../src/virtualdom/items/Element/prototype/bubble.js","../src/virtualdom/items/Element/prototype/detach.js","../src/virtualdom/items/Element/prototype/find.js","../src/virtualdom/items/Element/prototype/findAll.js","../src/virtualdom/items/Element/prototype/findAllComponents.js","../src/virtualdom/items/Element/prototype/findComponent.js","../src/virtualdom/items/Element/prototype/findNextNode.js","../src/virtualdom/items/Element/prototype/firstNode.js","../src/virtualdom/items/Element/prototype/getAttribute.js","../src/virtualdom/items/Element/prototype/init/processBindingAttributes.js","../src/virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js","../src/virtualdom/items/Element/Attribute/prototype/rebind.js","../src/virtualdom/items/Partial/getPartialTemplate.js","../src/virtualdom/items/Component/getComponent.js","../src/viewmodel/helpers/getUpstreamChanges.js","../src/viewmodel/prototype/applyChanges.js","../src/viewmodel/prototype/compute.js","../src/viewmodel/prototype/set.js","../src/viewmodel/prototype/unregister.js","../src/virtualdom/items/Component/initialise/propagateEvents.js","../src/virtualdom/items/Component/prototype/init.js","../src/virtualdom/Fragment/prototype/init.js","../src/virtualdom/Fragment/prototype/rebind.js","../src/Ractive/prototype/resetTemplate.js","../src/Ractive/prototype/set.js","../src/Ractive/prototype/subtract.js","../src/Ractive/prototype/toggle.js","../src/Ractive/prototype/updateModel.js","../src/extend/unwrapExtended.js","../src/config/template.js","../src/config/environment.js","../src/Ractive/config/defaults.js","../src/Ractive/static/easing.js","../src/utils/dom.js","../src/legacy.js","../src/utils/object.js","../src/utils/log.js","../src/utils/is.js","../src/utils/noop.js","../src/config/errors.js","../src/shared/interpolate.js","../src/Ractive/static/interpolators.js","../src/utils/getPotentialWildcardMatches.js","../src/shared/keypaths.js","../src/utils/requestAnimationFrame.js","../src/Ractive/prototype/shared/add.js","../src/utils/getTime.js","../src/Ractive/prototype/shared/hooks/Hook.js","../src/utils/Promise.js","../src/shared/getInnerContext.js","../src/global/TransitionManager.js","../src/global/runloop.js","../src/shared/animations.js","../src/parse/converters/readTemplate.js","../src/Ractive/config/wrapPrototypeMethod.js","../src/Ractive/config/deprecate.js","../src/virtualdom/Fragment/prototype/getArgsList.js","../src/virtualdom/Fragment/prototype/getValue.js","../src/virtualdom/items/shared/unbind.js","../src/virtualdom/items/shared/Resolvers/createReferenceResolver.js","../src/virtualdom/items/shared/Mustache/initialise.js","../src/virtualdom/items/Section/prototype/findAllComponents.js","../src/virtualdom/items/Section/prototype/shuffle.js","../src/virtualdom/items/Section/prototype/setValue.js","../src/virtualdom/items/Section/prototype/unbind.js","../src/virtualdom/items/Triple/prototype/find.js","../src/virtualdom/items/Triple/prototype/findAll.js","../src/virtualdom/items/Triple/helpers/updateSelect.js","../src/virtualdom/items/Triple/prototype/render.js","../src/virtualdom/items/Triple/prototype/setValue.js","../src/virtualdom/items/Triple/prototype/toString.js","../src/virtualdom/items/Triple/prototype/unrender.js","../src/virtualdom/items/Triple/prototype/update.js","../src/virtualdom/items/Element/Attribute/prototype/bubble.js","../src/virtualdom/items/Element/Attribute/helpers/getInterpolator.js","../src/virtualdom/items/Element/Attribute/prototype/init.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js","../src/virtualdom/items/Element/Attribute/prototype/update/updateClassName.js","../src/virtualdom/items/Element/Attribute/prototype/update.js","../src/virtualdom/items/Element/Binding/shared/handleDomEvent.js","../src/virtualdom/items/Element/prototype/init/createTwowayBinding.js","../src/virtualdom/items/Element/EventHandler/prototype/fire.js","../src/virtualdom/items/Element/EventHandler/shared/genericHandler.js","../src/virtualdom/items/Element/EventHandler/prototype/unbind.js","../src/virtualdom/items/Element/EventHandler/prototype/unrender.js","../src/virtualdom/items/Element/special/select.js","../src/virtualdom/items/Element/special/option.js","../src/virtualdom/items/Element/prototype/init.js","../src/virtualdom/items/Element/prototype/rebind.js","../src/virtualdom/items/Element/special/img.js","../src/virtualdom/items/Element/special/form.js","../src/virtualdom/items/Element/Transition/prototype/init.js","../src/virtualdom/items/Element/prototype/unbind.js","../src/virtualdom/items/Element/prototype/unrender.js","../src/shared/registry.js","../src/Ractive/prototype/add.js","../src/utils/array.js","../src/shared/resolveRef.js","../src/shared/methodCallers.js","../src/Ractive/prototype/shared/makeQuery/test.js","../src/Ractive/prototype/shared/makeQuery/_makeQuery.js","../src/Ractive/prototype/findAll.js","../src/Ractive/prototype/findAllComponents.js","../src/Ractive/prototype/findContainer.js","../src/Ractive/prototype/shared/fireEvent.js","../src/Ractive/prototype/fire.js","../src/Ractive/prototype/merge.js","../src/Ractive/prototype/observe/getPattern.js","../src/Ractive/prototype/observe.js","../src/Ractive/prototype/off.js","../src/Ractive/prototype/on.js","../src/shared/getNewIndices.js","../src/parse/converters/expressions/primary/literal/readBooleanLiteral.js","../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePair.js","../src/parse/converters/expressions/primary/literal/objectLiteral/keyValuePairs.js","../src/parse/converters/expressions/shared/readExpressionList.js","../src/parse/converters/expressions/primary/readLiteral.js","../src/parse/converters/expressions/primary/readBracketedExpression.js","../src/parse/converters/expressions/shared/readRefinement.js","../src/parse/converters/expressions/readConditional.js","../src/parse/converters/readExpression.js","../src/parse/utils/flattenExpression.js","../src/parse/converters/mustache/readUnescaped.js","../src/parse/converters/mustache/readPartial.js","../src/parse/converters/mustache/readMustacheComment.js","../src/parse/converters/readExpressionOrReference.js","../src/parse/converters/mustache/readInterpolator.js","../src/parse/converters/mustache/section/readClosing.js","../src/parse/converters/readText.js"],"sourcesContent":["import { COMMENT } from 'config/types';\nimport detach from './shared/detach';\n\nvar Comment = function ( options ) {\n\tthis.type = COMMENT;\n\tthis.value = options.template.c;\n};\n\nComment.prototype = {\n\tdetach: detach,\n\n\tfirstNode () {\n\t\treturn this.node;\n\t},\n\n\trender () {\n\t\tif ( !this.node ) {\n\t\t\tthis.node = document.createComment( this.value );\n\t\t}\n\n\t\treturn this.node;\n\t},\n\n\ttoString () {\n\t\treturn '<!--' + this.value + '-->';\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( shouldDestroy ) {\n\t\t\tthis.node.parentNode.removeChild( this.node );\n\t\t}\n\t}\n};\n\nexport default Comment;\n","import { YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\nimport { isArray } from 'utils/is';\n\nvar Yielder = function ( options ) {\n\tvar container, component;\n\n\tthis.type = YIELDER;\n\n\tthis.container = container = options.parentFragment.root;\n\tthis.component = component = container.component;\n\n\tthis.container = container;\n\tthis.containerFragment = options.parentFragment;\n\tthis.parentFragment = component.parentFragment;\n\n\tlet name = this.name = options.template.n || '';\n\n\tlet template = container._inlinePartials[ name ];\n\n\tif ( !template ) {\n\t\twarnIfDebug( `Could not find template for partial \"${name}\"`, { ractive: options.root });\n\t\ttemplate = [];\n\t}\n\n\tthis.fragment = new Fragment({\n\t\towner: this,\n\t\troot: container.parent,\n\t\ttemplate,\n\t\tpElement: this.containerFragment.pElement\n\t});\n\n\t// even though only one yielder is allowed, we need to have an array of them\n\t// as it's possible to cause a yielder to be created before the last one\n\t// was destroyed in the same turn of the runloop\n\tif ( !isArray( component.yielders[ name ] ) ) {\n\t\tcomponent.yielders[ name ] = [ this ];\n\t} else {\n\t\tcomponent.yielders[ name ].push( this );\n\t}\n\n\trunloop.scheduleTask( () => {\n\t\tif ( component.yielders[ name ].length > 1 ) {\n\t\t\tthrow new Error( 'A component template can only have one {{yield' + (name ? ' ' + name : '') + '}} declaration at a time' );\n\t\t}\n\t});\n};\n\nYielder.prototype = {\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfindNextNode () {\n\t\treturn this.containerFragment.findNextNode( this );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tgetValue ( options ) {\n\t\treturn this.fragment.getValue( options );\n\t},\n\n\trender () {\n\t\treturn this.fragment.render();\n\t},\n\n\tunbind () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tthis.fragment.unrender( shouldDestroy );\n\t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\ttoString () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default Yielder;\n","import noop from 'utils/noop';\n\nvar Doctype = function ( options ) {\n\tthis.declaration = options.template.a;\n};\n\nDoctype.prototype = {\n\tinit: noop,\n\trender: noop,\n\tunrender: noop,\n\tteardown: noop,\n\ttoString () {\n\t\treturn '<!DOCTYPE' + this.declaration + '>';\n\t}\n};\n\nexport default Doctype;","export default function Fragment$render () {\n\tvar result;\n\n\tif ( this.items.length === 1 ) {\n\t\tresult = this.items[0].render();\n\t} else {\n\t\tresult = document.createDocumentFragment();\n\n\t\tthis.items.forEach( item => {\n\t\t\tresult.appendChild( item.render() );\n\t\t});\n\t}\n\n\tthis.rendered = true;\n\treturn result;\n}\n","export default function Fragment$toString ( escape ) {\n\tif ( !this.items ) {\n\t\treturn '';\n\t}\n\n\treturn this.items.map( escape ? toEscapedString : toString ).join( '' );\n}\n\nfunction toString ( item ) {\n\treturn item.toString();\n}\n\nfunction toEscapedString ( item ) {\n\treturn item.toString( true );\n}","export default function Fragment$unbind () {\n\tif ( !this.bound ) {\n\t\treturn;\n\t}\n\n\tthis.items.forEach( unbindItem );\n\tthis.bound = false;\n}\n\nfunction unbindItem ( item ) {\n\tif ( item.unbind ) {\n\t\titem.unbind();\n\t}\n}\n","export default function Fragment$unrender ( shouldDestroy ) {\n\tif ( !this.rendered ) {\n\t\tthrow new Error( 'Attempted to unrender a fragment that was not rendered' );\n\t}\n\n\tthis.items.forEach( i => i.unrender( shouldDestroy ) );\n\tthis.rendered = false;\n}\n","import bubble from './Fragment/prototype/bubble';\nimport detach from './Fragment/prototype/detach';\nimport find from './Fragment/prototype/find';\nimport findAll from './Fragment/prototype/findAll';\nimport findAllComponents from './Fragment/prototype/findAllComponents';\nimport findComponent from './Fragment/prototype/findComponent';\nimport findNextNode from './Fragment/prototype/findNextNode';\nimport firstNode from './Fragment/prototype/firstNode';\nimport getArgsList from './Fragment/prototype/getArgsList';\nimport getNode from './Fragment/prototype/getNode';\nimport getValue from './Fragment/prototype/getValue';\nimport init from './Fragment/prototype/init';\nimport rebind from './Fragment/prototype/rebind';\nimport render from './Fragment/prototype/render';\nimport toString from './Fragment/prototype/toString';\nimport unbind from './Fragment/prototype/unbind';\nimport unrender from './Fragment/prototype/unrender';\n\nvar Fragment = function ( options ) {\n\tthis.init( options );\n};\n\nFragment.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetArgsList: getArgsList,\n\tgetNode: getNode,\n\tgetValue: getValue,\n\tinit: init,\n\trebind: rebind,\n\tregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tif ( idxs.indexOf( idx ) === -1 ) {\n\t\t\tidxs.push( idx );\n\t\t}\n\t},\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunregisterIndexRef: function( idx ) {\n\t\tvar idxs = this.registeredIndexRefs;\n\t\tidxs.splice( idxs.indexOf( idx ), 1 );\n\t},\n\tunrender: unrender\n};\n\nexport default Fragment;\n","import defaults from 'Ractive/config/defaults';\nimport easing from 'Ractive/static/easing';\nimport interpolators from 'Ractive/static/interpolators';\nimport { magic, svg } from 'config/environment';\nimport { defineProperties, extend as extendObj } from 'utils/object';\nimport proto from 'Ractive/prototype';\nimport Promise from 'utils/Promise';\nimport extend from 'extend/_extend';\nimport parse from 'parse/_parse';\nimport getNodeInfo from 'Ractive/static/getNodeInfo';\nimport initialise from 'Ractive/initialise';\n\nvar Ractive, properties;\n\n// Main Ractive required object\nRactive = function ( options ) {\n\tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\tinitialise( this, options );\n};\n\n\n// Ractive properties\nproperties = {\n\n\t// debug flag\n\tDEBUG:          { writable: true, value: true },\n\tDEBUG_PROMISES: { writable: true, value: true },\n\n\t// static methods:\n\textend:         { value: extend },\n\tgetNodeInfo:    { value: getNodeInfo },\n\tparse:          { value: parse },\n\n\t// Namespaced constructors\n\tPromise:        { value: Promise },\n\n\t// support\n\tsvg:            { value: svg },\n\tmagic:          { value: magic },\n\n\t// version\n\tVERSION:        { value: '<@version@>' },\n\n\t// Plugins\n\tadaptors:       { writable: true, value: {} },\n\tcomponents:     { writable: true, value: {} },\n\tdecorators:     { writable: true, value: {} },\n\teasing:         { writable: true, value: easing },\n\tevents:         { writable: true, value: {} },\n\tinterpolators:  { writable: true, value: interpolators },\n\tpartials:       { writable: true, value: {} },\n\ttransitions:    { writable: true, value: {} }\n};\n\n\n// Ractive properties\ndefineProperties( Ractive, properties );\n\nRactive.prototype = extendObj( proto, defaults );\n\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as defaults\nRactive.defaults = Ractive.prototype;\n\n// Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n// older browsers, these are made available via a shim - here, we do a quick\n// pre-flight check to make sure that either a) we're not in a shit browser,\n// or b) we're using a Ractive-legacy.js build\nvar FUNCTION = 'function';\n\nif (\n\ttypeof Date.now !== FUNCTION                 ||\n\ttypeof String.prototype.trim !== FUNCTION    ||\n\ttypeof Object.keys !== FUNCTION              ||\n\ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\ttypeof Array.prototype.forEach !== FUNCTION  ||\n\ttypeof Array.prototype.map !== FUNCTION      ||\n\ttypeof Array.prototype.filter !== FUNCTION   ||\n\t( typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION )\n) {\n\tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n}\n\nexport default Ractive;\n","import config from 'Ractive/config/config';\nimport Fragment from 'virtualdom/Fragment';\nimport Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { rootKeypath } from 'shared/keypaths';\n\nvar shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ],\n\tresetHook = new Hook( 'reset' );\n\nexport default function Ractive$reset ( data ) {\n\tvar promise, wrapper, changes, i, rerender;\n\n\tdata = data || {};\n\n\tif ( typeof data !== 'object' ) {\n\t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t}\n\n\t// If the root object is wrapped, try and use the wrapper's reset value\n\tif ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {\n\t\tif ( wrapper.reset( data ) === false ) {\n\t\t\t// reset was rejected, we need to replace the object\n\t\t\tthis.viewmodel.reset( data );\n\t\t}\n\t} else {\n\t\tthis.viewmodel.reset( data );\n\t}\n\n\t// reset config items and track if need to rerender\n\tchanges = config.reset( this );\n\n\ti = changes.length;\n\twhile ( i-- ) {\n\t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t\t\trerender = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ( rerender ) {\n\t\tlet component;\n\n\t\tthis.viewmodel.mark( rootKeypath );\n\n\t\t// Is this is a component, we need to set the `shouldDestroy`\n\t \t// flag, otherwise it will assume by default that a parent node\n\t \t// will be detached, and therefore it doesn't need to bother\n\t \t// detaching its own nodes\n\t \tif ( component = this.component ) {\n\t \t\tcomponent.shouldDestroy = true;\n\t \t}\n\n\t\tthis.unrender();\n\n\t\tif ( component ) {\n\t\t\tcomponent.shouldDestroy = false;\n\t\t}\n\n\t\t// If the template changed, we need to destroy the parallel DOM\n\t\t// TODO if we're here, presumably it did?\n\t\tif ( this.fragment.template !== this.template ) {\n\t\t\tthis.fragment.unbind();\n\n\t\t\tthis.fragment = new Fragment({\n\t\t\t\ttemplate: this.template,\n\t\t\t\troot: this,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tpromise = this.render( this.el, this.anchor );\n\t} else {\n\t\tpromise = runloop.start( this, true );\n\t\tthis.viewmodel.mark( rootKeypath );\n\t\trunloop.end();\n\t}\n\n\tresetHook.fire( this, data );\n\n\treturn promise;\n}\n","import { isArray } from 'utils/is';\nimport runloop from 'global/runloop';\nimport { PARTIAL, COMPONENT, ELEMENT } from 'config/types';\n\nexport default function ( name, partial ) {\n\tvar promise, collection = [];\n\n\tfunction collect( source, dest, ractive ) {\n\t\t// if this is a component and it has its own partial, bail\n\t\tif ( ractive && ractive.partials[name] ) return;\n\n\t\tsource.forEach( item => {\n\t\t\t// queue to rerender if the item is a partial and the current name matches\n\t\t\tif ( item.type === PARTIAL && item.getPartialName() === name ) {\n\t\t\t\tdest.push( item );\n\t\t\t}\n\n\t\t\t// if it has a fragment, process its items\n\t\t\tif ( item.fragment ) {\n\t\t\t\tcollect( item.fragment.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it has fragments\n\t\t\tif ( isArray( item.fragments ) ) {\n\t\t\t\tcollect( item.fragments, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is itself a fragment, process its items\n\t\t\telse if ( isArray( item.items ) ) {\n\t\t\t\tcollect( item.items, dest, ractive );\n\t\t\t}\n\n\t\t\t// or if it is a component, step in and process its items\n\t\t\telse if ( item.type === COMPONENT && item.instance ) {\n\t\t\t\tcollect( item.instance.fragment.items, dest, item.instance );\n\t\t\t}\n\n\t\t\t// if the item is an element, process its attributes too\n\t\t\tif ( item.type === ELEMENT ) {\n\t\t\t\tif ( isArray( item.attributes ) ) {\n\t\t\t\t\tcollect( item.attributes, dest, ractive );\n\t\t\t\t}\n\n\t\t\t\tif ( isArray( item.conditionalAttributes ) ) {\n\t\t\t\t\tcollect( item.conditionalAttributes, dest, ractive );\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tcollect( this.fragment.items, collection );\n\tthis.partials[name] = partial;\n\n\tpromise = runloop.start( this, true );\n\n\tcollection.forEach( item => {\n\t\titem.value = undefined;\n\t\titem.setValue( name );\n\t});\n\n\trunloop.end();\n\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'reverse' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'shift' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'sort' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'splice' );\n","import Hook from './shared/hooks/Hook';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport { cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nexport default function Ractive$teardown () {\n\tvar promise;\n\n\tthis.fragment.unbind();\n\tthis.viewmodel.teardown();\n\n\tthis._observers.forEach( cancel );\n\n\tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\n\tthis.shouldDestroy = true;\n\tpromise = ( this.fragment.rendered ? this.unrender() : Promise.resolve() );\n\n\tteardownHook.fire( this );\n\n\tthis._boundFunctions.forEach( deleteFunctionCopy );\n\n\treturn promise;\n}\n\nfunction deleteFunctionCopy ( bound ) {\n\tdelete bound.fn[ bound.prop ];\n}","export default function Ractive$toHTML () {\n\treturn this.fragment.toString( true );\n}\n","import Hook from './shared/hooks/Hook';\nimport { warnIfDebug } from 'utils/log';\nimport Promise from 'utils/Promise';\nimport { removeFromArray } from 'utils/array';\nimport runloop from 'global/runloop';\n\nvar unrenderHook = new Hook( 'unrender' );\n\nexport default function Ractive$unrender () {\n\tvar promise, shouldDestroy;\n\n\tif ( !this.fragment.rendered ) {\n\t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t\treturn Promise.resolve();\n\t}\n\n\tpromise = runloop.start( this, true );\n\n\t// If this is a component, and the component isn't marked for destruction,\n\t// don't detach nodes from the DOM unnecessarily\n\tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n\t// Cancel any animations in progress\n\twhile ( this._animations[0] ) {\n\t\tthis._animations[0].stop(); // it will remove itself from the index\n\t}\n\n\tthis.fragment.unrender( shouldDestroy );\n\n\tremoveFromArray( this.el.__ractive_instances__, this );\n\n\tunrenderHook.fire( this );\n\n\trunloop.end();\n\treturn promise;\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'unshift' );\n","import Hook from './shared/hooks/Hook';\nimport runloop from 'global/runloop';\nimport { getKeypath, rootKeypath } from 'shared/keypaths';\n\nvar updateHook = new Hook( 'update' );\n\nexport default function Ractive$update ( keypath ) {\n\tvar promise;\n\n\tkeypath = getKeypath( keypath ) || rootKeypath;\n\n\tpromise = runloop.start( this, true );\n\tthis.viewmodel.mark( keypath );\n\trunloop.end();\n\n\tupdateHook.fire( this, keypath );\n\n\treturn promise;\n}\n","import add from 'Ractive/prototype/add';\nimport animate from 'Ractive/prototype/animate';\nimport detach from 'Ractive/prototype/detach';\nimport find from 'Ractive/prototype/find';\nimport findAll from 'Ractive/prototype/findAll';\nimport findAllComponents from 'Ractive/prototype/findAllComponents';\nimport findComponent from 'Ractive/prototype/findComponent';\nimport findContainer from 'Ractive/prototype/findContainer';\nimport findParent from 'Ractive/prototype/findParent';\nimport fire from 'Ractive/prototype/fire';\nimport get from 'Ractive/prototype/get';\nimport insert from 'Ractive/prototype/insert';\nimport merge from 'Ractive/prototype/merge';\nimport observe from 'Ractive/prototype/observe';\nimport observeOnce from 'Ractive/prototype/observeOnce';\nimport off from 'Ractive/prototype/off';\nimport on from 'Ractive/prototype/on';\nimport once from 'Ractive/prototype/once';\nimport pop from 'Ractive/prototype/pop';\nimport push from 'Ractive/prototype/push';\nimport render from 'Ractive/prototype/render';\nimport reset from 'Ractive/prototype/reset';\nimport resetPartial from 'Ractive/prototype/resetPartial';\nimport resetTemplate from 'Ractive/prototype/resetTemplate';\nimport reverse from 'Ractive/prototype/reverse';\nimport set from 'Ractive/prototype/set';\nimport shift from 'Ractive/prototype/shift';\nimport sort from 'Ractive/prototype/sort';\nimport splice from 'Ractive/prototype/splice';\nimport subtract from 'Ractive/prototype/subtract';\nimport teardown from 'Ractive/prototype/teardown';\nimport toggle from 'Ractive/prototype/toggle';\nimport toHTML from 'Ractive/prototype/toHTML';\nimport unrender from 'Ractive/prototype/unrender';\nimport unshift from 'Ractive/prototype/unshift';\nimport update from 'Ractive/prototype/update';\nimport updateModel from 'Ractive/prototype/updateModel';\n\nexport default {\n\tadd: add,\n\tanimate: animate,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindContainer: findContainer,\n\tfindParent: findParent,\n\tfire: fire,\n\tget: get,\n\tinsert: insert,\n\tmerge: merge,\n\tobserve: observe,\n\tobserveOnce: observeOnce,\n\toff: off,\n\ton: on,\n\tonce: once,\n\tpop: pop,\n\tpush: push,\n\trender: render,\n\treset: reset,\n\tresetPartial: resetPartial,\n\tresetTemplate: resetTemplate,\n\treverse: reverse,\n\tset: set,\n\tshift: shift,\n\tsort: sort,\n\tsplice: splice,\n\tsubtract: subtract,\n\tteardown: teardown,\n\ttoggle: toggle,\n\ttoHTML: toHTML,\n\ttoHtml: toHTML,\n\tunrender: unrender,\n\tunshift: unshift,\n\tupdate: update,\n\tupdateModel: updateModel\n};\n","export default function ( method, superMethod, force ) {\n\n\tif ( force || needsSuper( method, superMethod ) )  {\n\n\t\treturn function () {\n\n\t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n\t\t\tthis._super = superMethod;\n\n\t\t\tresult = method.apply( this, arguments );\n\n\t\t\tif ( hasSuper ) {\n\t\t\t\tthis._super = _super;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\telse {\n\t\treturn method;\n\t}\n}\n\nfunction needsSuper ( method, superMethod ) {\n\treturn typeof superMethod === 'function' && /_super/.test( method );\n}\n","import { create, defineProperties, extend as extendObj } from 'utils/object';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport initialise from 'Ractive/initialise';\nimport Ractive from 'Ractive';\nimport unwrapExtended from './unwrapExtended';\n\nexport default extend;\n\nfunction extend ( ...options ) {\n\tif( !options.length ) {\n\t\treturn extendOne( this );\n\t} else {\n\t\treturn options.reduce( extendOne, this );\n\t}\n}\n\nfunction extendOne ( Parent, options = {} ) {\n\tvar Child, proto;\n\n\t// if we're extending with another Ractive instance...\n\t//\n\t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t//   var Spiderman = Human.extend( Spider );\n\t//\n\t// ...inherit prototype methods and default options as well\n\tif ( options.prototype instanceof Ractive ) {\n\t\toptions = unwrapExtended( options );\n\t}\n\n\tChild = function ( options ) {\n\t\tif ( !( this instanceof Child ) ) return new Child( options );\n\t\tinitialise( this, options );\n\t};\n\n\tproto = create( Parent.prototype );\n\tproto.constructor = Child;\n\n\t// Static properties\n\tdefineProperties( Child, {\n\t\t// alias prototype as defaults\n\t\tdefaults: { value: proto },\n\n\t\t// extendable\n\t\textend: { value: extend, writable: true, configurable: true },\n\n\t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t\t_Parent: { value: Parent }\n\t});\n\n\t// extend configuration\n\tconfig.extend( Parent, proto, options );\n\n\tdataConfigurator.extend( Parent, proto, options );\n\n\tif ( options.computed ) {\n\t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t}\n\n\tChild.prototype = proto;\n\n\treturn Child;\n}\n","import findIndexRefs from 'virtualdom/items/shared/Resolvers/findIndexRefs';\n\nexport default function( node ) {\n\tvar info = {}, priv, indices;\n\n\tif ( !node || !( priv = node._ractive ) ) {\n\t\treturn info;\n\t}\n\n\tinfo.ractive = priv.root;\n\tinfo.keypath = priv.keypath.str;\n\tinfo.index = {};\n\n\t// find all index references and resolve them\n\tif ( indices = findIndexRefs( priv.proxy.parentFragment ) ) {\n\t\tinfo.index = findIndexRefs.resolve( indices );\n\t}\n\n\treturn info;\n}\n","import { namespaces } from 'config/environment';\n\n// the property name equivalents for element attributes, where they differ\n// from the lowercased attribute name\nvar propertyNames = {\n\t'accept-charset': 'acceptCharset',\n\t'accesskey': 'accessKey',\n\t'bgcolor': 'bgColor',\n\t'class': 'className',\n\t'codebase': 'codeBase',\n\t'colspan': 'colSpan',\n\t'contenteditable': 'contentEditable',\n\t'datetime': 'dateTime',\n\t'dirname': 'dirName',\n\t'for': 'htmlFor',\n\t'http-equiv': 'httpEquiv',\n\t'ismap': 'isMap',\n\t'maxlength': 'maxLength',\n\t'novalidate': 'noValidate',\n\t'pubdate': 'pubDate',\n\t'readonly': 'readOnly',\n\t'rowspan': 'rowSpan',\n\t'tabindex': 'tabIndex',\n\t'usemap': 'useMap'\n};\n\nexport default function Attribute$render ( node ) {\n\tvar propertyName;\n\n\tthis.node = node;\n\n\t// should we use direct property access, or setAttribute?\n\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t\tpropertyName = propertyNames[ this.name ] || this.name;\n\n\t\tif ( node[ propertyName ] !== undefined ) {\n\t\t\tthis.propertyName = propertyName;\n\t\t}\n\n\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t\tif ( this.isBoolean || this.isTwoway ) {\n\t\t\tthis.useProperty = true;\n\t\t}\n\n\t\tif ( propertyName === 'value' ) {\n\t\t\tnode._ractive.value = this.value;\n\t\t}\n\t}\n\n\tthis.rendered = true;\n\tthis.update();\n}\n","export default function Attribute$toString () {\n\tvar { name, namespacePrefix, value, interpolator, fragment } = this;\n\n\t// Special case - select and textarea values (should not be stringified)\n\tif ( name === 'value' && ( this.element.name === 'select' || this.element.name === 'textarea' ) ) {\n\t\treturn;\n\t}\n\n\t// Special case - content editable\n\tif ( name === 'value' && this.element.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\treturn;\n\t}\n\n\t// Special case - radio names\n\tif ( name === 'name' && this.element.name === 'input' && interpolator ) {\n\t\treturn 'name={{' + ( interpolator.keypath.str || interpolator.ref ) + '}}';\n\t}\n\n\t// Boolean attributes\n\tif ( this.isBoolean ) {\n\t\treturn value ? name : '';\n\t}\n\n\tif ( fragment ) {\n\t\t// special case - this catches undefined/null values (#1211)\n\t\tif ( fragment.items.length === 1 && fragment.items[0].value == null ) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvalue = fragment.toString();\n\t}\n\n\tif ( namespacePrefix ) {\n\t\tname = namespacePrefix + ':' + name;\n\t}\n\n\treturn value ? name + '=\"' + escape( value ) + '\"' : name;\n}\n\nfunction escape ( value ) {\n\treturn value\n\t\t.replace( /&/g, '&amp;' )\n\t\t.replace( /\"/g, '&quot;' )\n\t\t.replace( /'/g, '&#39;' );\n}\n","export default function Attribute$unbind () {\n\t// ignore non-dynamic attributes\n\tif ( this.fragment ) {\n\t\tthis.fragment.unbind();\n\t}\n\n\tif ( this.name === 'id' ) {\n\t\tdelete this.root.nodes[ this.value ];\n\t}\n}\n","export default function Attribute$updateSelect () {\n\tvar value = this.value, options, option, optionValue, i;\n\n\tif ( !this.locked ) {\n\t\tthis.node._ractive.value = value;\n\n\t\toptions = this.node.options;\n\t\ti = options.length;\n\n\t\twhile ( i-- ) {\n\t\t\toption = options[i];\n\t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t\t\t\toption.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if we're still here, it means the new value didn't match any of the options...\n\t// TODO figure out what to do in this situation\n}\n","export default function Attribute$updateRadioName () {\n\tvar { node, value } = this;\n\tnode.checked = ( value == node._ractive.value );\n}\n","export default function Attribute$updateIdAttribute () {\n\tvar { node, value } = this;\n\n\tthis.root.nodes[ value ] = node;\n\tnode.id = value;\n}\n","export default function Attribute$updateIEStyleAttribute () {\n\tvar node, value;\n\n\tnode = this.node;\n\tvalue = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tnode.style.setAttribute( 'cssText', value );\n}\n","export default function Attribute$updateContentEditableValue () {\n\tvar value = this.value;\n\n\tif ( value === undefined ) {\n\t\tvalue = '';\n\t}\n\n\tif ( !this.locked ) {\n\t\tthis.node.innerHTML = value;\n\t}\n}\n","export default function Attribute$updateValue () {\n\tvar { node, value } = this;\n\n\t// store actual value, so it doesn't get coerced to a string\n\tnode._ractive.value = value;\n\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tnode.value = ( value == undefined ? '' : value );\n\t}\n}\n","export default function Attribute$updateBooleanAttribute () {\n\t// with two-way binding, only update if the change wasn't initiated by the user\n\t// otherwise the cursor will often be sent to the wrong place\n\tif ( !this.locked ) {\n\t\tthis.node[ this.propertyName ] = this.value;\n\t}\n}\n","export default function Attribute$updateEverythingElse () {\n\tvar { node, namespace, name, value, fragment } = this;\n\n\tif ( namespace ) {\n\t\tnode.setAttributeNS( namespace, name, ( fragment || value ).toString() );\n\t}\n\n\telse if ( !this.isBoolean ) {\n\t\tif ( value == null ) {\n\t\t\tnode.removeAttribute( name );\n\t\t} else {\n\t\t\tnode.setAttribute( name, ( fragment || value ).toString() );\n\t\t}\n\t}\n\n\t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n\telse {\n\t\tif ( value ) {\n\t\t\tnode.setAttribute( name, '' );\n\t\t} else {\n\t\t\tnode.removeAttribute( name );\n\t\t}\n\t}\n}\n","import bubble from './prototype/bubble';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport update from './prototype/update';\n\nvar Attribute = function ( options ) {\n\tthis.init( options );\n};\n\nAttribute.prototype = {\n\tbubble: bubble,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tupdate: update\n};\n\nexport default Attribute;\n","import { namespaces } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport { toArray } from 'utils/array';\nimport Fragment from 'virtualdom/Fragment';\n\nvar div;\n\nif ( typeof document !== 'undefined' ) {\n\tdiv = createElement( 'div' );\n}\n\nvar ConditionalAttribute = function ( element, template ) {\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\n\tthis.attributes = [];\n\n\tthis.fragment = new Fragment({\n\t\troot: element.root,\n\t\towner: this,\n\t\ttemplate: [ template ]\n\t});\n};\n\nConditionalAttribute.prototype = {\n\tbubble: function () {\n\t\tif ( this.node ) {\n\t\t\tthis.update();\n\t\t}\n\n\t\tthis.element.bubble();\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\trender: function ( node ) {\n\t\tthis.node = node;\n\t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n\t\tthis.update();\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t},\n\n\tupdate: function () {\n\t\tvar str, attrs;\n\n\t\tstr = this.fragment.toString();\n\t\tattrs = parseAttributes( str, this.isSvg );\n\n\t\t// any attributes that previously existed but no longer do\n\t\t// must be removed\n\t\tthis.attributes.filter( a => notIn( attrs, a ) ).forEach( a => {\n\t\t\tthis.node.removeAttribute( a.name );\n\t\t});\n\n\t\tattrs.forEach( a => {\n\t\t\tthis.node.setAttribute( a.name, a.value );\n\t\t});\n\n\t\tthis.attributes = attrs;\n\t},\n\n\ttoString: function () {\n\t\treturn this.fragment.toString();\n\t}\n};\n\nexport default ConditionalAttribute;\n\n\nfunction parseAttributes ( str, isSvg ) {\n\tvar tag = isSvg ? 'svg' : 'div';\n\tdiv.innerHTML = '<' + tag + ' ' + str + '></' + tag + '>';\n\n\treturn toArray( div.childNodes[0].attributes );\n}\n\nfunction notIn ( haystack, needle ) {\n\tvar i = haystack.length;\n\n\twhile ( i-- ) {\n\t\tif ( haystack[i].name === needle.name ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","import Attribute from '../../Attribute/_Attribute';\n\nexport default function ( element, attributes ) {\n\tvar name, attribute, result = [];\n\n\tfor ( name in attributes ) {\n\t\t// skip binding attributes\n\t\tif ( name === 'twoway' || name === 'lazy') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( attributes.hasOwnProperty( name ) ) {\n\t\t\tattribute = new Attribute({\n\t\t\t\telement: element,\n\t\t\t\tname:    name,\n\t\t\t\tvalue:   attributes[ name ],\n\t\t\t\troot:    element.root\n\t\t\t});\n\n\t\t\tresult[ name ] = attribute;\n\n\t\t\tif ( name !== 'value' ) {\n\t\t\t\tresult.push( attribute );\n\t\t\t}\n\t\t}\n\t}\n\n\t// value attribute goes last. This is because it\n\t// may get clamped on render otherwise, e.g. in\n\t// `<input type='range' value='999' min='0' max='1000'>`\n\t// since default max is 100\n\tif ( attribute = result.value ) {\n\t\tresult.push( attribute );\n\t}\n\n\treturn result;\n}\n","import ConditionalAttribute from '../../ConditionalAttribute/_ConditionalAttribute';\n\nexport default function ( element, attributes ) {\n\tif ( !attributes ) {\n\t\treturn [];\n\t}\n\n\treturn attributes.map( a => {\n\t\treturn new ConditionalAttribute( element, a );\n\t});\n}\n","import runloop from 'global/runloop';\nimport { warnIfDebug, warnOnceIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { removeFromArray } from 'utils/array';\n\nvar Binding = function ( element ) {\n\tvar interpolator, keypath, value, parentForm;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.attribute = element.attributes[ this.name || 'value' ];\n\n\tinterpolator = this.attribute.interpolator;\n\tinterpolator.twowayBinding = this;\n\n\tif ( keypath = interpolator.keypath ) {\n\t\tif ( keypath.str.slice( -1 ) === '}' ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with expressions (`%s` on <%s>)', interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( keypath.isSpecial ) {\n\t\t\twarnOnceIfDebug( 'Two-way binding does not work with %s', interpolator.resolver.ref, { ractive: this.root });\n\t\t\treturn false;\n\t\t}\n\t}\n\n\telse {\n\t\t// A mustache may be *ambiguous*. Let's say we were given\n\t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n\t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n\t\t// Then, any user input would result in `foo.bar` being updated.\n\t\t//\n\t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n\t\t// left with an unresolved partial keypath - so we are forced to make an\n\t\t// assumption. That assumption is that the input in question should\n\t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n\t\t// and not `foo.bar`.\n\t\t//\n\t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n\t\t// be explicit when using two-way data-binding about what keypath you're\n\t\t// updating. Using it in lists is probably a recipe for confusion...\n\t\tlet ref = interpolator.template.r ? `'${interpolator.template.r}' reference` : 'expression';\n\t\twarnIfDebug( 'The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity', ref, { ractive: this.root });\n\t\tinterpolator.resolver.forceResolution();\n\t\tkeypath = interpolator.keypath;\n\t}\n\n\tthis.attribute.isTwoway = true;\n\tthis.keypath = keypath;\n\n\t// initialise value, if it's undefined\n\tvalue = this.root.viewmodel.get( keypath );\n\n\tif ( value === undefined && this.getInitialValue ) {\n\t\tvalue = this.getInitialValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t}\n\t}\n\n\tif ( parentForm = findParentForm( element ) ) {\n\t\tthis.resetValue = value;\n\t\tparentForm.formBindings.push( this );\n\t}\n};\n\nBinding.prototype = {\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\t\tthis.attribute.locked = true;\n\t\tthis.root.viewmodel.set( this.keypath, this.getValue() );\n\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\trunloop.end();\n\t},\n\n\trebound: function () {\n\t\tvar bindings, oldKeypath, newKeypath;\n\n\t\toldKeypath = this.keypath;\n\t\tnewKeypath = this.attribute.interpolator.keypath;\n\n\t\t// The attribute this binding is linked to has already done the work\n\t\tif ( oldKeypath === newKeypath ) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveFromArray( this.root._twowayBindings[ oldKeypath.str ], this );\n\n\t\tthis.keypath = newKeypath;\n\n\t\tbindings = this.root._twowayBindings[ newKeypath.str ] || ( this.root._twowayBindings[ newKeypath.str ] = [] );\n\t\tbindings.push( this );\n\t},\n\n\tunbind: function () {\n\t\t// this is called when the element is unbound.\n\t\t// Specialised bindings can override it\n\t}\n};\n\nBinding.extend = function ( properties ) {\n\tvar Parent = this, SpecialisedBinding;\n\n\tSpecialisedBinding = function ( element ) {\n\t\tBinding.call( this, element );\n\n\t\tif ( this.init ) {\n\t\t\tthis.init();\n\t\t}\n\t};\n\n\tSpecialisedBinding.prototype = create( Parent.prototype );\n\textend( SpecialisedBinding.prototype, properties );\n\n\tSpecialisedBinding.extend = Binding.extend;\n\n\treturn SpecialisedBinding;\n};\n\nexport default Binding;\n\nfunction findParentForm ( element ) {\n\twhile ( element = element.parent ) {\n\t\tif ( element.name === 'form' ) {\n\t\t\treturn element;\n\t\t}\n\t}\n}\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport { isNumeric } from 'utils/is';\n\nvar GenericBinding;\n\nGenericBinding = Binding.extend({\n\tgetInitialValue: () => '',\n\n\tgetValue: function () {\n\t\treturn this.element.node.value;\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, lazy, timeout = false;\n\t\tthis.rendered = true;\n\n\t\t// any lazy setting for this element overrides the root\n\t\t// if the value is a number, it's a timeout\n\t\tlazy = this.root.lazy;\n\t\tif ( this.element.lazy === true ) {\n\t\t\tlazy = true;\n\t\t} else if ( this.element.lazy === false ) {\n\t\t\tlazy = false;\n\t\t} else if ( isNumeric( this.element.lazy ) ) {\n\t\t\tlazy = false;\n\t\t\ttimeout = +this.element.lazy;\n\t\t} else if ( isNumeric( ( lazy || '' ) ) ) {\n\t\t\ttimeout = +lazy;\n\t\t\tlazy = false;\n\n\t\t\t// make sure the timeout is available to the handler\n\t\t\tthis.element.lazy = timeout;\n\t\t}\n\n\t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( !lazy ) {\n\t\t\tnode.addEventListener( 'input', this.handler, false );\n\n\t\t\tif ( node.attachEvent ) {\n\t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t\t\t}\n\t\t}\n\n\t\tnode.addEventListener( 'blur', handleBlur, false );\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\t\tthis.rendered = false;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'input', this.handler, false );\n\t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t}\n});\n\nexport default GenericBinding;\n\n\nfunction handleBlur () {\n\tvar value;\n\n\thandleDomEvent.call( this );\n\n\tvalue = this._ractive.root.viewmodel.get( this._ractive.binding.keypath );\n\tthis.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay () {\n\tvar binding = this._ractive.binding, el = this;\n\n\tif ( !!binding._timeout ) clearTimeout( binding._timeout );\n\n\tbinding._timeout = setTimeout( () => {\n\t\tif ( binding.rendered ) handleDomEvent.call( el );\n\t\tbinding._timeout = undefined;\n\t}, binding.element.lazy );\n}\n","import GenericBinding from './GenericBinding';\n\nvar ContentEditableBinding = GenericBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.innerHTML;\n\t}\n});\n\nexport default ContentEditableBinding;\n","var sets = {};\n\nexport default function getSiblings ( id, group, keypath ) {\n\tvar hash = id + group + keypath;\n\treturn sets[ hash ] || ( sets[ hash ] = [] );\n}\n","import runloop from 'global/runloop';\nimport { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar RadioBinding = Binding.extend({\n\tname: 'checked',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );\n\t\tthis.siblings.push( this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\thandleChange: function () {\n\t\trunloop.start( this.root );\n\n\t\tthis.siblings.forEach( binding => {\n\t\t\tbinding.root.viewmodel.set( binding.keypath, binding.getValue() );\n\t\t});\n\n\t\trunloop.end();\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioBinding;\n","import { removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\nimport getSiblings from './shared/getSiblings';\n\nvar RadioNameBinding = Binding.extend({\n\tname: 'name',\n\n\tinit: function () {\n\t\tthis.siblings = getSiblings( this.root._guid, 'radioname', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n\t},\n\n\tgetInitialValue: function () {\n\t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t\t\treturn this.element.getAttribute( 'value' );\n\t\t}\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\tvar node = this.element.node;\n\t\treturn node._ractive ? node._ractive.value : node.value;\n\t},\n\n\thandleChange: function () {\n\t\t// If this <input> is the one that's checked, then the value of its\n\t\t// `name` keypath gets set to its value\n\t\tif ( this.element.node.checked ) {\n\t\t\tBinding.prototype.handleChange.call( this );\n\t\t}\n\t},\n\n\trebound: function ( oldKeypath, newKeypath ) {\n\t\tvar node;\n\n\t\tBinding.prototype.rebound.call( this, oldKeypath, newKeypath );\n\n\t\tif ( node = this.element.node ) {\n\t\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t}\n});\n\nexport default RadioNameBinding;\n","import { isArray } from 'utils/is';\nimport { arrayContains, removeFromArray } from 'utils/array';\nimport Binding from './Binding';\nimport getSiblings from './shared/getSiblings';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxNameBinding = Binding.extend({\n\tname: 'name',\n\n\tgetInitialValue: function () {\n\t\t// This only gets called once per group (of inputs that\n\t\t// share a name), because it only gets called if there\n\t\t// isn't an initial value. By the same token, we can make\n\t\t// a note of that fact that there was no initial value,\n\t\t// and populate it using any `checked` attributes that\n\t\t// exist (which users should avoid, but which we should\n\t\t// support anyway to avoid breaking expectations)\n\t\tthis.noInitialValue = true;\n\t\treturn [];\n\t},\n\n\tinit: function () {\n\t\tvar existingValue, bindingValue;\n\n\t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n\t\t// Each input has a reference to an array containing it and its\n\t\t// siblings, as two-way binding depends on being able to ascertain\n\t\t// the status of all inputs within the group\n\t\tthis.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath.str );\n\t\tthis.siblings.push( this );\n\n\t\tif ( this.noInitialValue ) {\n\t\t\tthis.siblings.noInitialValue = true;\n\t\t}\n\n\t\t// If no initial value was set, and this input is checked, we\n\t\t// update the model\n\t\tif ( this.siblings.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\t\texistingValue.push( bindingValue );\n\t\t}\n\t},\n\n\tunbind: function () {\n\t\tremoveFromArray( this.siblings, this );\n\t},\n\n\trender: function () {\n\t\tvar node = this.element.node, existingValue, bindingValue;\n\n\t\texistingValue = this.root.viewmodel.get( this.keypath );\n\t\tbindingValue = this.element.getAttribute( 'value' );\n\n\t\tif ( isArray( existingValue ) ) {\n\t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t\t} else {\n\t\t\tthis.isChecked = existingValue == bindingValue;\n\t\t}\n\n\t\tnode.name = '{{' + this.keypath.str + '}}';\n\t\tnode.checked = this.isChecked;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\t// in case of IE emergency, bind to click event as well\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tchanged: function () {\n\t\tvar wasChecked = !!this.isChecked;\n\t\tthis.isChecked = this.element.node.checked;\n\t\treturn this.isChecked === wasChecked;\n\t},\n\n\thandleChange: function () {\n\t\tthis.isChecked = this.element.node.checked;\n\t\tBinding.prototype.handleChange.call( this );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.siblings.filter( isChecked ).map( getValue );\n\t}\n});\n\nfunction isChecked ( binding ) {\n\treturn binding.isChecked;\n}\n\nfunction getValue ( binding ) {\n\treturn binding.element.getAttribute( 'value' );\n}\n\nexport default CheckboxNameBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar CheckboxBinding = Binding.extend({\n\tname: 'checked',\n\n\trender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n\t\tif ( node.attachEvent ) {\n\t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tvar node = this.element.node;\n\n\t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.checked;\n\t}\n});\n\nexport default CheckboxBinding;\n","import runloop from 'global/runloop';\nimport Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar SelectBinding = Binding.extend({\n\tgetInitialValue: function () {\n\t\tvar options = this.element.options, len, i, value, optionWasSelected;\n\n\t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\ti = len = options.length;\n\n\t\tif ( !len ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// take the final selected option...\n\t\twhile ( i-- ) {\n\t\t\tif ( options[i].getAttribute( 'selected' ) ) {\n\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\toptionWasSelected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// or the first non-disabled option, if none are selected\n\t\tif ( !optionWasSelected ) {\n\t\t\twhile ( ++i < len ) {\n\t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t\t// other more expensive work\n\t\tif ( value !== undefined ) {\n\t\t\tthis.element.attributes.value.value = value;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\t// TODO this method is an anomaly... is it necessary?\n\tsetValue: function ( value ) {\n\t\tthis.root.viewmodel.set( this.keypath, value );\n\t},\n\n\tgetValue: function () {\n\t\tvar options, i, len, option, optionValue;\n\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( options[i].selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\treturn optionValue;\n\t\t\t}\n\t\t}\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t}\n});\n\nexport default SelectBinding;\n","import runloop from 'global/runloop';\nimport { arrayContentsMatch } from 'utils/array';\nimport SelectBinding from './SelectBinding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar MultipleSelectBinding = SelectBinding.extend({\n\tgetInitialValue: function () {\n\t\treturn this.element.options\n\t\t\t.filter( option => option.getAttribute( 'selected' ) )\n\t\t\t.map( option => option.getAttribute( 'value' ) );\n\t},\n\n\trender: function () {\n\t\tvar valueFromModel;\n\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\n\t\tvalueFromModel = this.root.viewmodel.get( this.keypath );\n\n\t\tif ( valueFromModel === undefined ) {\n\t\t\t// get value from DOM, if possible\n\t\t\tthis.handleChange();\n\t\t}\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tsetValue: function () {\n\t\tthrow new Error( 'TODO not implemented yet' );\n\t},\n\n\tgetValue: function () {\n\t\tvar selectedValues, options, i, len, option, optionValue;\n\n\t\tselectedValues = [];\n\t\toptions = this.element.node.options;\n\t\tlen = options.length;\n\n\t\tfor ( i=0; i<len; i+=1 ) {\n\t\t\toption = options[i];\n\n\t\t\tif ( option.selected ) {\n\t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n\t\t\t\tselectedValues.push( optionValue );\n\t\t\t}\n\t\t}\n\n\t\treturn selectedValues;\n\t},\n\n\thandleChange: function () {\n\t\tvar attribute, previousValue, value;\n\n\t\tattribute = this.attribute;\n\t\tpreviousValue = attribute.value;\n\n\t\tvalue = this.getValue();\n\n\t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t\t\tSelectBinding.prototype.handleChange.call( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tforceUpdate: function () {\n\t\tvar value = this.getValue();\n\n\t\tif ( value !== undefined ) {\n\t\t\tthis.attribute.locked = true;\n\t\t\trunloop.scheduleTask( () => this.attribute.locked = false );\n\t\t\tthis.root.viewmodel.set( this.keypath, value );\n\t\t}\n\t},\n\n\tupdateModel: function () {\n\t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t\t\tthis.root.viewmodel.set( this.keypath, this.initialValue );\n\t\t}\n\t}\n});\n\nexport default MultipleSelectBinding;\n","import Binding from './Binding';\nimport handleDomEvent from './shared/handleDomEvent';\n\nvar FileListBinding = Binding.extend({\n\trender: function () {\n\t\tthis.element.node.addEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tunrender: function () {\n\t\tthis.element.node.removeEventListener( 'change', handleDomEvent, false );\n\t},\n\n\tgetValue: function () {\n\t\treturn this.element.node.files;\n\t}\n});\n\nexport default FileListBinding;\n","import GenericBinding from './GenericBinding';\n\nexport default GenericBinding.extend({\n\tgetInitialValue: () => undefined,\n\n\tgetValue: function () {\n\t\tvar value = parseFloat( this.element.node.value );\n\t\treturn isNaN( value ) ? undefined : value;\n\t}\n});\n","export default function EventHandler$bubble () {\n\tvar hasAction = this.getAction();\n\n\tif( hasAction && !this.hasListener ) {\n\t\tthis.listen();\n\t}\n\telse if ( !hasAction && this.hasListener ) {\n\t\tthis.unrender();\n\t}\n}\n","export default function EventHandler$getAction () {\n\treturn this.action.toString().trim();\n}\n","import getFunctionFromString from 'shared/getFunctionFromString';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport Fragment from 'virtualdom/Fragment';\nimport eventStack from 'Ractive/prototype/shared/eventStack';\nimport fireEvent from 'Ractive/prototype/shared/fireEvent';\nimport { fatal } from 'utils/log';\n\nvar eventPattern = /^event(?:\\.(.+))?/;\n\nexport default function EventHandler$init ( element, name, template ) {\n\tvar action, refs, ractive;\n\n\tthis.element = element;\n\tthis.root = element.root;\n\tthis.parentFragment = element.parentFragment;\n\tthis.name = name;\n\n\tif ( name.indexOf( '*' ) !== -1 ) {\n\t\tfatal( 'Only component proxy-events may contain \"*\" wildcards, <%s on-%s=\"...\"/> is not valid', element.name, name );\n\t\tthis.invalid = true;\n\t}\n\n\tif ( template.m ) {\n\t\trefs = template.a.r;\n\n\t\t// This is a method call\n\t\tthis.method = template.m;\n\t\tthis.keypaths = [];\n\t\tthis.fn = getFunctionFromString( template.a.s, refs.length );\n\n\t\tthis.parentFragment = element.parentFragment;\n\t\tractive = this.root;\n\n\t\t// Create resolvers for each reference\n\t\tthis.refResolvers = [];\n\t\trefs.forEach(( ref, i ) => {\n\t\t\tlet match;\n\n\t\t\t// special case - the `event` object\n\t\t\tif ( match = eventPattern.exec( ref ) ) {\n\t\t\t\tthis.keypaths[i] = {\n\t\t\t\t\teventObject: true,\n\t\t\t\t\trefinements: match[1] ? match[1].split( '.' ) : []\n\t\t\t\t};\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthis.refResolvers.push( createReferenceResolver( this, ref, keypath => this.resolve( i, keypath ) ) );\n\t\t\t}\n\t\t});\n\n\t\tthis.fire = fireMethodCall;\n\t}\n\n\telse {\n\t\t// Get action ('foo' in 'on-click='foo')\n\t\taction = template.n || template;\n\t\tif ( typeof action !== 'string' ) {\n\t\t\taction = new Fragment({\n\t\t\t\ttemplate: action,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this\n\t\t\t});\n\t\t}\n\n\t\tthis.action = action;\n\n\t\t// Get parameters\n\t\tif ( template.d ) {\n\t\t\tthis.dynamicParams = new Fragment({\n\t\t\t\ttemplate: template.d,\n\t\t\t\troot: this.root,\n\t\t\t\towner: this.element\n\t\t\t});\n\n\t\t\tthis.fire = fireEventWithDynamicParams;\n\t\t} else if ( template.a ) {\n\t\t\tthis.params = template.a;\n\t\t\tthis.fire = fireEventWithParams;\n\t\t}\n\t}\n}\n\n\nfunction fireMethodCall ( event ) {\n\tvar ractive, values, args;\n\n\tractive = this.root;\n\n\tif ( typeof ractive[ this.method ] !== 'function' ) {\n\t\tthrow new Error( 'Attempted to call a non-existent method (\"' + this.method + '\")' );\n\t}\n\n\tvalues = this.keypaths.map( function ( keypath ) {\n\t\tvar value, len, i;\n\n\t\tif ( keypath === undefined ) {\n\t\t\t// not yet resolved\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// TODO the refinements stuff would be better handled at parse time\n\t\tif ( keypath.eventObject ) {\n\t\t\tvalue = event;\n\n\t\t\tif ( len = keypath.refinements.length ) {\n\t\t\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\t\t\tvalue = value[ keypath.refinements[i] ];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = ractive.viewmodel.get( keypath );\n\t\t}\n\n\t\treturn value;\n\t});\n\n\teventStack.enqueue( ractive, event );\n\n\targs = this.fn.apply( null, values );\n\tractive[ this.method ].apply( ractive, args );\n\n\teventStack.dequeue( ractive );\n}\n\nfunction fireEventWithParams ( event ) {\n\tfireEvent( this.root, this.getAction(), { event: event, args: this.params } );\n}\n\nfunction fireEventWithDynamicParams ( event ) {\n\tvar args = this.dynamicParams.getArgsList();\n\n\t// need to strip [] from ends if a string!\n\tif ( typeof args === 'string' ) {\n\t\targs = args.substr( 1, args.length - 2 );\n\t}\n\n\tfireEvent( this.root, this.getAction(), { event: event, args: args } );\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isJsdom } from 'config/environment';\nimport { missingPlugin } from 'config/errors';\nimport genericHandler from '../shared/genericHandler';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar customHandlers = {},\n\ttouchEvents = {\n\t\ttouchstart: true,\n\t\ttouchmove: true,\n\t\ttouchend: true,\n\t\ttouchcancel: true,\n\t\t//not w3c, but supported in some browsers\n\t\ttouchleave: true\n\t};\n\nexport default function EventHandler$listen () {\n\tvar definition, name = this.name;\n\n\tif ( this.invalid ) { return; }\n\n\tif ( definition = findInViewHierarchy( 'events', this.root, name ) ) {\n\t\tthis.custom = definition( this.node, getCustomHandler( name ) );\n\t} else {\n\t\t// Looks like we're dealing with a standard DOM event... but let's check\n\t\tif ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) && !isJsdom ) {\n\n\t\t\t// okay to use touch events if this browser doesn't support them\n\t\t\tif ( !touchEvents[ name ] ) {\n\t\t\t\twarnOnceIfDebug( missingPlugin( name, 'event' ), { node: this.node });\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.node.addEventListener( name, genericHandler, false );\n\t}\n\n\tthis.hasListener = true;\n}\n\nfunction getCustomHandler ( name ) {\n\tif ( !customHandlers[ name ] ) {\n\t\tcustomHandlers[ name ] = function ( event ) {\n\t\t\tvar storage = event.node._ractive;\n\n\t\t\tevent.index = storage.index;\n\t\t\tevent.keypath = storage.keypath.str;\n\t\t\tevent.context = storage.root.viewmodel.get( storage.keypath );\n\n\t\t\tstorage.events[ name ].fire( event );\n\t\t};\n\t}\n\n\treturn customHandlers[ name ];\n}\n","export default function EventHandler$rebind ( oldKeypath, newKeypath ) {\n\tvar fragment;\n\tif ( this.method ) {\n\t\tfragment = this.element.parentFragment;\n\t\tthis.refResolvers.forEach( rebind );\n\n\t\treturn;\n\t}\n\n\tif ( typeof this.action !== 'string' ) {\n\t\trebind( this.action );\n\t}\n\n\tif ( this.dynamicParams ) {\n\t\trebind( this.dynamicParams );\n\t}\n\n\tfunction rebind ( thing ) {\n\t\tthing && thing.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function EventHandler$render () {\n\tthis.node = this.element.node;\n\t// store this on the node itself, so it can be retrieved by a\n\t// universal handler\n\tthis.node._ractive.events[ this.name ] = this;\n\n\tif ( this.method || this.getAction() ) {\n\t\tthis.listen();\n\t}\n}\n","export default function EventHandler$resolve ( index, keypath ) {\n\tthis.keypaths[ index ] = keypath;\n}\n","import bubble from './prototype/bubble';\nimport fire from './prototype/fire';\nimport getAction from './prototype/getAction';\nimport init from './prototype/init';\nimport listen from './prototype/listen';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport resolve from './prototype/resolve';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar EventHandler = function ( element, name, template ) {\n\tthis.init( element, name, template );\n};\n\nEventHandler.prototype = {\n\tbubble: bubble,\n\tfire: fire,\n\tgetAction: getAction,\n\tinit: init,\n\tlisten: listen,\n\trebind: rebind,\n\trender: render,\n\tresolve: resolve,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default EventHandler;\n","import EventHandler from '../../EventHandler/_EventHandler';\n\nexport default function ( element, template ) {\n\tvar i, name, names, handler, result = [];\n\n\tfor ( name in template ) {\n\t\tif ( template.hasOwnProperty( name ) ) {\n\t\t\tnames = name.split( '-' );\n\t\t\ti = names.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\thandler = new EventHandler( element, names[i], template[ name ] );\n\t\t\t\tresult.push( handler );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n","import { fatal } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport Fragment from 'virtualdom/Fragment';\nimport { findInViewHierarchy } from 'shared/registry';\n\nvar Decorator = function ( element, template ) {\n\tvar self = this, ractive, name, fragment;\n\n\tthis.element = element;\n\tthis.root = ractive = element.root;\n\n\tname = template.n || template;\n\n\tif ( typeof name !== 'string' ) {\n\t\tfragment = new Fragment({\n\t\t\ttemplate: name,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tname = fragment.toString();\n\t\tfragment.unbind();\n\n\t\tif ( name === '' ) {\n\t\t\t// empty string okay, just no decorator\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( template.a ) {\n\t\tthis.params = template.a;\n\t}\n\n\telse if ( template.d ) {\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate: template.d,\n\t\t\troot:     ractive,\n\t\t\towner:    element\n\t\t});\n\n\t\tthis.params = this.fragment.getArgsList();\n\n\t\tthis.fragment.bubble = function () {\n\t\t\tthis.dirtyArgs = this.dirtyValue = true;\n\t\t\tself.params = this.getArgsList();\n\n\t\t\tif ( self.ready ) {\n\t\t\t\tself.update();\n\t\t\t}\n\t\t};\n\t}\n\n\tthis.fn = findInViewHierarchy( 'decorators', ractive, name );\n\n\tif ( !this.fn ) {\n\t\tfatal( missingPlugin( name, 'decorator' ) );\n\t}\n};\n\nDecorator.prototype = {\n\tinit: function () {\n\t\tvar node, result, args;\n\n\t\tnode = this.element.node;\n\n\t\tif ( this.params ) {\n\t\t\targs = [ node ].concat( this.params );\n\t\t\tresult = this.fn.apply( this.root, args );\n\t\t} else {\n\t\t\tresult = this.fn.call( this.root, node );\n\t\t}\n\n\t\tif ( !result || !result.teardown ) {\n\t\t\tthrow new Error( 'Decorator definition must return an object with a teardown method' );\n\t\t}\n\n\t\t// TODO does this make sense?\n\t\tthis.actual = result;\n\t\tthis.ready = true;\n\t},\n\n\tupdate: function () {\n\t\tif ( this.actual.update ) {\n\t\t\tthis.actual.update.apply( this.root, this.params );\n\t\t}\n\n\t\telse {\n\t\t\tthis.actual.teardown( true );\n\t\t\tthis.init();\n\t\t}\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\tteardown: function ( updating ) {\n\t\tthis.torndown = true;\n\t\tif ( this.ready ) {\n\t\t\tthis.actual.teardown();\n\t\t}\n\n\t\tif ( !updating && this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t}\n};\n\nexport default Decorator;\n","import { isClient, vendors } from 'config/environment';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\n\nvar prefix, prefixCache, testStyle;\n\nif ( !isClient ) {\n\tprefix = null;\n} else {\n\tprefixCache = {};\n\ttestStyle = createElement( 'div' ).style;\n\n\tprefix = function ( prop ) {\n\t\tvar i, vendor, capped;\n\n\t\tprop = camelCase( prop );\n\n\t\tif ( !prefixCache[ prop ] ) {\n\t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t\t\t\tprefixCache[ prop ] = prop;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\t// test vendors...\n\t\t\t\tcapped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n\t\t\t\ti = vendors.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tvendor = vendors[i];\n\t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn prefixCache[ prop ];\n\t};\n}\n\nexport default prefix;\n","export default function ( hyphenatedStr ) {\n\treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t\treturn $1.toUpperCase();\n\t});\n}\n","import legacy from 'legacy';\nimport { isClient } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport prefix from '../helpers/prefix';\n\nvar getStyle, getComputedStyle;\n\nif ( !isClient ) {\n\tgetStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tgetStyle = function ( props ) {\n\t\tvar computedStyle, styles, i, prop, value;\n\n\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\tif ( typeof props === 'string' ) {\n\t\t\tvalue = computedStyle[ prefix( props ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( !isArray( props ) ) {\n\t\t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t\t}\n\n\t\tstyles = {};\n\n\t\ti = props.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = props[i];\n\t\t\tvalue = computedStyle[ prefix( prop ) ];\n\t\t\tif ( value === '0px' ) {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tstyles[ prop ] = value;\n\t\t}\n\n\t\treturn styles;\n\t};\n}\n\nexport default getStyle;\n","import prefix from '../helpers/prefix';\n\nexport default function ( style, value ) {\n\tvar prop;\n\n\tif ( typeof style === 'string' ) {\n\t\tthis.node.style[ prefix( style ) ] = value;\n\t}\n\n\telse {\n\t\tfor ( prop in style ) {\n\t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t\t\t\tthis.node.style[ prefix( prop ) ] = style[ prop ];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport getTime from 'utils/getTime';\nimport animations from 'shared/animations';\n\n// TODO what happens if a transition is aborted?\n// TODO use this with Animation to dedupe some code?\n\nvar Ticker = function ( options ) {\n\tvar easing;\n\n\tthis.duration = options.duration;\n\tthis.step = options.step;\n\tthis.complete = options.complete;\n\n\t// easing\n\tif ( typeof options.easing === 'string' ) {\n\t\teasing = options.root.easing[ options.easing ];\n\n\t\tif ( !easing ) {\n\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t\t\teasing = linear;\n\t\t}\n\t} else if ( typeof options.easing === 'function' ) {\n\t\teasing = options.easing;\n\t} else {\n\t\teasing = linear;\n\t}\n\n\tthis.easing = easing;\n\n\tthis.start = getTime();\n\tthis.end = this.start + this.duration;\n\n\tthis.running = true;\n\tanimations.add( this );\n};\n\nTicker.prototype = {\n\ttick: function ( now ) {\n\t\tvar elapsed, eased;\n\n\t\tif ( !this.running ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( now > this.end ) {\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( 1 );\n\t\t\t}\n\n\t\t\tif ( this.complete ) {\n\t\t\t\tthis.complete( 1 );\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\telapsed = now - this.start;\n\t\teased = this.easing( elapsed / this.duration );\n\n\t\tif ( this.step ) {\n\t\t\tthis.step( eased );\n\t\t}\n\n\t\treturn true;\n\t},\n\n\tstop: function () {\n\t\tif ( this.abort ) {\n\t\t\tthis.abort();\n\t\t}\n\n\t\tthis.running = false;\n\t}\n};\n\nexport default Ticker;\nfunction linear ( t ) { return t; }\n","import { isClient } from 'config/environment';\nimport { warnIfDebug } from 'utils/log';\nimport { createElement } from 'utils/dom';\nimport camelCase from 'utils/camelCase';\nimport interpolate from 'shared/interpolate';\nimport Ticker from 'shared/Ticker';\nimport prefix from '../../helpers/prefix';\nimport unprefix from '../../helpers/unprefix';\nimport hyphenate from '../../helpers/hyphenate';\n\nvar createTransitions,\n\ttestStyle,\n\tTRANSITION,\n\tTRANSITIONEND,\n\tCSS_TRANSITIONS_ENABLED,\n\tTRANSITION_DURATION,\n\tTRANSITION_PROPERTY,\n\tTRANSITION_TIMING_FUNCTION,\n\tcanUseCssTransitions = {},\n\tcannotUseCssTransitions = {};\n\nif ( !isClient ) {\n\tcreateTransitions = null;\n} else {\n\ttestStyle = createElement( 'div' ).style;\n\n\t// determine some facts about our environment\n\t(function() {\n\t\tif ( testStyle.transition !== undefined ) {\n\t\t\tTRANSITION = 'transition';\n\t\t\tTRANSITIONEND = 'transitionend';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else if ( testStyle.webkitTransition !== undefined ) {\n\t\t\tTRANSITION = 'webkitTransition';\n\t\t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t\t\tCSS_TRANSITIONS_ENABLED = true;\n\t\t} else {\n\t\t\tCSS_TRANSITIONS_ENABLED = false;\n\t\t}\n\t}());\n\n\tif ( TRANSITION ) {\n\t\tTRANSITION_DURATION = TRANSITION + 'Duration';\n\t\tTRANSITION_PROPERTY = TRANSITION + 'Property';\n\t\tTRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';\n\t}\n\n\tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n\t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t\t// TODO use a fastdom-style mechanism?\n\t\tsetTimeout( function () {\n\n\t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n\t\t\tcheckComplete = function () {\n\t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t\t\t\t\tt.root.fire( t.name + ':end', t.node, t.isIntro );\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// this is used to keep track of which elements can use CSS to animate\n\t\t\t// which properties\n\t\t\thashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n\t\t\tt.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );\n\t\t\tt.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t\t\tt.node.style[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n\t\t\ttransitionEndHandler = function ( event ) {\n\t\t\t\tvar index;\n\n\t\t\t\tindex = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\t\t\tif ( index !== -1 ) {\n\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t}\n\n\t\t\t\tif ( changedProperties.length ) {\n\t\t\t\t\t// still transitioning...\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n\t\t\tsetTimeout( function () {\n\t\t\t\tvar i = changedProperties.length, hash, originalValue, index, propertiesToTransitionInJs = [], prop, suffix;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tprop = changedProperties[i];\n\t\t\t\t\thash = hashPrefix + prop;\n\n\t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = to[ prop ];\n\n\t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t\t\t\t\t\t// this tag/property combo, find out now\n\t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n\t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t\t\t\t\t\t\t// the current style will be different from the target style\n\t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n\t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t\t\tt.node.style[ prefix( prop ) ] = originalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t\t\t\t\t\tif ( originalValue === undefined ) {\n\t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t\t\t\t\t\t// will get confused\n\t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t\t\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n\t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\n\t\t\t\t\t\t// ...then kick off a timer-based transition\n\t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t\t\t\t\t\t\tname: prefix( prop ),\n\t\t\t\t\t\t\tinterpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),\n\t\t\t\t\t\t\tsuffix: suffix\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\t// javascript transitions\n\t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t\t\t\t\tnew Ticker({\n\t\t\t\t\t\troot: t.root,\n\t\t\t\t\t\tduration: options.duration,\n\t\t\t\t\t\teasing: camelCase( options.easing || '' ),\n\t\t\t\t\t\tstep: function ( pos ) {\n\t\t\t\t\t\t\tvar prop, i;\n\n\t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n\t\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n\t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete: function () {\n\t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tjsTransitionsComplete = true;\n\t\t\t\t}\n\n\n\t\t\t\tif ( !changedProperties.length ) {\n\t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t\t\t\t\t// the fact that it will never fire\n\t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\t\t\t\tcssTransitionsComplete = true;\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}, 0 );\n\t\t}, options.delay || 0 );\n\t};\n}\n\nexport default createTransitions;\n","import { vendors } from 'config/environment';\n\nvar unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\nexport default function ( prop ) {\n\treturn prop.replace( unprefixPattern, '' );\n}\n","import { vendors } from 'config/environment';\n\nvar vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\nexport default function ( str ) {\n\tvar hyphenated;\n\n\tif ( !str ) {\n\t\treturn ''; // edge case\n\t}\n\n\tif ( vendorPattern.test( str ) ) {\n\t\tstr = '-' + str;\n\t}\n\n\thyphenated = str.replace( /[A-Z]/g, function ( match ) {\n\t\treturn '-' + match.toLowerCase();\n\t});\n\n\treturn hyphenated;\n}\n","import { vendors } from 'config/environment';\n\nvar hidden, vendor, prefix, i, visibility;\n\nif ( typeof document !== 'undefined' ) {\n\thidden = 'hidden';\n\n\tvisibility = {};\n\n\tif ( hidden in document ) {\n\t\tprefix = '';\n\t} else {\n\t\ti = vendors.length;\n\t\twhile ( i-- ) {\n\t\t\tvendor = vendors[i];\n\t\t\thidden = vendor + 'Hidden';\n\n\t\t\tif ( hidden in document ) {\n\t\t\t\tprefix = vendor;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( prefix !== undefined ) {\n\t\tdocument.addEventListener( prefix + 'visibilitychange', onChange );\n\n\t\t// initialise\n\t\tonChange();\n\t}\n\n\telse {\n        // gah, we're in an old browser\n        if ( 'onfocusout' in document ) {\n        \tdocument.addEventListener( 'focusout', onHide );\n        \tdocument.addEventListener( 'focusin', onShow );\n        }\n\n        else {\n        \twindow.addEventListener( 'pagehide', onHide );\n        \twindow.addEventListener( 'blur', onHide );\n\n        \twindow.addEventListener( 'pageshow', onShow );\n        \twindow.addEventListener( 'focus', onShow );\n        }\n\n        visibility.hidden = false; // until proven otherwise. Not ideal but hey\n    }\n}\n\nfunction onChange () {\n\tvisibility.hidden = document[ hidden ];\n}\n\nfunction onHide () {\n\tvisibility.hidden = true;\n}\n\nfunction onShow () {\n\tvisibility.hidden = false;\n}\n\nexport default visibility;\n","import { warnOnceIfDebug } from 'utils/log';\nimport { isClient } from 'config/environment';\nimport legacy from 'legacy';\nimport prefix from 'virtualdom/items/Element/Transition/helpers/prefix';\nimport Promise from 'utils/Promise';\nimport createTransitions from './createTransitions';\nimport visibility from './visibility';\n\nvar animateStyle, getComputedStyle, resolved;\n\nif ( !isClient ) {\n\tanimateStyle = null;\n} else {\n\tgetComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n\tanimateStyle = function ( style, value, options ) {\n\t\tvar to;\n\n\t\tif ( arguments.length === 4 ) {\n\t\t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t\t}\n\n\t\t// Special case - page isn't visible. Don't animate anything, because\n\t\t// that way you'll never get CSS transitionend events\n\t\tif ( visibility.hidden ) {\n\t\t\tthis.setStyle( style, value );\n\t\t\treturn resolved || ( resolved = Promise.resolve() );\n\t\t}\n\n\t\tif ( typeof style === 'string' ) {\n\t\t\tto = {};\n\t\t\tto[ style ] = value;\n\t\t} else {\n\t\t\tto = style;\n\n\t\t\t// shuffle arguments\n\t\t\toptions = value;\n\t\t}\n\n\t\t// As of 0.3.9, transition authors should supply an `option` object with\n\t\t// `duration` and `easing` properties (and optional `delay`), plus a\n\t\t// callback function that gets called after the animation completes\n\n\t\t// TODO remove this check in a future version\n\t\tif ( !options ) {\n\t\t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t\t\toptions = this;\n\t\t}\n\n\t\tvar promise = new Promise( resolve => {\n\t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n\t\t\t// Edge case - if duration is zero, set style synchronously and complete\n\t\t\tif ( !options.duration ) {\n\t\t\t\tthis.setStyle( to );\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get a list of the properties we're animating\n\t\t\tpropertyNames = Object.keys( to );\n\t\t\tchangedProperties = [];\n\n\t\t\t// Store the current styles\n\t\t\tcomputedStyle = getComputedStyle( this.node );\n\n\t\t\tfrom = {};\n\t\t\ti = propertyNames.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tprop = propertyNames[i];\n\t\t\t\tcurrent = computedStyle[ prefix( prop ) ];\n\n\t\t\t\tif ( current === '0px' ) {\n\t\t\t\t\tcurrent = 0;\n\t\t\t\t}\n\n\t\t\t\t// we need to know if we're actually changing anything\n\t\t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t\t\t\t\tchangedProperties.push( prop );\n\n\t\t\t\t\t// make the computed style explicit, so we can animate where\n\t\t\t\t\t// e.g. height='auto'\n\t\t\t\t\tthis.node.style[ prefix( prop ) ] = current;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not actually changing anything, the transitionend event\n\t\t\t// will never fire! So we complete early\n\t\t\tif ( !changedProperties.length ) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcreateTransitions( this, to, options, changedProperties, resolve );\n\t\t});\n\n\t\treturn promise;\n\t};\n}\n\nexport default animateStyle;\n","import { fillGaps } from 'utils/object';\n\nexport default function ( params, defaults ) {\n\tif ( typeof params === 'number' ) {\n\t\tparams = { duration: params };\n\t}\n\n\telse if ( typeof params === 'string' ) {\n\t\tif ( params === 'slow' ) {\n\t\t\tparams = { duration: 600 };\n\t\t} else if ( params === 'fast' ) {\n\t\t\tparams = { duration: 200 };\n\t\t} else {\n\t\t\tparams = { duration: 400 };\n\t\t}\n\t} else if ( !params ) {\n\t\tparams = {};\n\t}\n\n\treturn fillGaps( {}, params, defaults );\n}\n","export default function Transition$start () {\n\tvar node, originalStyle, completed;\n\n\tnode = this.node = this.element.node;\n\toriginalStyle = node.getAttribute( 'style' );\n\n\t// create t.complete() - we don't want this on the prototype,\n\t// because we don't want `this` silliness when passing it as\n\t// an argument\n\tthis.complete = noReset => {\n\t\tif ( completed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !noReset && this.isIntro ) {\n\t\t\tresetStyle( node, originalStyle);\n\t\t}\n\n\t\tnode._ractive.transition = null;\n\t\tthis._manager.remove( this );\n\n\t\tcompleted = true;\n\t};\n\n\t// If the transition function doesn't exist, abort\n\tif ( !this._fn ) {\n\t\tthis.complete();\n\t\treturn;\n\t}\n\n\tthis._fn.apply( this.root, [ this ].concat( this.params ) );\n}\n\nfunction resetStyle ( node, style ) {\n\tif ( style ) {\n\t\tnode.setAttribute( 'style', style );\n\t} else {\n\n\t\t// Next line is necessary, to remove empty style attribute!\n\t\t// See http://stackoverflow.com/a/7167553\n\t\tnode.getAttribute( 'style' );\n\t\tnode.removeAttribute( 'style' );\n\t}\n}\n","import init from './prototype/init';\nimport getStyle from './prototype/getStyle';\nimport setStyle from './prototype/setStyle';\nimport animateStyle from './prototype/animateStyle/_animateStyle';\nimport processParams from './prototype/processParams';\nimport start from './prototype/start';\n\nvar Transition = function ( owner, template, isIntro ) {\n\tthis.init( owner, template, isIntro );\n};\n\nTransition.prototype = {\n\tinit: init,\n\tstart: start,\n\tgetStyle: getStyle,\n\tsetStyle: setStyle,\n\tanimateStyle: animateStyle,\n\tprocessParams: processParams\n};\n\nexport default Transition;\n","import { namespaces } from 'config/environment';\nimport { isArray } from 'utils/is';\nimport { warnIfDebug } from 'utils/log';\nimport { create, defineProperty } from 'utils/object';\nimport { createElement } from 'utils/dom';\nimport noop from 'utils/noop';\nimport runloop from 'global/runloop';\nimport getInnerContext from 'shared/getInnerContext';\nimport { render as renderImage } from '../special/img';\nimport { render as renderForm } from '../special/form';\nimport Transition from '../Transition/_Transition';\n\nvar updateCss, updateScript;\n\nupdateCss = function () {\n\tvar node = this.node, content = this.fragment.toString( false );\n\n\t// IE8 has no styleSheet unless there's a type text/css\n\tif ( window && window.appearsToBeIELessEqual8 ) {\n\t\tnode.type = 'text/css';\n\t}\n\n\tif ( node.styleSheet ) {\n\t\tnode.styleSheet.cssText = content;\n\t} else {\n\n\t\twhile ( node.hasChildNodes() ) {\n\t\t\tnode.removeChild( node.firstChild );\n\t\t}\n\n\t\tnode.appendChild( document.createTextNode(content) );\n\t}\n};\n\nupdateScript = function () {\n\tif ( !this.node.type || this.node.type === 'text/javascript' ) {\n\t\twarnIfDebug( 'Script tag was updated. This does not cause the code to be re-evaluated!', { ractive: this.root });\n\t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n\t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n\t\t// But this would be a terrible idea with unpredictable results, so let's not.\n\t}\n\n\tthis.node.text = this.fragment.toString( false );\n};\n\nexport default function Element$render () {\n\tvar root = this.root, namespace, node, transition;\n\n\tnamespace = getNamespace( this );\n\tnode = this.node = createElement( this.name, namespace );\n\n\t// Is this a top-level node of a component? If so, we may need to add\n\t// a data-ractive-css attribute, for CSS encapsulation\n\tif ( this.parentFragment.cssIds ) {\n\t\tthis.node.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( x => `{${x}}` ).join( ' ' ) );\n\t}\n\n\t// Add _ractive property to the node - we use this object to store stuff\n\t// related to proxy events, two-way bindings etc\n\tdefineProperty( this.node, '_ractive', {\n\t\tvalue: {\n\t\t\tproxy: this,\n\t\t\tkeypath: getInnerContext( this.parentFragment ),\n\t\t\tevents: create( null ),\n\t\t\troot: root\n\t\t}\n\t});\n\n\t// Render attributes\n\tthis.attributes.forEach( a => a.render( node ) );\n\tthis.conditionalAttributes.forEach( a => a.render( node ) );\n\n\t// Render children\n\tif ( this.fragment ) {\n\t\t// Special case - <script> element\n\t\tif ( this.name === 'script' ) {\n\t\t\tthis.bubble = updateScript;\n\t\t\tthis.node.text = this.fragment.toString( false ); // bypass warning initially\n\t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n\t\t}\n\n\t\t// Special case - <style> element\n\t\telse if ( this.name === 'style' ) {\n\t\t\tthis.bubble = updateCss;\n\t\t\tthis.bubble();\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\t// Special case - contenteditable\n\t\telse if ( this.binding && this.getAttribute( 'contenteditable' ) ) {\n\t\t\tthis.fragment.unrender = noop;\n\t\t}\n\n\t\telse {\n\t\t\tthis.node.appendChild( this.fragment.render() );\n\t\t}\n\t}\n\n\t// deal with two-way bindings\n\tif ( this.binding ) {\n\t\tthis.binding.render();\n\t\tthis.node._ractive.binding = this.binding;\n\t}\n\n\t// Add proxy event handlers\n\tif ( this.eventHandlers ) {\n\t\tthis.eventHandlers.forEach( h => h.render() );\n\t}\n\n\tif ( this.name === 'option' ) {\n\t\tprocessOption( this );\n\t}\n\n\t// Special cases\n\tif ( this.name === 'img' ) {\n\t\t// if this is an <img>, and we're in a crap browser, we may\n\t\t// need to prevent it from overriding width and height when\n\t\t// it loads the src\n\t\trenderImage( this );\n\t} else if ( this.name === 'form' ) {\n\t\t// forms need to keep track of their bindings, in case of reset\n\t\trenderForm( this );\n\t} else if ( this.name === 'input' || this.name === 'textarea' ) {\n\t\t// inputs and textareas should store their initial value as\n\t\t// `defaultValue` in case of reset\n\t\tthis.node.defaultValue = this.node.value;\n\t} else if ( this.name === 'option' ) {\n\t\t// similarly for option nodes\n\t\tthis.node.defaultSelected = this.node.selected;\n\t}\n\n\t// apply decorator(s)\n\tif ( this.decorator && this.decorator.fn ) {\n\t\trunloop.scheduleTask( () => {\n\t\t\tif ( !this.decorator.torndown ) {\n\t\t\t\tthis.decorator.init();\n\t\t\t}\n\t\t}, true );\n\t}\n\n\t// trigger intro transition\n\tif ( root.transitionsEnabled && this.intro ) {\n\t\ttransition = new Transition ( this, this.intro, true );\n\t\trunloop.registerTransition( transition );\n\t\trunloop.scheduleTask( () => transition.start(), true );\n\n\t\tthis.transition = transition;\n\t}\n\n\tif ( this.node.autofocus ) {\n\t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n\t\t// with dynamically-generated elements having autofocus, and they won't\n\t\t// allow you to programmatically focus the element until it's in the DOM\n\t\trunloop.scheduleTask( () => this.node.focus(), true );\n\t}\n\n\tupdateLiveQueries( this );\n\treturn this.node;\n}\n\nfunction getNamespace ( element ) {\n\tvar namespace, xmlns, parent;\n\n\t// Use specified namespace...\n\tif ( xmlns = element.getAttribute( 'xmlns' ) ) {\n\t\tnamespace = xmlns;\n\t}\n\n\t// ...or SVG namespace, if this is an <svg> element\n\telse if ( element.name === 'svg' ) {\n\t\tnamespace = namespaces.svg;\n\t}\n\n\telse if ( parent = element.parent ) {\n\t\t// ...or HTML, if the parent is a <foreignObject>\n\t\tif ( parent.name === 'foreignObject' ) {\n\t\t\tnamespace = namespaces.html;\n\t\t}\n\n\t\t// ...or inherit from the parent node\n\t\telse {\n\t\t\tnamespace = parent.node.namespaceURI;\n\t\t}\n\t}\n\n\telse {\n\t\tnamespace = element.root.el.namespaceURI;\n\t}\n\n\treturn namespace;\n}\n\nfunction processOption ( option ) {\n\tvar optionValue, selectValue, i;\n\n\tif ( !option.select ) {\n\t\treturn;\n\t}\n\n\tselectValue = option.select.getAttribute( 'value' );\n\tif ( selectValue === undefined ) {\n\t\treturn;\n\t}\n\n\toptionValue = option.getAttribute( 'value' );\n\n\tif ( option.select.node.multiple && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( optionValue == selectValue[i] ) {\n\t\t\t\toption.node.selected = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toption.node.selected = ( optionValue == selectValue );\n\t}\n}\n\nfunction updateLiveQueries ( element ) {\n\tvar instance, liveQueries, i, selector, query;\n\n\t// Does this need to be added to any live queries?\n\tinstance = element.root;\n\n\tdo {\n\t\tliveQueries = instance._liveQueries;\n\n\t\ti = liveQueries.length;\n\t\twhile ( i-- ) {\n\t\t\tselector = liveQueries[i];\n\t\t\tquery = liveQueries[ '_' + selector ];\n\n\t\t\tif ( query._test( element ) ) {\n\t\t\t\t// keep register of applicable selectors, for when we teardown\n\t\t\t\t( element.liveQueries || ( element.liveQueries = [] ) ).push( query );\n\t\t\t}\n\t\t}\n\t} while ( instance = instance.parent );\n}\n","import { escapeHtml, voidElementNames } from 'utils/html';\nimport { isArray } from 'utils/is';\n\nexport default function () {\n\tvar str, escape;\n\n\tif ( this.template.y ) {\n\t\t// DOCTYPE declaration\n\t\treturn '<!DOCTYPE' + this.template.dd + '>';\n\t}\n\n\tstr = '<' + this.template.e;\n\n\tstr += this.attributes.map( stringifyAttribute ).join( '' )\n\t     + this.conditionalAttributes.map( stringifyAttribute ).join( '' );\n\n\t// Special case - selected options\n\tif ( this.name === 'option' && optionIsSelected( this ) ) {\n\t\tstr += ' selected';\n\t}\n\n\t// Special case - two-way radio name bindings\n\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t\tstr += ' checked';\n\t}\n\n\tstr += '>';\n\n\t// Special case - textarea\n\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t}\n\n\t// Special case - contenteditable\n\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t}\n\n\tif ( this.fragment ) {\n\t\tescape = ( this.name !== 'script' && this.name !== 'style' );\n\t\tstr += this.fragment.toString( escape );\n\t}\n\n\t// add a closing tag if this isn't a void element\n\tif ( !voidElementNames.test( this.template.e ) ) {\n\t\tstr += '</' + this.template.e + '>';\n\t}\n\n\treturn str;\n}\n\nfunction optionIsSelected ( element ) {\n\tvar optionValue, selectValue, i;\n\n\toptionValue = element.getAttribute( 'value' );\n\n\tif ( optionValue === undefined || !element.select ) {\n\t\treturn false;\n\t}\n\n\tselectValue = element.select.getAttribute( 'value' );\n\n\tif ( selectValue == optionValue ) {\n\t\treturn true;\n\t}\n\n\tif ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t\ti = selectValue.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( selectValue[i] == optionValue ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction inputIsCheckedRadio ( element ) {\n\tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n\tattributes = element.attributes;\n\n\ttypeAttribute  = attributes.type;\n\tvalueAttribute = attributes.value;\n\tnameAttribute  = attributes.name;\n\n\tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t\treturn;\n\t}\n\n\tif ( valueAttribute.value === nameAttribute.interpolator.value ) {\n\t\treturn true;\n\t}\n}\n\nfunction stringifyAttribute ( attribute ) {\n\tvar str = attribute.toString();\n\treturn str ? ' ' + str : '';\n}\n","import bubble from './prototype/bubble';\nimport detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport getAttribute from './prototype/getAttribute';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Element = function ( options ) {\n\tthis.init( options );\n};\n\nElement.prototype = {\n\tbubble: bubble,\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tgetAttribute: getAttribute,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Element;\n","import { lastItem } from 'utils/array';\n\nvar empty = /^\\s*$/, leadingWhitespace = /^\\s*/;\n\nexport default function ( str ) {\n\tvar lines, firstLine, lastLine, minIndent;\n\n\tlines = str.split( '\\n' );\n\n\t// remove first and last line, if they only contain whitespace\n\tfirstLine = lines[0];\n\tif ( firstLine !== undefined && empty.test( firstLine ) ) {\n\t\tlines.shift();\n\t}\n\n\tlastLine = lastItem( lines );\n\tif ( lastLine !== undefined && empty.test( lastLine ) ) {\n\t\tlines.pop();\n\t}\n\n\tminIndent = lines.reduce( reducer, null );\n\n\tif ( minIndent ) {\n\t\tstr = lines.map( function ( line ) {\n\t\t\treturn line.replace( minIndent, '' );\n\t\t}).join( '\\n' );\n\t}\n\n\treturn str;\n}\n\nfunction reducer ( previous, line ) {\n\tvar lineIndent = leadingWhitespace.exec( line )[0];\n\n\tif ( previous === null || ( lineIndent.length < previous.length ) ) {\n\t\treturn lineIndent;\n\t}\n\n\treturn previous;\n}\n","export default function ( string, indent ) {\n\tvar indented;\n\n\tif ( !indent ) {\n\t\treturn string;\n\t}\n\n\tindented = string.split( '\\n' ).map( function ( line, notFirstLine ) {\n\t\treturn notFirstLine ? indent + line : line;\n\t}).join( '\\n' );\n\n\treturn indented;\n}\n","import { warnOnceIfDebug } from 'utils/log';\nimport { PARTIAL, TEXT } from 'config/types';\nimport runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\nimport Mustache from '../shared/Mustache/_Mustache';\nimport rebind from '../shared/Mustache/rebind';\nimport unbind from '../shared/unbind';\nimport getPartialTemplate from './getPartialTemplate';\nimport applyIndent from './applyIndent';\n\nlet missingPartialMessage = 'Could not find template for partial \"%s\"';\n\nlet Partial = function ( options ) {\n\tvar parentFragment, template;\n\n\tparentFragment = this.parentFragment = options.parentFragment;\n\n\tthis.root = parentFragment.root;\n\tthis.type = PARTIAL;\n\tthis.index = options.index;\n\tthis.name = options.template.r;\n\tthis.rendered = false;\n\n\tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n\tMustache.init( this, options );\n\n\t// If this didn't resolve, it most likely means we have a named partial\n\t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n\t// whose name is the value of `foo`')\n\tif ( !this.keypath ) {\n\t\tif ( template = getPartialTemplate( this.root, this.name, parentFragment ) ) {\n\t\t\tunbind.call( this ); // prevent any further changes\n\t\t\tthis.isNamed = true;\n\t\t\tthis.setTemplate( template );\n\t\t} else {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name );\n\t\t}\n\t}\n};\n\nPartial.prototype = {\n\tbubble () {\n\t\tthis.parentFragment.bubble();\n\t},\n\n\tdetach () {\n\t\treturn this.fragment.detach();\n\t},\n\n\tfind ( selector ) {\n\t\treturn this.fragment.find( selector );\n\t},\n\n\tfindAll ( selector, query ) {\n\t\treturn this.fragment.findAll( selector, query );\n\t},\n\n\tfindComponent ( selector ) {\n\t\treturn this.fragment.findComponent( selector );\n\t},\n\n\tfindAllComponents ( selector, query ) {\n\t\treturn this.fragment.findAllComponents( selector, query );\n\t},\n\n\tfirstNode () {\n\t\treturn this.fragment.firstNode();\n\t},\n\n\tfindNextNode () {\n\t\treturn this.parentFragment.findNextNode( this );\n\t},\n\n\tgetPartialName () {\n\t\tif ( this.isNamed && this.name ) return this.name;\n\t\telse if ( this.value === undefined ) return this.name;\n\t\telse return this.value;\n\t},\n\n\tgetValue () {\n\t\treturn this.fragment.getValue();\n\t},\n\n\trebind ( oldKeypath, newKeypath ) {\n\t\t// named partials aren't bound, so don't rebind\n\t\tif ( !this.isNamed ) {\n\t\t\trebind.call( this, oldKeypath, newKeypath );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t\t}\n\t},\n\n\trender () {\n\t\tthis.docFrag = document.createDocumentFragment();\n\t\tthis.update();\n\n\t\tthis.rendered = true;\n\t\treturn this.docFrag;\n\t},\n\n\tresolve: Mustache.resolve,\n\n\tsetValue ( value ) {\n\t\tvar template;\n\n\t\tif ( value !== undefined && value === this.value ) {\n\t\t\t// nothing has changed, so no work to be done\n\t\t\treturn;\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\ttemplate = getPartialTemplate( this.root, '' + value, this.parentFragment );\n\t\t}\n\n\t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n\t\t// name of both a data property (whose value ISN'T the name of a partial)\n\t\t// and a partial. In those cases, this becomes a named partial\n\t\tif ( !template && this.name && ( template = getPartialTemplate( this.root, this.name, this.parentFragment ) ) ) {\n\t\t\tunbind.call( this );\n\t\t\tthis.isNamed = true;\n\t\t}\n\n\t\tif ( !template ) {\n\t\t\twarnOnceIfDebug( missingPartialMessage, this.name, { ractive: this.root });\n\t\t}\n\n\t\tthis.value = value;\n\n\t\tthis.setTemplate( template || [] );\n\n\t\tthis.bubble();\n\n\t\tif ( this.rendered ) {\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tsetTemplate ( template ) {\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t\tif ( this.rendered ) {\n\t\t\t\tthis.fragmentToUnrender = this.fragment;\n\t\t\t}\n\t\t}\n\n\t\tthis.fragment = new Fragment({\n\t\t\ttemplate,\n\t\t\troot: this.root,\n\t\t\towner: this,\n\t\t\tpElement: this.parentFragment.pElement\n\t\t});\n\n\t\tthis.fragmentToRender = this.fragment;\n\t},\n\n\ttoString ( toString ) {\n\t\tvar string, previousItem, lastLine, match;\n\n\t\tstring = this.fragment.toString( toString );\n\n\t\tpreviousItem = this.parentFragment.items[ this.index - 1 ];\n\n\t\tif ( !previousItem || ( previousItem.type !== TEXT ) ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tlastLine = previousItem.text.split( '\\n' ).pop();\n\n\t\tif ( match = /^\\s+$/.exec( lastLine ) ) {\n\t\t\treturn applyIndent( string, match[0] );\n\t\t}\n\n\t\treturn string;\n\t},\n\n\tunbind () {\n\t\tif ( !this.isNamed ) { // dynamic partial - need to unbind self\n\t\t\tunbind.call( this );\n\t\t}\n\n\t\tif ( this.fragment ) {\n\t\t\tthis.fragment.unbind();\n\t\t}\n\t},\n\n\tunrender ( shouldDestroy ) {\n\t\tif ( this.rendered ) {\n\t\t\tif ( this.fragment ) {\n\t\t\t\tthis.fragment.unrender( shouldDestroy );\n\t\t\t}\n\t\t\tthis.rendered = false;\n\t\t}\n\t},\n\n\tupdate() {\n\t\tvar target, anchor;\n\n\t\tif ( this.fragmentToUnrender ) {\n\t\t\tthis.fragmentToUnrender.unrender( true );\n\t\t\tthis.fragmentToUnrender = null;\n\t\t}\n\n\t\tif ( this.fragmentToRender ) {\n\t\t\tthis.docFrag.appendChild( this.fragmentToRender.render() );\n\t\t\tthis.fragmentToRender = null;\n\t\t}\n\n\t\tif ( this.rendered ) {\n\t\t\ttarget = this.parentFragment.getNode();\n\t\t\tanchor = this.parentFragment.findNextNode( this );\n\t\t\ttarget.insertBefore( this.docFrag, anchor );\n\t\t}\n\t}\n};\n\nexport default Partial;\n","import runloop from 'global/runloop';\nimport { defineProperty } from 'utils/object';\nimport getNewIndices from 'shared/getNewIndices';\nimport processWrapper from './processWrapper';\n\nvar patchedArrayProto = [],\n\tmutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ],\n\ttestObj,\n\tpatchArrayMethods,\n\tunpatchArrayMethods;\n\nmutatorMethods.forEach( function ( methodName ) {\n\tvar method = function ( ...args ) {\n\t\tvar newIndices,\n\t\t\tresult,\n\t\t\twrapper,\n\t\t\ti;\n\n\t\tnewIndices = getNewIndices( this, methodName, args );\n\n\t\t// apply the underlying method\n\t\tresult = Array.prototype[ methodName ].apply( this, arguments );\n\n\t\t// trigger changes\n\t\trunloop.start();\n\n\t\tthis._ractive.setting = true;\n\t\ti = this._ractive.wrappers.length;\n\t\twhile ( i-- ) {\n\t\t\twrapper = this._ractive.wrappers[i];\n\n\t\t\trunloop.addRactive( wrapper.root );\n\t\t\tprocessWrapper( wrapper, this, methodName, newIndices );\n\t\t}\n\n\t\trunloop.end();\n\n\t\tthis._ractive.setting = false;\n\t\treturn result;\n\t};\n\n\tdefineProperty( patchedArrayProto, methodName, {\n\t\tvalue: method\n\t});\n});\n\n// can we use prototype chain injection?\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\ntestObj = {};\n\nif ( testObj.__proto__ ) {\n\t// yes, we can\n\tpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = patchedArrayProto;\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tarray.__proto__ = Array.prototype;\n\t};\n}\n\nelse {\n\t// no, we can't\n\tpatchArrayMethods = function ( array ) {\n\t\tvar i, methodName;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tmethodName = mutatorMethods[i];\n\t\t\tdefineProperty( array, methodName, {\n\t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t};\n\n\tunpatchArrayMethods = function ( array ) {\n\t\tvar i;\n\n\t\ti = mutatorMethods.length;\n\t\twhile ( i-- ) {\n\t\t\tdelete array[ mutatorMethods[i] ];\n\t\t}\n\t};\n}\n\npatchArrayMethods.unpatch = unpatchArrayMethods;\nexport default patchArrayMethods;\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Component$detach () {\n\tvar detached = this.instance.fragment.detach();\n\tdetachHook.fire( this.instance );\n\treturn detached;\n}\n","export default function Component$find ( selector ) {\n\treturn this.instance.fragment.find( selector );\n}\n","export default function Component$findAll ( selector, query ) {\n\treturn this.instance.fragment.findAll( selector, query );\n}\n","export default function Component$findAllComponents ( selector, query ) {\n\tquery._test( this, true );\n\n\tif ( this.instance.fragment ) {\n\t\tthis.instance.fragment.findAllComponents( selector, query );\n\t}\n}\n","export default function Component$findComponent ( selector ) {\n\tif ( !selector || ( selector === this.name ) ) {\n\t\treturn this.instance;\n\t}\n\n\tif ( this.instance.fragment ) {\n\t\treturn this.instance.fragment.findComponent( selector );\n\t}\n\n\treturn null;\n}\n","export default function Component$findNextNode () {\n\treturn this.parentFragment.findNextNode( this );\n}\n","export default function Component$firstNode () {\n\tif ( this.rendered ) {\n\t\treturn this.instance.fragment.firstNode();\n\t}\n\n\treturn null;\n}\n","export default function ( wrapper, array, methodName, newIndices ) {\n\tvar { root, keypath } = wrapper;\n\n\tif ( !!newIndices ) {\n\t\troot.viewmodel.smartUpdate( keypath, array, newIndices );\n\t} else {\n\t\t// If this is a sort or reverse, we just do root.set()...\n\t\t// TODO use merge logic?\n\t\troot.viewmodel.mark( keypath );\n\t}\n}\n","import { defineProperty } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport { getKeypath } from 'shared/keypaths';\nimport patch from './patch';\n\nvar arrayAdaptor,\n\n\t// helpers\n\tArrayWrapper,\n\terrorMessage;\n\narrayAdaptor = {\n\tfilter: function ( object ) {\n\t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t\t// or the array didn't trigger the get() itself\n\t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t},\n\twrap: function ( ractive, array, keypath ) {\n\t\treturn new ArrayWrapper( ractive, array, keypath );\n\t}\n};\n\nArrayWrapper = function ( ractive, array, keypath ) {\n\tthis.root = ractive;\n\tthis.value = array;\n\tthis.keypath = getKeypath( keypath );\n\n\t// if this array hasn't already been ractified, ractify it\n\tif ( !array._ractive ) {\n\n\t\t// define a non-enumerable _ractive property to store the wrappers\n\t\tdefineProperty( array, '_ractive', {\n\t\t\tvalue: {\n\t\t\t\twrappers: [],\n\t\t\t\tinstances: [],\n\t\t\t\tsetting: false\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\n\t\tpatch( array );\n\t}\n\n\t// store the ractive instance, so we can handle transitions later\n\tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t\tarray._ractive.instances.push( ractive );\n\t}\n\n\tarray._ractive.instances[ ractive._guid ] += 1;\n\tarray._ractive.wrappers.push( this );\n};\n\nArrayWrapper.prototype = {\n\tget: function () {\n\t\treturn this.value;\n\t},\n\tteardown: function () {\n\t\tvar array, storage, wrappers, instances, index;\n\n\t\tarray = this.value;\n\t\tstorage = array._ractive;\n\t\twrappers = storage.wrappers;\n\t\tinstances = storage.instances;\n\n\t\t// if teardown() was invoked because we're clearing the cache as a result of\n\t\t// a change that the array itself triggered, we can save ourselves the teardown\n\t\t// and immediate setup\n\t\tif ( storage.setting ) {\n\t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n\t\t}\n\n\t\tindex = wrappers.indexOf( this );\n\t\tif ( index === -1 ) {\n\t\t\tthrow new Error( errorMessage );\n\t\t}\n\n\t\twrappers.splice( index, 1 );\n\n\t\t// if nothing else depends on this array, we can revert it to its\n\t\t// natural state\n\t\tif ( !wrappers.length ) {\n\t\t\tdelete array._ractive;\n\t\t\tpatch.unpatch( this.value );\n\t\t}\n\n\t\telse {\n\t\t\t// remove ractive instance if possible\n\t\t\tinstances[ this.root._guid ] -= 1;\n\t\t\tif ( !instances[ this.root._guid ] ) {\n\t\t\t\tindex = instances.indexOf( this.root );\n\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\tthrow new Error( errorMessage );\n\t\t\t\t}\n\n\t\t\t\tinstances.splice( index, 1 );\n\t\t\t}\n\t\t}\n\t}\n};\n\nerrorMessage = 'Something went wrong in a rather interesting way';\nexport default arrayAdaptor;\n","import runloop from 'global/runloop';\nimport createBranch from 'utils/createBranch';\nimport { getKeypath } from 'shared/keypaths';\nimport { isArray } from 'utils/is';\n\nvar magicAdaptor, MagicWrapper;\n\ntry {\n\tObject.defineProperty({}, 'test', { value: 0 });\n\n\tmagicAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\tvar parentWrapper, parentValue;\n\n\t\t\tif ( !keypath ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tkeypath = getKeypath( keypath );\n\n\t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n\t\t\t// we shouldn't wrap this property\n\t\t\tif ( ( parentWrapper = ractive.viewmodel.wrapped[ keypath.parent.str ] ) && !parentWrapper.magic ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparentValue = ractive.viewmodel.get( keypath.parent );\n\n\t\t\t// if parentValue is an array that doesn't include this member,\n\t\t\t// we should return false otherwise lengths will get messed up\n\t\t\tif ( isArray( parentValue ) && /^[0-9]+$/.test( keypath.lastKey ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) );\n\t\t},\n\t\twrap: function ( ractive, property, keypath ) {\n\t\t\treturn new MagicWrapper( ractive, property, keypath );\n\t\t}\n\t};\n\n\tMagicWrapper = function ( ractive, value, keypath ) {\n\t\tvar objKeypath, template, siblings;\n\n\t\tkeypath = getKeypath( keypath );\n\n\t\tthis.magic = true;\n\n\t\tthis.ractive = ractive;\n\t\tthis.keypath = keypath;\n\t\tthis.value = value;\n\n\t\tthis.prop = keypath.lastKey;\n\n\t\tobjKeypath = keypath.parent;\n\t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get( objKeypath );\n\n\t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\n\t\t// Has this property already been wrapped?\n\t\tif ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {\n\n\t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n\t\t\tif ( siblings.indexOf( this ) === -1 ) {\n\t\t\t\tsiblings.push( this );\n\t\t\t}\n\n\t\t\treturn; // already wrapped\n\t\t}\n\n\t\t// No, it hasn't been wrapped\n\t\tcreateAccessors( this, value, template );\n\t};\n\n\tMagicWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\treset: function ( value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.updating = true;\n\t\t\tthis.obj[ this.prop ] = value; // trigger set() accessor\n\t\t\trunloop.addRactive( this.ractive );\n\t\t\tthis.ractive.viewmodel.mark( this.keypath, { keepExistingWrapper: true } );\n\t\t\tthis.updating = false;\n\t\t\treturn true;\n\t\t},\n\t\tset: function ( key, value ) {\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( !this.obj[ this.prop ] ) {\n\t\t\t\tthis.updating = true;\n\t\t\t\tthis.obj[ this.prop ] = createBranch( key );\n\t\t\t\tthis.updating = false;\n\t\t\t}\n\n\t\t\tthis.obj[ this.prop ][ key ] = value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tvar template, set, value, wrappers, index;\n\n\t\t\t// If this method was called because the cache was being cleared as a\n\t\t\t// result of a set()/update() call made by this wrapper, we return false\n\t\t\t// so that it doesn't get torn down\n\t\t\tif ( this.updating ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttemplate = Object.getOwnPropertyDescriptor( this.obj, this.prop );\n\t\t\tset = template && template.set;\n\n\t\t\tif ( !set ) {\n\t\t\t\t// most likely, this was an array member that was spliced out\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twrappers = set._ractiveWrappers;\n\n\t\t\tindex = wrappers.indexOf( this );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\twrappers.splice( index, 1 );\n\t\t\t}\n\n\t\t\t// Last one out, turn off the lights\n\t\t\tif ( !wrappers.length ) {\n\t\t\t\tvalue = this.obj[ this.prop ];\n\n\t\t\t\tObject.defineProperty( this.obj, this.prop, this.originalDescriptor || {\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\n\t\t\t\tthis.obj[ this.prop ] = value;\n\t\t\t}\n\t\t}\n\t};\n} catch ( err ) {\n\tmagicAdaptor = false; // no magic in this browser\n}\n\nexport default magicAdaptor;\n\nfunction createAccessors ( originalWrapper, value, template ) {\n\n\tvar object, property, oldGet, oldSet, get, set;\n\n\tobject = originalWrapper.obj;\n\tproperty = originalWrapper.prop;\n\n\t// Is this template configurable?\n\tif ( template && !template.configurable ) {\n\t\t// Special case - array length\n\t\tif ( property === 'length' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error( 'Cannot use magic mode with property \"' + property + '\" - object is not configurable' );\n\t}\n\n\n\t// Time to wrap this property\n\tif ( template ) {\n\t\toldGet = template.get;\n\t\toldSet = template.set;\n\t}\n\n\tget = oldGet || function () {\n\t\treturn value;\n\t};\n\n\tset = function ( v ) {\n\t\tif ( oldSet ) {\n\t\t\toldSet( v );\n\t\t}\n\n\t\tvalue = oldGet ? oldGet() : v;\n\t\tset._ractiveWrappers.forEach( updateWrapper );\n\t};\n\n\tfunction updateWrapper ( wrapper ) {\n\t\tvar keypath, ractive;\n\n\t\twrapper.value = value;\n\n\t\tif ( wrapper.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tractive = wrapper.ractive;\n\t\tkeypath = wrapper.keypath;\n\n\t\twrapper.updating = true;\n\t\trunloop.start( ractive );\n\n\t\tractive.viewmodel.mark( keypath );\n\n\t\trunloop.end();\n\t\twrapper.updating = false;\n\t}\n\n\t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n\t// Handily, we can store them as a property of the set function. Yay JavaScript.\n\tset._ractiveWrappers = [ originalWrapper ];\n\tObject.defineProperty( object, property, { get: get, set: set, enumerable: true, configurable: true });\n}\n","var numeric = /^\\s*[0-9]+\\s*$/;\n\nexport default function ( key ) {\n\treturn numeric.test( key ) ? [] : {};\n}\n","import magicAdaptor from './magic';\nimport arrayAdaptor from './array/index';\n\nvar magicArrayAdaptor, MagicArrayWrapper;\n\nif ( magicAdaptor ) {\n\tmagicArrayAdaptor = {\n\t\tfilter: function ( object, keypath, ractive ) {\n\t\t\treturn magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t\t},\n\n\t\twrap: function ( ractive, array, keypath ) {\n\t\t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t\t}\n\t};\n\n\tMagicArrayWrapper = function ( ractive, array, keypath ) {\n\t\tthis.value = array;\n\n\t\tthis.magic = true;\n\n\t\tthis.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );\n\t\tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t};\n\n\tMagicArrayWrapper.prototype = {\n\t\tget: function () {\n\t\t\treturn this.value;\n\t\t},\n\t\tteardown: function () {\n\t\t\tthis.arrayWrapper.teardown();\n\t\t\tthis.magicWrapper.teardown();\n\t\t},\n\t\treset: function ( value ) {\n\t\t\treturn this.magicWrapper.reset( value );\n\t\t}\n\t};\n}\n\nexport default magicArrayAdaptor;\n","var prefixers = {};\n\nexport default function Viewmodel$adapt ( keypath, value ) {\n\tvar len, i, adaptor, wrapped;\n\n\tif ( !this.adaptors ) return;\n\n\t// Do we have an adaptor for this value?\n\tlen = this.adaptors.length;\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tadaptor = this.adaptors[i];\n\n\t\tif ( adaptor.filter( value, keypath, this.ractive ) ) {\n\t\t\twrapped = this.wrapped[ keypath ] = adaptor.wrap( this.ractive, value, keypath, getPrefixer( keypath ) );\n\t\t\twrapped.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nfunction prefixKeypath ( obj, prefix ) {\n\tvar prefixed = {}, key;\n\n\tif ( !prefix ) {\n\t\treturn obj;\n\t}\n\n\tprefix += '.';\n\n\tfor ( key in obj ) {\n\t\tif ( obj.hasOwnProperty( key ) ) {\n\t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn prefixed;\n}\n\nfunction getPrefixer ( rootKeypath ) {\n\tvar rootDot;\n\n\tif ( !prefixers[ rootKeypath ] ) {\n\t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n\t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t\t\tvar obj;\n\n\t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t\t\t}\n\t\t};\n\t}\n\n\treturn prefixers[ rootKeypath ];\n}\n","export default notifyPatternObservers;\n\nfunction notifyPatternObservers ( viewmodel, keypath, onlyDirect ) {\n\tvar potentialWildcardMatches;\n\n\tupdateMatchingPatternObservers( viewmodel, keypath );\n\n\tif ( onlyDirect ) {\n\t\treturn;\n\t}\n\n\tpotentialWildcardMatches = keypath.wildcardMatches();\n\tpotentialWildcardMatches.forEach( upstreamPattern => {\n\t\tcascade( viewmodel, upstreamPattern, keypath );\n\t});\n}\n\n\nfunction cascade ( viewmodel, upstreamPattern, keypath ) {\n\tvar group, map, actualChildKeypath;\n\n\t// TODO should be one or the other\n\tupstreamPattern = ( upstreamPattern.str || upstreamPattern );\n\n\tgroup = viewmodel.depsMap.patternObservers;\n\tmap = group && group[ upstreamPattern ];\n\n\tif ( !map ) {\n\t\treturn;\n\t}\n\n\tmap.forEach( childKeypath => {\n\t\tactualChildKeypath = keypath.join( childKeypath.lastKey ); // 'foo.bar.baz'\n\n\t\tupdateMatchingPatternObservers( viewmodel, actualChildKeypath );\n\t\tcascade( viewmodel, childKeypath, actualChildKeypath );\n\t});\n}\n\nfunction updateMatchingPatternObservers ( viewmodel, keypath ) {\n\tviewmodel.patternObservers.forEach( observer => {\n\t\tif ( observer.regex.test( keypath.str ) ) {\n\t\t\tobserver.update( keypath );\n\t\t}\n\t});\n}\n","export default function Viewmodel$capture () {\n\tthis.captureGroups.push([]);\n}\n","export default function Viewmodel$clearCache ( keypath, keepExistingWrapper ) {\n\tvar cacheMap, wrapper;\n\n\tif ( !keepExistingWrapper ) {\n\t\t// Is there a wrapped property at this keypath?\n\t\tif ( wrapper = this.wrapped[ keypath ] ) {\n\t\t\t// Did we unwrap it?\n\t\t\tif ( wrapper.teardown() !== false ) {\n\t\t\t\t// Is this right?\n\t\t\t\t// What's the meaning of returning false from teardown?\n\t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n\t\t\t\tthis.wrapped[ keypath ] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cache[ keypath ] = undefined;\n\n\tif ( cacheMap = this.cacheMap[ keypath ] ) {\n\t\twhile ( cacheMap.length ) {\n\t\t\tthis.clearCache( cacheMap.pop() );\n\t\t}\n\t}\n}\n","var UnresolvedDependency = function ( computation, ref ) {\n\tthis.computation = computation;\n\tthis.viewmodel = computation.viewmodel;\n\tthis.ref = ref;\n\n\t// TODO this seems like a red flag!\n\tthis.root = this.viewmodel.ractive;\n\tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n};\n\nUnresolvedDependency.prototype = {\n\tresolve: function ( keypath ) {\n\t\tthis.computation.softDeps.push( keypath );\n\t\tthis.computation.unresolvedDeps[ keypath.str ] = null;\n\t\tthis.viewmodel.register( keypath, this.computation, 'computed' );\n\t}\n};\n\nexport default UnresolvedDependency;","import runloop from 'global/runloop';\nimport { logIfDebug, warnIfDebug, warnOnce } from 'utils/log';\nimport { isEqual } from 'utils/is';\nimport UnresolvedDependency from './UnresolvedDependency';\n\nvar Computation = function ( key, signature ) {\n\tthis.key = key;\n\n\tthis.getter = signature.getter;\n\tthis.setter = signature.setter;\n\n\tthis.hardDeps = signature.deps || [];\n\tthis.softDeps = [];\n\tthis.unresolvedDeps = {};\n\n\tthis.depValues = {};\n\n\tthis._dirty = this._firstRun = true;\n};\n\nComputation.prototype = {\n\tconstructor: Computation,\n\n\tinit ( viewmodel ) {\n\t\tvar initial;\n\n\t\tthis.viewmodel = viewmodel;\n\t\tthis.bypass = true;\n\n\t\tinitial = viewmodel.get( this.key );\n\t\tviewmodel.clearCache( this.key.str );\n\n\t\tthis.bypass = false;\n\n\t\tif ( this.setter && initial !== undefined ) {\n\t\t\tthis.set( initial );\n\t\t}\n\n\t\tif ( this.hardDeps ) {\n\t\t\tthis.hardDeps.forEach( d => viewmodel.register( d, this, 'computed' ) );\n\t\t}\n\t},\n\n\tinvalidate () {\n\t\tthis._dirty = true;\n\t},\n\n\tget () {\n\t\tvar newDeps, dependenciesChanged, dependencyValuesChanged = false;\n\n\t\tif ( this.getting ) {\n\t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n\t\t\tlet msg = `The ${this.key.str} computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by \\`array.sort(...)\\` - if that\\'s the case, clone the array first with \\`array.slice().sort(...)\\``;\n\t\t\twarnOnce( msg );\n\t\t\treturn this.value;\n\t\t}\n\n\t\tthis.getting = true;\n\n\t\tif ( this._dirty ) {\n\t\t\t// determine whether the inputs have changed, in case this depends on\n\t\t\t// other computed values\n\t\t\tif ( this._firstRun || ( !this.hardDeps.length && !this.softDeps.length ) ) {\n\t\t\t\tdependencyValuesChanged = true;\n\t\t\t} else {\n\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\tvar keypath, value, i;\n\n\t\t\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ti = deps.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tkeypath = deps[i];\n\t\t\t\t\t\tvalue = this.viewmodel.get( keypath );\n\n\t\t\t\t\t\tif ( !isEqual( value, this.depValues[ keypath.str ] ) ) {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = value;\n\t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( dependencyValuesChanged ) {\n\t\t\t\tthis.viewmodel.capture();\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.value = this.getter();\n\t\t\t\t} catch ( err ) {\n\t\t\t\t\twarnIfDebug( 'Failed to compute \"%s\"', this.key.str );\n\t\t\t\t\tlogIfDebug( err.stack || err );\n\n\t\t\t\t\tthis.value = void 0;\n\t\t\t\t}\n\n\t\t\t\tnewDeps = this.viewmodel.release();\n\t\t\t\tdependenciesChanged = this.updateDependencies( newDeps );\n\n\t\t\t\tif ( dependenciesChanged ) {\n\t\t\t\t\t[ this.hardDeps, this.softDeps ].forEach( deps => {\n\t\t\t\t\t\tdeps.forEach( keypath => {\n\t\t\t\t\t\t\tthis.depValues[ keypath.str ] = this.viewmodel.get( keypath );\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._dirty = false;\n\t\t}\n\n\t\tthis.getting = this._firstRun = false;\n\t\treturn this.value;\n\t},\n\n\tset ( value ) {\n\t\tif ( this.setting ) {\n\t\t\tthis.value = value;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !this.setter ) {\n\t\t\tthrow new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );\n\t\t}\n\n\t\tthis.setter( value );\n\t},\n\n\tupdateDependencies ( newDeps ) {\n\t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n\t\toldDeps = this.softDeps;\n\n\t\t// remove dependencies that are no longer used\n\t\ti = oldDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = oldDeps[i];\n\n\t\t\tif ( newDeps.indexOf( keypath ) === -1 ) {\n\t\t\t\tdependenciesChanged = true;\n\t\t\t\tthis.viewmodel.unregister( keypath, this, 'computed' );\n\t\t\t}\n\t\t}\n\n\t\t// create references for any new dependencies\n\t\ti = newDeps.length;\n\t\twhile ( i-- ) {\n\t\t\tkeypath = newDeps[i];\n\n\t\t\tif ( oldDeps.indexOf( keypath ) === -1 && ( !this.hardDeps || this.hardDeps.indexOf( keypath ) === -1 ) ) {\n\t\t\t\tdependenciesChanged = true;\n\n\t\t\t\t// if this keypath is currently unresolved, we need to mark\n\t\t\t\t// it as such. TODO this is a bit muddy...\n\t\t\t\tif ( isUnresolved( this.viewmodel, keypath ) && ( !this.unresolvedDeps[ keypath.str ] ) ) {\n\t\t\t\t\tunresolved = new UnresolvedDependency( this, keypath.str );\n\t\t\t\t\tnewDeps.splice( i, 1 );\n\n\t\t\t\t\tthis.unresolvedDeps[ keypath.str ] = unresolved;\n\t\t\t\t\trunloop.addUnresolved( unresolved );\n\t\t\t\t} else {\n\t\t\t\t\tthis.viewmodel.register( keypath, this, 'computed' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dependenciesChanged ) {\n\t\t\tthis.softDeps = newDeps.slice();\n\t\t}\n\n\t\treturn dependenciesChanged;\n\t}\n};\n\nfunction isUnresolved( viewmodel, keypath ) {\n\tvar key = keypath.firstKey;\n\n\treturn !( key in viewmodel.data ) &&\n\t       !( key in viewmodel.computations ) &&\n\t       !( key in viewmodel.mappings );\n}\n\nexport default Computation;\n","import { lastItem } from 'utils/array';\nimport { hasOwn } from 'utils/object';\nimport FAILED_LOOKUP from './get/FAILED_LOOKUP';\n\nvar empty = {};\n\nexport default function Viewmodel$get ( keypath, options ) {\n\tvar cache = this.cache,\n\t\tvalue,\n\t\tcomputation,\n\t\twrapped,\n\t\tcaptureGroup,\n\t\tkeypathStr = keypath.str,\n\t\tkey;\n\n\toptions = options || empty;\n\n\t// capture the keypath, if we're inside a computation\n\tif ( options.capture && ( captureGroup = lastItem( this.captureGroups ) ) ) {\n\t\tif ( !~captureGroup.indexOf( keypath ) ) {\n\t\t\tcaptureGroup.push( keypath );\n\t\t}\n\t}\n\n\tif ( hasOwn.call( this.mappings, keypath.firstKey ) ) {\n\t\treturn this.mappings[ keypath.firstKey ].get( keypath, options );\n\t}\n\n\tif ( keypath.isSpecial ) {\n\t\treturn keypath.value;\n\t}\n\n\tif ( cache[ keypathStr ] === undefined ) {\n\n\t\t// Is this a computed property?\n\t\tif ( ( computation = this.computations[ keypathStr ] ) && !computation.bypass ) {\n\t\t\tvalue = computation.get();\n\t\t\tthis.adapt( keypathStr, value );\n\t\t}\n\n\t\t// Is this a wrapped property?\n\t\telse if ( wrapped = this.wrapped[ keypathStr ] ) {\n\t\t\tvalue = wrapped.value;\n\t\t}\n\n\t\t// Is it the root?\n\t\telse if ( keypath.isRoot ) {\n\t\t\tthis.adapt( '', this.data );\n\t\t\tvalue = this.data;\n\t\t}\n\n\t\t// No? Then we need to retrieve the value one key at a time\n\t\telse {\n\t\t\tvalue = retrieve( this, keypath );\n\t\t}\n\n\t\tcache[ keypathStr ] = value;\n\t} else {\n\t\tvalue = cache[ keypathStr ];\n\t}\n\n\tif ( !options.noUnwrap && ( wrapped = this.wrapped[ keypathStr ] ) ) {\n\t\tvalue = wrapped.get();\n\t}\n\n\tif ( keypath.isRoot && options.fullRootGet ) {\n\t\tfor ( key in this.mappings ) {\n\t\t\tvalue[ key ] = this.mappings[ key ].getValue();\n\t\t}\n\t}\n\n\treturn value === FAILED_LOOKUP ? void 0 : value;\n}\n\nfunction retrieve ( viewmodel, keypath ) {\n\n\tvar parentValue, cacheMap, value, wrapped;\n\n\tparentValue = viewmodel.get( keypath.parent );\n\n\tif ( wrapped = viewmodel.wrapped[ keypath.parent.str ] ) {\n\t\tparentValue = wrapped.get();\n\t}\n\n\tif ( parentValue === null || parentValue === undefined ) {\n\t\treturn;\n\t}\n\n\t// update cache map\n\tif ( !( cacheMap = viewmodel.cacheMap[ keypath.parent.str ] ) ) {\n\t\tviewmodel.cacheMap[ keypath.parent.str ] = [ keypath.str ];\n\t} else {\n\t\tif ( cacheMap.indexOf( keypath.str ) === -1 ) {\n\t\t\tcacheMap.push( keypath.str );\n\t\t}\n\t}\n\n\t// If this property doesn't exist, we return a sentinel value\n\t// so that we know to query parent scope (if such there be)\n\tif ( typeof parentValue === 'object' && !( keypath.lastKey in parentValue ) ) {\n\t\treturn viewmodel.cache[ keypath.str ] = FAILED_LOOKUP;\n\t}\n\n\tvalue = parentValue[ keypath.lastKey ];\n\n\t// Do we have an adaptor for this value?\n\tviewmodel.adapt( keypath.str, value, false );\n\n\t// Update cache\n\tviewmodel.cache[ keypath.str ] = value;\n\treturn value;\n}\n","export default function Viewmodel$init () {\n\tvar key;\n\n\tfor ( key in this.computations ) {\n\t\tthis.computations[ key ].init( this );\n\t}\n}","export default function Viewmodel$map ( key, options ) {\n\tvar mapping = this.mappings[ key.str ] = new Mapping( key, options );\n\tmapping.initViewmodel( this );\n\treturn mapping;\n}\n\nvar Mapping = function ( localKey, options ) {\n\tthis.localKey = localKey;\n\tthis.keypath = options.keypath;\n\tthis.origin = options.origin;\n\n\tthis.deps = [];\n\tthis.unresolved = [];\n\n\tthis.resolved = false;\n};\n\nMapping.prototype = {\n\tforceResolution () {\n\t\t// TODO warn, as per #1692?\n\t\tthis.keypath = this.localKey;\n\t\tthis.setup();\n\t},\n\n\tget ( keypath, options ) {\n\t\tif ( !this.resolved ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.map( keypath ), options );\n\t},\n\n\tgetValue () {\n\t\tif ( !this.keypath ) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.origin.get( this.keypath );\n\t},\n\n\tinitViewmodel ( viewmodel ) {\n\t\tthis.local = viewmodel;\n\t\tthis.setup();\n\t},\n\n\tmap ( keypath ) {\n    \t\tif( typeof this.keypath === undefined ) {\n    \t\t\treturn this.localKey;\n    \t\t}\n    \t\treturn keypath.replace( this.localKey, this.keypath );\n\t},\n\n\tregister ( keypath, dependant, group ) {\n\t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n\t\tif ( this.resolved ) {\n\t\t\tthis.origin.register( this.map( keypath ), dependant, group );\n\t\t}\n\t},\n\n\tresolve ( keypath ) {\n\t\tif ( this.keypath !== undefined ) {\n\t\t\tthis.unbind( true );\n\t\t}\n\n\t\tthis.keypath = keypath;\n\t\tthis.setup();\n\t},\n\n\tset ( keypath, value ) {\n\t\tif ( !this.resolved ) {\n\t\t\tthis.forceResolution();\n\t\t}\n\n\t\tthis.origin.set( this.map( keypath ), value );\n\t},\n\n\tsetup () {\n\t\tif ( this.keypath === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.resolved = true;\n\n\t\t// accumulated dependants can now be registered\n\t\tif ( this.deps.length ) {\n\t\t\tthis.deps.forEach( d => {\n\t\t\t\tvar keypath = this.map( d.keypath );\n\t\t\t\tthis.origin.register( keypath, d.dep, d.group );\n\n\t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n\t\t\t\tif ( d.dep.setValue ) {\n\t\t\t\t\td.dep.setValue( this.origin.get( keypath ) );\n\t\t\t\t} else if ( d.dep.invalidate ) {\n\t\t\t\t\td.dep.invalidate();\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error( 'An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.origin.mark( this.keypath );\n\t\t}\n\t},\n\n\tsetValue ( value ) {\n\t\tif ( !this.keypath ) {\n\t\t\tthrow new Error( 'Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t\t}\n\n\t\tthis.origin.set( this.keypath, value );\n\t},\n\n\tunbind ( keepLocal ) {\n\t\tif ( !keepLocal ) {\n\t\t\tdelete this.local.mappings[ this.localKey ];\n\t\t}\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.deps.forEach( d => {\n\t\t\tthis.origin.unregister( this.map( d.keypath ), d.dep, d.group );\n\t\t});\n\n\t\tif ( this.tracker ) {\n\t\t\tthis.origin.unregister( this.keypath, this.tracker );\n\t\t}\n\t},\n\n\tunregister ( keypath, dependant, group ) {\n\t\tvar deps, i;\n\n\t\tif( !this.resolved ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdeps = this.deps;\n\t\ti = deps.length;\n\n\t\twhile ( i-- ) {\n\t\t\tif ( deps[i].dep === dependant ) {\n\t\t\t\tdeps.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.origin.unregister( this.map( keypath ), dependant, group );\n\t}\n};\n","export default function Viewmodel$mark ( keypath, options ) {\n\tvar computation, keypathStr = keypath.str;\n\n\t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n\t// should not be picked up by pattern observers\n\tif ( options ) {\n\t\tif ( options.implicit ) {\n\t\t\tthis.implicitChanges[ keypathStr ] = true;\n\t\t}\n\t\tif ( options.noCascade ) {\n\t\t\tthis.noCascade[ keypathStr ] = true;\n\t\t}\n\t}\n\n\tif ( computation = this.computations[ keypathStr ] ) {\n\t\tcomputation.invalidate();\n\t}\n\n\tif ( this.changes.indexOf( keypath ) === -1 ) {\n\t\tthis.changes.push( keypath );\n\t}\n\n\t// pass on keepExistingWrapper, if we can\n\tlet keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n\tthis.clearCache( keypathStr, keepExistingWrapper );\n\n\tif ( this.ready ) {\n\t\tthis.onchange();\n\t}\n}\n","export default function ( oldArray, newArray ) {\n\tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n\tusedIndices = {};\n\tfirstUnusedIndex = 0;\n\n\tnewIndices = oldArray.map( function ( item, i ) {\n\t\tvar index, start, len;\n\n\t\tstart = firstUnusedIndex;\n\t\tlen = newArray.length;\n\n\t\tdo {\n\t\t\tindex = newArray.indexOf( item, start );\n\n\t\t\tif ( index === -1 ) {\n\t\t\t\tchanged = true;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstart = index + 1;\n\t\t} while ( usedIndices[ index ] && start < len );\n\n\t\t// keep track of the first unused index, so we don't search\n\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t\tif ( index === firstUnusedIndex ) {\n\t\t\tfirstUnusedIndex += 1;\n\t\t}\n\n\t\tif ( index !== i ) {\n\t\t\tchanged = true;\n\t\t}\n\n\t\tusedIndices[ index ] = true;\n\t\treturn index;\n\t});\n\n\treturn newIndices;\n}\n","import { warnIfDebug } from 'utils/log';\nimport mapOldToNewIndex from './merge/mapOldToNewIndex';\n\nvar comparators = {};\n\nexport default function Viewmodel$merge ( keypath, currentArray, array, options ) {\n\tvar oldArray,\n\t\tnewArray,\n\t\tcomparator,\n\t\tnewIndices;\n\n\tthis.mark( keypath );\n\n\tif ( options && options.compare ) {\n\n\t\tcomparator = getComparatorFunction( options.compare );\n\n\t\ttry {\n\t\t\toldArray = currentArray.map( comparator );\n\t\t\tnewArray = array.map( comparator );\n\t\t} catch ( err ) {\n\t\t\t// fallback to an identity check - worst case scenario we have\n\t\t\t// to do more DOM manipulation than we thought...\n\t\t\twarnIfDebug( 'merge(): \"%s\" comparison failed. Falling back to identity checking', keypath );\n\n\t\t\toldArray = currentArray;\n\t\t\tnewArray = array;\n\t\t}\n\n\t} else {\n\t\toldArray = currentArray;\n\t\tnewArray = array;\n\t}\n\n\t// find new indices for members of oldArray\n\tnewIndices = mapOldToNewIndex( oldArray, newArray );\n\n\tthis.smartUpdate( keypath, array, newIndices, currentArray.length !== array.length );\n}\n\nfunction stringify ( item ) {\n\treturn JSON.stringify( item );\n}\n\nfunction getComparatorFunction ( comparator ) {\n\t// If `compare` is `true`, we use JSON.stringify to compare\n\t// objects that are the same shape, but non-identical - i.e.\n\t// { foo: 'bar' } !== { foo: 'bar' }\n\tif ( comparator === true ) {\n\t\treturn stringify;\n\t}\n\n\tif ( typeof comparator === 'string' ) {\n\t\tif ( !comparators[ comparator ] ) {\n\t\t\tcomparators[ comparator ] = function ( item ) {\n\t\t\t\treturn item[ comparator ];\n\t\t\t};\n\t\t}\n\n\t\treturn comparators[ comparator ];\n\t}\n\n\tif ( typeof comparator === 'function' ) {\n\t\treturn comparator;\n\t}\n\n\tthrow new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );\n}\n","export default function Viewmodel$register ( keypath, dependant, group = 'default' ) {\n\tvar mapping, depsByKeypath, deps;\n\n\tif ( dependant.isStatic ) {\n\t\treturn; // TODO we should never get here if a dependant is static...\n\t}\n\n\tif ( mapping = this.mappings[ keypath.firstKey ] ) {\n\t\tmapping.register( keypath, dependant, group );\n\t}\n\n\telse {\n\t\tdepsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );\n\t\tdeps = depsByKeypath[ keypath.str ] || ( depsByKeypath[ keypath.str ] = [] );\n\n\t\tdeps.push( dependant );\n\n\t\tif ( !this.depsMap[ group ] ) {\n\t\t\tthis.depsMap[ group ] = {};\n\t\t}\n\n\t\tif ( !keypath.isRoot ) {\n\t\t\tupdateDependantsMap( this, keypath, group );\n\t\t}\n\t}\n}\n\nfunction updateDependantsMap ( viewmodel, keypath, group ) {\n\tvar map, parent, keypathStr;\n\n\t// update dependants map\n\twhile ( !keypath.isRoot ) {\n\t\tmap = viewmodel.depsMap[ group ];\n\t\tparent = map[ keypath.parent.str ] || ( map[ keypath.parent.str ] = [] );\n\n\t\tkeypathStr = keypath.str;\n\n\t\t// TODO find an alternative to this nasty approach\n\t\tif ( parent[ '_' + keypathStr ] === undefined ) {\n\t\t\tparent[ '_' + keypathStr ] = 0;\n\t\t\tparent.push( keypath );\n\t\t}\n\n\t\tparent[ '_' + keypathStr ] += 1;\n\t\tkeypath = keypath.parent;\n\t}\n}\n","export default function Viewmodel$release () {\n\treturn this.captureGroups.pop();\n}\n","export default function Viewmodel$reset ( data ) {\n\tthis.data = data;\n\tthis.clearCache( '' );\n}","var implicitOption = { implicit: true }, noCascadeOption = { noCascade: true };\n\nexport default function Viewmodel$smartUpdate ( keypath, array, newIndices ) {\n\tvar dependants, oldLength, i;\n\n\toldLength = newIndices.length;\n\n\t// Indices that are being removed should be marked as dirty\n\tnewIndices.forEach( ( newIndex, oldIndex ) => {\n\t\tif ( newIndex === -1 ) {\n\t\t\tthis.mark( keypath.join( oldIndex ), noCascadeOption );\n\t\t}\n\t});\n\n\t// Update the model\n\t// TODO allow existing array to be updated in place, rather than replaced?\n\tthis.set( keypath, array, { silent: true } );\n\n\tif ( dependants = this.deps[ 'default' ][ keypath.str ] ) {\n\t\tdependants.filter( canShuffle ).forEach( d => d.shuffle( newIndices, array ) );\n\t}\n\n\tif ( oldLength !== array.length ) {\n\t\tthis.mark( keypath.join( 'length' ), implicitOption );\n\n\t\tfor ( i = newIndices.touchedFrom; i < array.length; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ) );\n\t\t}\n\n\t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n\t\t// TODO is this still necessary, now that computations are lazy?\n\t\tfor ( i = array.length; i < oldLength; i += 1 ) {\n\t\t\tthis.mark( keypath.join( i ), noCascadeOption );\n\t\t}\n\t}\n}\n\nfunction canShuffle ( dependant ) {\n\treturn typeof dependant.shuffle === 'function';\n}\n","export default function Viewmodel$teardown () {\n\tvar unresolvedImplicitDependency;\n\n\t// Clear entire cache - this has the desired side-effect\n\t// of unwrapping adapted values (e.g. arrays)\n\tObject.keys( this.cache ).forEach( keypath => this.clearCache( keypath ) );\n\n\t// Teardown any failed lookups - we don't need them to resolve any more\n\twhile ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {\n\t\tunresolvedImplicitDependency.teardown();\n\t}\n}\n","import { fatal } from 'utils/log';\nimport { getKeypath } from 'shared/keypaths';\nimport { create } from 'utils/object';\nimport adapt from './prototype/adapt';\nimport applyChanges from './prototype/applyChanges';\nimport capture from './prototype/capture';\nimport clearCache from './prototype/clearCache';\nimport compute from './prototype/compute';\nimport get from './prototype/get';\nimport init from './prototype/init';\nimport map from './prototype/map';\nimport mark from './prototype/mark';\nimport merge from './prototype/merge';\nimport register from './prototype/register';\nimport release from './prototype/release';\nimport reset from './prototype/reset';\nimport set from './prototype/set';\nimport smartUpdate from './prototype/smartUpdate';\nimport teardown from './prototype/teardown';\nimport unregister from './prototype/unregister';\n\nvar Viewmodel = function ( options ) {\n\tvar { adapt, data, ractive, computed, mappings } = options,\n\t\tkey,\n\t\tmapping;\n\n\t// TODO is it possible to remove this reference?\n\tthis.ractive = ractive;\n\n\tthis.adaptors = adapt;\n\tthis.onchange = options.onchange;\n\n\tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n\tthis.cacheMap = create( null );\n\n\tthis.deps = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\tthis.depsMap = {\n\t\tcomputed: create( null ),\n\t\t'default': create( null )\n\t};\n\n\tthis.patternObservers = [];\n\n\tthis.specials = create( null );\n\n\tthis.wrapped = create( null );\n\tthis.computations = create( null );\n\n\tthis.captureGroups = [];\n\tthis.unresolvedImplicitDependencies = [];\n\n\tthis.changes = [];\n\tthis.implicitChanges = {};\n\tthis.noCascade = {};\n\n\tthis.data = data;\n\n\t// set up explicit mappings\n\tthis.mappings = create( null );\n\tfor ( key in mappings ) {\n\t\tthis.map( getKeypath( key ), mappings[ key ] );\n\t}\n\n\tif ( data ) {\n\t\t// if data exists locally, but is missing on the parent,\n\t\t// we transfer ownership to the parent\n\t\tfor ( key in data ) {\n\t\t\tif ( ( mapping = this.mappings[ key ] ) && mapping.getValue() === undefined ) {\n\t\t\t\tmapping.setValue( data[ key ] );\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( key in computed ) {\n\t\tif ( mappings && key in mappings ) {\n\t\t\tfatal( 'Cannot map to a computed property (\\'%s\\')', key );\n\t\t}\n\n\t\tthis.compute( getKeypath( key ), computed[ key ] );\n\t}\n\n\tthis.ready = true;\n};\n\nViewmodel.prototype = {\n\tadapt: adapt,\n\tapplyChanges: applyChanges,\n\tcapture: capture,\n\tclearCache: clearCache,\n\tcompute: compute,\n\tget: get,\n\tinit: init,\n\tmap: map,\n\tmark: mark,\n\tmerge: merge,\n\tregister: register,\n\trelease: release,\n\treset: reset,\n\tset: set,\n\tsmartUpdate: smartUpdate,\n\tteardown: teardown,\n\tunregister: unregister\n};\n\nexport default Viewmodel;\n","import Hook from './Hook';\n\nfunction HookQueue ( event ) {\n\tthis.hook = new Hook( event );\n\tthis.inProcess = {};\n\tthis.queue = {};\n}\n\nHookQueue.prototype = {\n\n\tconstructor: HookQueue,\n\n\tbegin: function ( ractive ) {\n\t\tthis.inProcess[ ractive._guid ] = true;\n\t},\n\n\tend: function ( ractive ) {\n\n\t\tvar parent = ractive.parent;\n\n\t\t// If this is *isn't* a child of a component that's in process,\n\t\t// it should call methods or fire at this point\n\t\tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t\t\tfire( this, ractive );\n\t\t}\n\t\t// elsewise, handoff to parent to fire when ready\n\t\telse {\n\t\t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t\t}\n\n\t\tdelete this.inProcess[ ractive._guid ];\n\t}\n};\n\nfunction getChildQueue ( queue, ractive ) {\n\treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n}\n\nfunction fire ( hookQueue, ractive ) {\n\n\tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n\thookQueue.hook.fire( ractive );\n\n\t// queue is \"live\" because components can end up being\n\t// added while hooks fire on parents that modify data values.\n\twhile ( childQueue.length ) {\n\t\tfire( hookQueue, childQueue.shift() );\n\t}\n\n\tdelete hookQueue.queue[ ractive._guid ];\n}\n\n\nexport default HookQueue;\n","import { fatal } from 'utils/log';\n\nvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\nexport default function getComputationSignatures ( ractive, computed ) {\n\tvar signatures = {}, key;\n\n\tfor ( key in computed ) {\n\t\tsignatures[ key ] = getComputationSignature( ractive, key, computed[ key ] );\n\t}\n\n\treturn signatures;\n}\n\nfunction getComputationSignature ( ractive, key, signature ) {\n\tvar getter, setter;\n\n\tif ( typeof signature === 'function' ) {\n\t\tgetter = bind( signature, ractive );\n\t}\n\n\tif ( typeof signature === 'string' ) {\n\t\tgetter = createFunctionFromString( ractive, signature );\n\t}\n\n\tif ( typeof signature === 'object' ) {\n\t\tif ( typeof signature.get === 'string' ) {\n\t\t\tgetter = createFunctionFromString( ractive, signature.get );\n\t\t} else if ( typeof signature.get === 'function' ) {\n\t\t\tgetter = bind( signature.get, ractive );\n\t\t} else {\n\t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t\t}\n\n\t\tif ( typeof signature.set === 'function' ) {\n\t\t\tsetter = bind( signature.set, ractive );\n\t\t}\n\t}\n\n\treturn { getter: getter, setter: setter };\n}\n\nfunction createFunctionFromString ( ractive, str ) {\n\tvar functionBody, hasThis, fn;\n\n\tfunctionBody = 'return (' + str.replace( pattern, ( match, keypath ) => {\n\t\thasThis = true;\n\t\treturn '__ractive.get(\"' + keypath + '\")';\n\t}) + ');';\n\n\tif ( hasThis ) {\n\t\tfunctionBody = 'var __ractive = this; ' + functionBody;\n\t}\n\n\tfn = new Function( functionBody );\n\treturn hasThis ? fn.bind( ractive ) : fn;\n}\n\nfunction bind ( fn, context ) {\n\treturn /this/.test( fn.toString() ) ? fn.bind( context ) : fn;\n}","import { fatal, logIfDebug, warnIfDebug, warnOnceIfDebug, welcome } from 'utils/log';\nimport { missingPlugin } from 'config/errors';\nimport { magic as magicSupported } from 'config/environment';\nimport { ensureArray } from 'utils/array';\nimport { findInViewHierarchy } from 'shared/registry';\nimport arrayAdaptor from 'Ractive/static/adaptors/array/index';\nimport magicAdaptor from 'Ractive/static/adaptors/magic';\nimport magicArrayAdaptor from 'Ractive/static/adaptors/magicArray';\nimport { getElement } from 'utils/dom';\nimport { create, defineProperty, extend } from 'utils/object';\nimport runloop from 'global/runloop';\nimport config from 'Ractive/config/config';\nimport dataConfigurator from 'Ractive/config/custom/data';\nimport Fragment from 'virtualdom/Fragment';\nimport Viewmodel from 'viewmodel/Viewmodel';\nimport Hook from './prototype/shared/hooks/Hook';\nimport HookQueue from './prototype/shared/hooks/HookQueue';\nimport getComputationSignatures from './helpers/getComputationSignatures';\nimport Ractive from '../Ractive';\n\nlet constructHook = new Hook( 'construct' );\nlet configHook = new Hook( 'config' );\nlet initHook = new HookQueue( 'init' );\nlet uid = 0;\n\nlet registryNames = [\n\t'adaptors',\n\t'components',\n\t'decorators',\n\t'easing',\n\t'events',\n\t'interpolators',\n\t'partials',\n\t'transitions'\n];\n\nexport default initialiseRactiveInstance;\n\nfunction initialiseRactiveInstance ( ractive, userOptions = {}, options = {} ) {\n\tvar el, viewmodel;\n\n\tif ( Ractive.DEBUG ) {\n\t\twelcome();\n\t}\n\n\tinitialiseProperties( ractive, options );\n\n\t// TODO remove this, eventually\n\tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n\t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\tconstructHook.fire( ractive, userOptions );\n\n\t// Add registries\n\tregistryNames.forEach( name => {\n\t\tractive[ name ] = extend( create( ractive.constructor[ name ] || null ), userOptions[ name ] );\n\t});\n\n\t// Create a viewmodel\n\tviewmodel = new Viewmodel({\n\t\tadapt: getAdaptors( ractive, ractive.adapt, userOptions ),\n\t\tdata: dataConfigurator.init( ractive.constructor, ractive, userOptions ),\n\t\tcomputed: getComputationSignatures( ractive, extend( create( ractive.constructor.prototype.computed ), userOptions.computed ) ),\n\t\tmappings: options.mappings,\n\t\tractive: ractive,\n\t\tonchange: () => runloop.addRactive( ractive )\n\t});\n\n\tractive.viewmodel = viewmodel;\n\n\t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n\tviewmodel.init();\n\n\t// init config from Parent and options\n\tconfig.init( ractive.constructor, ractive, userOptions );\n\n\tconfigHook.fire( ractive );\n\tinitHook.begin( ractive );\n\n\t// // If this is a component with a function `data` property, call the function\n\t// // with `ractive` as context (unless the child was also a function)\n\t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n\t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n\t// }\n\n\n\t// Render virtual DOM\n\tif ( ractive.template ) {\n\t\tlet cssIds;\n\n\t\tif ( options.cssIds || ractive.cssId ) {\n\t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n\t\t\tif ( ractive.cssId ) {\n\t\t\t\tcssIds.push( ractive.cssId );\n\t\t\t}\n\t\t}\n\n\t\tractive.fragment = new Fragment({\n\t\t\ttemplate: ractive.template,\n\t\t\troot: ractive,\n\t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n\t\t\tcssIds\n\t\t});\n\t}\n\n\tinitHook.end( ractive );\n\n\t// render automatically ( if `el` is specified )\n\tif ( el = getElement( ractive.el ) ) {\n\t\tlet promise = ractive.render( el, ractive.append );\n\n\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t\t\tpromise.catch( err => {\n\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive });\n\t\t\t\terr.stack && logIfDebug( err.stack );\n\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction getAdaptors ( ractive, protoAdapt, userOptions ) {\n\tvar adapt, magic, modifyArrays;\n\n\tprotoAdapt = protoAdapt.map( lookup );\n\tadapt = ensureArray( userOptions.adapt ).map( lookup );\n\n\tadapt = combine( protoAdapt, adapt );\n\n\tmagic = 'magic' in userOptions ? userOptions.magic : ractive.magic;\n\tmodifyArrays = 'modifyArrays' in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n\tif ( magic ) {\n\t\tif ( !magicSupported ) {\n\t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t\t}\n\n\t\tif ( modifyArrays ) {\n\t\t\tadapt.push( magicArrayAdaptor );\n\t\t}\n\n\t\tadapt.push( magicAdaptor );\n\t}\n\n\tif ( modifyArrays ) {\n\t\tadapt.push( arrayAdaptor );\n\t}\n\n\treturn adapt;\n\n\n\tfunction lookup ( adaptor ) {\n\t\tif ( typeof adaptor === 'string' ) {\n\t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n\t\t\tif ( !adaptor ) {\n\t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t\t\t}\n\t\t}\n\n\t\treturn adaptor;\n\t}\n}\n\nfunction combine ( a, b ) {\n\tvar c = a.slice(), i = b.length;\n\n\twhile ( i-- ) {\n\t\tif ( !~c.indexOf( b[i] ) ) {\n\t\t\tc.push( b[i] );\n\t\t}\n\t}\n\n\treturn c;\n}\n\nfunction initialiseProperties ( ractive, options ) {\n\t// Generate a unique identifier, for places where you'd use a weak map if it\n\t// existed\n\tractive._guid = 'r-' + uid++;\n\n\t// events\n\tractive._subs = create( null );\n\n\t// storage for item configuration from instantiation to reset,\n\t// like dynamic functions or original values\n\tractive._config = {};\n\n\t// two-way bindings\n\tractive._twowayBindings = create( null );\n\n\t// animations (so we can stop any in progress at teardown)\n\tractive._animations = [];\n\n\t// nodes registry\n\tractive.nodes = {};\n\n\t// live queries\n\tractive._liveQueries = [];\n\tractive._liveComponentQueries = [];\n\n\t// bound data functions\n\tractive._boundFunctions = [];\n\n\t// observers\n\tractive._observers = [];\n\n\n\t// properties specific to inline components\n\tif ( options.component ) {\n\t\tractive.parent = options.parent;\n\t\tractive.container = options.container || null;\n\t\tractive.root = ractive.parent.root;\n\n\t\tractive.component = options.component;\n\t\toptions.component.instance = ractive;\n\n\t\t// for hackability, this could be an open option\n\t\t// for any ractive instance, but for now, just\n\t\t// for components and just for ractive...\n\t\tractive._inlinePartials = options.inlinePartials;\n\t} else {\n\t\tractive.root = ractive;\n\t\tractive.parent = ractive.container = null;\n\t}\n}\n\nfunction deprecateRactiveData () {\n\tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n}\n","import runloop from 'global/runloop';\nimport Fragment from 'virtualdom/Fragment';\n\nfunction ComplexParameter ( component, template, callback ) {\n\tthis.parentFragment = component.parentFragment;\n\tthis.callback = callback;\n\n\tthis.fragment = new Fragment({\n\t\ttemplate: template,\n\t\troot:     component.root,\n\t\towner:    this\n\t});\n\n\tthis.update();\n}\n\nexport default ComplexParameter;\n\nComplexParameter.prototype = {\n\tbubble: function () {\n\t\tif ( !this.dirty ) {\n\t\t\tthis.dirty = true;\n\t\t\trunloop.addView( this );\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\tthis.callback( this.fragment.getValue() );\n\t\tthis.dirty = false;\n\t},\n\n\trebind: function ( oldKeypath, newKeypath ) {\n\t\tthis.fragment.rebind( oldKeypath, newKeypath );\n\t},\n\n\tunbind: function () {\n\t\tthis.fragment.unbind();\n\t}\n};\n\n","import { INTERPOLATOR, YIELDER } from 'config/types';\nimport { warnIfDebug } from 'utils/log';\nimport { create, extend } from 'utils/object';\nimport { isArray } from 'utils/is';\nimport parseJSON from 'utils/parseJSON';\nimport initialise from 'Ractive/initialise';\nimport createReferenceResolver from 'virtualdom/items/shared/Resolvers/createReferenceResolver';\nimport ExpressionResolver from 'virtualdom/items/shared/Resolvers/ExpressionResolver';\nimport ReferenceExpressionResolver from 'virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver';\nimport ComplexParameter from './ComplexParameter';\n\nexport default function ( component, Component, attributes, yieldTemplate, partials ) {\n\tvar instance, parentFragment, ractive, fragment, container, inlinePartials = {}, data = {}, mappings = {}, ready, resolvers = [];\n\n\tparentFragment = component.parentFragment;\n\tractive = component.root;\n\n\tpartials = partials || {};\n\textend( inlinePartials, partials );\n\n\t// Make contents available as a {{>content}} partial\n\tpartials.content = yieldTemplate || [];\n\n\t// set a default partial for yields with no name\n\tinlinePartials[''] = partials.content;\n\n\tif ( Component.defaults.el ) {\n\t\twarnIfDebug( 'The <%s/> component has a default `el` property; it has been disregarded', component.name );\n\t}\n\n\t// find container\n\tfragment = parentFragment;\n\twhile ( fragment ) {\n\t\tif ( fragment.owner.type === YIELDER ) {\n\t\t\tcontainer = fragment.owner.container;\n\t\t\tbreak;\n\t\t}\n\n\t\tfragment = fragment.parent;\n\t}\n\n\t// each attribute represents either a) data or b) a mapping\n\tif ( attributes ) {\n\t\tObject.keys( attributes ).forEach( key => {\n\t\t\tvar attribute = attributes[ key ], parsed, resolver;\n\n\t\t\tif ( typeof attribute === 'string' ) {\n\t\t\t\t// it's static data\n\t\t\t\tparsed = parseJSON( attribute );\n\t\t\t\tdata[ key ] = parsed ? parsed.value : attribute;\n\t\t\t}\n\n\t\t\telse if ( attribute === 0 ) {\n\t\t\t\t// it had no '=', so we'll call it true\n\t\t\t\tdata[ key ] = true;\n\t\t\t}\n\n\t\t\telse if ( isArray( attribute ) ) {\n\t\t\t\t// this represents dynamic data\n\t\t\t\tif ( isSingleInterpolator( attribute ) ) {\n\t\t\t\t\tmappings[ key ] = {\n\t\t\t\t\t\torigin: component.root.viewmodel,\n\t\t\t\t\t\tkeypath: undefined\n\t\t\t\t\t};\n\n\t\t\t\t\tresolver = createResolver( component, attribute[0], function ( keypath ) {\n\t\t\t\t\t\tif ( keypath.isSpecial ) {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.set( key, keypath.value ); // TODO use viewmodel?\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdata[ key ] = keypath.value;\n\n\t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n\t\t\t\t\t\t\t\tdelete mappings[ key ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\t\tinstance.viewmodel.mappings[ key ].resolve( keypath );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// resolved immediately\n\t\t\t\t\t\t\t\tmappings[ key ].keypath = keypath;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tresolver = new ComplexParameter( component, attribute, function ( value ) {\n\t\t\t\t\t\tif ( ready ) {\n\t\t\t\t\t\t\tinstance.set( key, value ); // TODO use viewmodel?\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata[ key ] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tresolvers.push( resolver );\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow new Error( 'erm wut' );\n\t\t\t}\n\t\t});\n\t}\n\n\tinstance = create( Component.prototype );\n\n\tinitialise( instance, {\n\t\tel: null,\n\t\tappend: true,\n\t\tdata,\n\t\tpartials,\n\t\tmagic: ractive.magic || Component.defaults.magic,\n\t\tmodifyArrays: ractive.modifyArrays,\n\t\t// need to inherit runtime parent adaptors\n\t\tadapt: ractive.adapt\n\t}, {\n\t\tparent: ractive,\n\t\tcomponent,\n\t\tcontainer,\n\t\tmappings,\n\t\tinlinePartials,\n\t\tcssIds: parentFragment.cssIds\n\t});\n\n\tready = true;\n\tcomponent.resolvers = resolvers;\n\n\treturn instance;\n}\n\nfunction createResolver ( component, template, callback ) {\n\tvar resolver;\n\n\tif ( template.r ) {\n\t\tresolver = createReferenceResolver( component, template.r, callback );\n\t}\n\n\telse if ( template.x ) {\n\t\tresolver = new ExpressionResolver( component, component.parentFragment, template.x, callback );\n\t}\n\n\telse if ( template.rx ) {\n\t\tresolver = new ReferenceExpressionResolver( component, template.rx, callback );\n\t}\n\n\treturn resolver;\n}\n\nfunction isSingleInterpolator( template ){\n\treturn template.length === 1 && template[0].t === INTERPOLATOR;\n}\n","export default function ( component ) {\n\tvar ancestor, query;\n\n\t// If there's a live query for this component type, add it\n\tancestor = component.root;\n\twhile ( ancestor ) {\n\t\tif ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery.push( component.instance );\n\t\t}\n\n\t\tancestor = ancestor.parent;\n\t}\n}\n","export default function Component$rebind ( oldKeypath, newKeypath ) {\n\tvar query;\n\n\tthis.resolvers.forEach( rebind );\n\n\tfor ( let k in this.yielders ) {\n\t\tif ( this.yielders[k][0] ) {\n\t\t\trebind( this.yielders[k][0] );\n\t\t}\n\t}\n\n\tif ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {\n\t\tquery._makeDirty();\n\t}\n\n\tfunction rebind ( x ) {\n\t\tx.rebind( oldKeypath, newKeypath );\n\t}\n}\n","export default function Component$render () {\n\tvar instance = this.instance;\n\n\tinstance.render( this.parentFragment.getNode() );\n\n\tthis.rendered = true;\n\treturn instance.fragment.detach();\n}\n","export default function Component$toString () {\n\treturn this.instance.fragment.toString();\n}\n","import Hook from 'Ractive/prototype/shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\nimport { unbind, cancel } from 'shared/methodCallers';\n\nvar teardownHook = new Hook( 'teardown' );\n\nexport default function Component$unbind () {\n\tvar instance = this.instance;\n\n\tthis.resolvers.forEach( unbind );\n\n\tremoveFromLiveComponentQueries( this );\n\n\tinstance._observers.forEach( cancel );\n\n\t// teardown the instance\n\tinstance.fragment.unbind();\n\tinstance.viewmodel.teardown();\n\n\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t}\n\n\tteardownHook.fire( instance );\n}\n\nfunction removeFromLiveComponentQueries ( component ) {\n\tvar instance, query;\n\n\tinstance = component.root;\n\n\tdo {\n\t\tif ( query = instance._liveComponentQueries[ '_' + component.name ] ) {\n\t\t\tquery._remove( component );\n\t\t}\n\t} while ( instance = instance.parent );\n}","export default function Component$unrender ( shouldDestroy ) {\n\tthis.shouldDestroy = shouldDestroy;\n\tthis.instance.unrender();\n}\n","import detach from './prototype/detach';\nimport find from './prototype/find';\nimport findAll from './prototype/findAll';\nimport findAllComponents from './prototype/findAllComponents';\nimport findComponent from './prototype/findComponent';\nimport findNextNode from './prototype/findNextNode';\nimport firstNode from './prototype/firstNode';\nimport init from './prototype/init';\nimport rebind from './prototype/rebind';\nimport render from './prototype/render';\nimport toString from './prototype/toString';\nimport unbind from './prototype/unbind';\nimport unrender from './prototype/unrender';\n\nvar Component = function ( options, Constructor ) {\n\tthis.init( options, Constructor );\n};\n\nComponent.prototype = {\n\tdetach: detach,\n\tfind: find,\n\tfindAll: findAll,\n\tfindAllComponents: findAllComponents,\n\tfindComponent: findComponent,\n\tfindNextNode: findNextNode,\n\tfirstNode: firstNode,\n\tinit: init,\n\trebind: rebind,\n\trender: render,\n\ttoString: toString,\n\tunbind: unbind,\n\tunrender: unrender\n};\n\nexport default Component;\n","import { warnIfDebug } from 'utils/log';\nimport runloop from 'global/runloop';\nimport interpolate from 'shared/interpolate';\n\nvar Animation = function ( options ) {\n\tvar key;\n\n\tthis.startTime = Date.now();\n\n\t// from and to\n\tfor ( key in options ) {\n\t\tif ( options.hasOwnProperty( key ) ) {\n\t\t\tthis[ key ] = options[ key ];\n\t\t}\n\t}\n\n\tthis.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );\n\tthis.running = true;\n\n\tthis.tick();\n};\n\nAnimation.prototype = {\n\ttick: function () {\n\t\tvar elapsed, t, value, timeNow, index, keypath;\n\n\t\tkeypath = this.keypath;\n\n\t\tif ( this.running ) {\n\t\t\ttimeNow = Date.now();\n\t\t\telapsed = timeNow - this.startTime;\n\n\t\t\tif ( elapsed >= this.duration ) {\n\t\t\t\tif ( keypath !== null ) {\n\t\t\t\t\trunloop.start( this.root );\n\t\t\t\t\tthis.root.viewmodel.set( keypath, this.to );\n\t\t\t\t\trunloop.end();\n\t\t\t\t}\n\n\t\t\t\tif ( this.step ) {\n\t\t\t\t\tthis.step( 1, this.to );\n\t\t\t\t}\n\n\t\t\t\tthis.complete( this.to );\n\n\t\t\t\tindex = this.root._animations.indexOf( this );\n\n\t\t\t\t// TODO investigate why this happens\n\t\t\t\tif ( index === -1 ) {\n\t\t\t\t\twarnIfDebug( 'Animation was not found' );\n\t\t\t\t}\n\n\t\t\t\tthis.root._animations.splice( index, 1 );\n\n\t\t\t\tthis.running = false;\n\t\t\t\treturn false; // remove from the stack\n\t\t\t}\n\n\t\t\tt = this.easing ? this.easing ( elapsed / this.duration ) : ( elapsed / this.duration );\n\n\t\t\tif ( keypath !== null ) {\n\t\t\t\tvalue = this.interpolator( t );\n\t\t\t\trunloop.start( this.root );\n\t\t\t\tthis.root.viewmodel.set( keypath, value );\n\t\t\t\trunloop.end();\n\t\t\t}\n\n\t\t\tif ( this.step ) {\n\t\t\t\tthis.step( t, value );\n\t\t\t}\n\n\t\t\treturn true; // keep in the stack\n\t\t}\n\n\t\treturn false; // remove from the stack\n\t},\n\n\tstop: function () {\n\t\tvar index;\n\n\t\tthis.running = false;\n\n\t\tindex = this.root._animations.indexOf( this );\n\n\t\t// TODO investigate why this happens\n\t\tif ( index === -1 ) {\n\t\t\twarnIfDebug( 'Animation was not found' );\n\t\t}\n\n\t\tthis.root._animations.splice( index, 1 );\n\t}\n};\n\nexport default Animation;\n","import animations from 'shared/animations';\nimport Animation from './animate/Animation';\nimport { isEqual } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport Promise from 'utils/Promise';\nimport noop from 'utils/noop';\n\nvar noAnimation = { stop: noop };\n\nexport default function Ractive$animate ( keypath, to, options ) {\n\tvar promise,\n\t\tfulfilPromise,\n\t\tk,\n\t\tanimation,\n\t\tanimations,\n\t\teasing,\n\t\tduration,\n\t\tstep,\n\t\tcomplete,\n\t\tmakeValueCollector,\n\t\tcurrentValues,\n\t\tcollectValue,\n\t\tdummy,\n\t\tdummyOptions;\n\n\tpromise = new Promise( fulfil => fulfilPromise = fulfil );\n\n\t// animate multiple keypaths\n\tif ( typeof keypath === 'object' ) {\n\t\toptions = to || {};\n\t\teasing = options.easing;\n\t\tduration = options.duration;\n\n\t\tanimations = [];\n\n\t\t// we don't want to pass the `step` and `complete` handlers, as they will\n\t\t// run for each animation! So instead we'll store the handlers and create\n\t\t// our own...\n\t\tstep = options.step;\n\t\tcomplete = options.complete;\n\n\t\tif ( step || complete ) {\n\t\t\tcurrentValues = {};\n\n\t\t\toptions.step = null;\n\t\t\toptions.complete = null;\n\n\t\t\tmakeValueCollector = function ( keypath ) {\n\t\t\t\treturn function ( t, value ) {\n\t\t\t\t\tcurrentValues[ keypath ] = value;\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\n\t\tfor ( k in keypath ) {\n\t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t\t\t\tif ( step || complete ) {\n\t\t\t\t\tcollectValue = makeValueCollector( k );\n\t\t\t\t\toptions = { easing, duration };\n\n\t\t\t\t\tif ( step ) {\n\t\t\t\t\t\toptions.step = collectValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toptions.complete = complete ? collectValue : noop;\n\t\t\t\tanimations.push( animate( this, k, keypath[k], options ) );\n\t\t\t}\n\t\t}\n\n\t\t// Create a dummy animation, to facilitate step/complete\n\t\t// callbacks, and Promise fulfilment\n\t\tdummyOptions = { easing, duration };\n\n\t\tif ( step ) {\n\t\t\tdummyOptions.step = t => step( t, currentValues );\n\t\t}\n\n\t\tif ( complete ) {\n\t\t\tpromise.then( t => complete( t, currentValues ) );\n\t\t}\n\n\t\tdummyOptions.complete = fulfilPromise;\n\n\t\tdummy = animate( this, null, null, dummyOptions );\n\t\tanimations.push( dummy );\n\n\t\tpromise.stop = () => {\n\t\t\tvar animation;\n\n\t\t\twhile ( animation = animations.pop() ) {\n\t\t\t\tanimation.stop();\n\t\t\t}\n\n\t\t\tif ( dummy ) {\n\t\t\t\tdummy.stop();\n\t\t\t}\n\t\t};\n\n\t\treturn promise;\n\t}\n\n\t// animate a single keypath\n\toptions = options || {};\n\n\tif ( options.complete ) {\n\t\tpromise.then( options.complete );\n\t}\n\n\toptions.complete = fulfilPromise;\n\tanimation = animate( this, keypath, to, options );\n\n\tpromise.stop = () => animation.stop();\n\treturn promise;\n}\n\nfunction animate ( root, keypath, to, options ) {\n\tvar easing, duration, animation, from;\n\n\tif ( keypath ) {\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\t}\n\n\tif ( keypath !== null ) {\n\t\tfrom = root.viewmodel.get( keypath );\n\t}\n\n\t// cancel any existing animation\n\t// TODO what about upstream/downstream keypaths?\n\tanimations.abort( keypath, root );\n\n\t// don't bother animating values that stay the same\n\tif ( isEqual( from, to ) ) {\n\t\tif ( options.complete ) {\n\t\t\toptions.complete( options.to );\n\t\t}\n\n\t\treturn noAnimation;\n\t}\n\n\t// easing function\n\tif ( options.easing ) {\n\t\tif ( typeof options.easing === 'function' ) {\n\t\t\teasing = options.easing;\n\t\t}\n\n\t\telse {\n\t\t\teasing = root.easing[ options.easing ];\n\t\t}\n\n\t\tif ( typeof easing !== 'function' ) {\n\t\t\teasing = null;\n\t\t}\n\t}\n\n\t// duration\n\tduration = ( options.duration === undefined ? 400 : options.duration );\n\n\t// TODO store keys, use an internal set method\n\tanimation = new Animation({\n\t\tkeypath,\n\t\tfrom,\n\t\tto,\n\t\troot,\n\t\tduration,\n\t\teasing,\n\t\tinterpolator: options.interpolator,\n\n\t\t// TODO wrap callbacks if necessary, to use instance as context\n\t\tstep: options.step,\n\t\tcomplete: options.complete\n\t});\n\n\tanimations.add( animation );\n\troot._animations.push( animation );\n\n\treturn animation;\n}\n","import Hook from './shared/hooks/Hook';\nimport { removeFromArray } from 'utils/array';\n\nvar detachHook = new Hook( 'detach' );\n\nexport default function Ractive$detach () {\n\tif ( this.detached ) {\n\t\treturn this.detached;\n\t}\n\n\tif ( this.el ) {\n\t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t}\n\tthis.detached = this.fragment.detach();\n\tdetachHook.fire( this );\n\treturn this.detached;\n}\n","export default function Ractive$find ( selector ) {\n\tif ( !this.el ) {\n\t\treturn null;\n\t}\n\n\treturn this.fragment.find( selector );\n}\n","export default function () {\n\tvar liveQueries, selector, index;\n\n\tliveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\tselector = this.selector;\n\n\tindex = liveQueries.indexOf( selector );\n\n\tif ( index !== -1 ) {\n\t\tliveQueries.splice( index, 1 );\n\t\tliveQueries[ selector ] = null;\n\t}\n}\n","import { lastItem } from 'utils/array';\n\nexport default function ( a, b ) {\n\tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n\tancestryA = getAncestry( a.component || a._ractive.proxy );\n\tancestryB = getAncestry( b.component || b._ractive.proxy );\n\n\toldestA = lastItem( ancestryA );\n\toldestB = lastItem( ancestryB );\n\n\t// remove items from the end of both ancestries as long as they are identical\n\t// - the final one removed is the closest mutual ancestor\n\twhile ( oldestA && ( oldestA === oldestB ) ) {\n\t\tancestryA.pop();\n\t\tancestryB.pop();\n\n\t\tmutualAncestor = oldestA;\n\n\t\toldestA = lastItem( ancestryA );\n\t\toldestB = lastItem( ancestryB );\n\t}\n\n\t// now that we have the mutual ancestor, we can find which is earliest\n\toldestA = oldestA.component || oldestA;\n\toldestB = oldestB.component || oldestB;\n\n\tfragmentA = oldestA.parentFragment;\n\tfragmentB = oldestB.parentFragment;\n\n\t// if both items share a parent fragment, our job is easy\n\tif ( fragmentA === fragmentB ) {\n\t\tindexA = fragmentA.items.indexOf( oldestA );\n\t\tindexB = fragmentB.items.indexOf( oldestB );\n\n\t\t// if it's the same index, it means one contains the other,\n\t\t// so we see which has the longest ancestry\n\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t}\n\n\t// if mutual ancestor is a section, we first test to see which section\n\t// fragment comes first\n\tif ( fragments = mutualAncestor.fragments ) {\n\t\tindexA = fragments.indexOf( fragmentA );\n\t\tindexB = fragments.indexOf( fragmentB );\n\n\t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t}\n\n\tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );\n}\n\nfunction getParent ( item ) {\n\tvar parentFragment;\n\n\tif ( parentFragment = item.parentFragment ) {\n\t\treturn parentFragment.owner;\n\t}\n\n\tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t\treturn parentFragment.owner;\n\t}\n}\n\nfunction getAncestry ( item ) {\n\tvar ancestry, ancestor;\n\n\tancestry = [ item ];\n\n\tancestor = getParent( item );\n\n\twhile ( ancestor ) {\n\t\tancestry.push( ancestor );\n\t\tancestor = getParent( ancestor );\n\t}\n\n\treturn ancestry;\n}\n","import sortByItemPosition from './sortByItemPosition';\n\nexport default function ( node, otherNode ) {\n\tvar bitmask;\n\n\tif ( node.compareDocumentPosition ) {\n\t\tbitmask = node.compareDocumentPosition( otherNode );\n\t\treturn ( bitmask & 2 ) ? 1 : -1;\n\t}\n\n\t// In old IE, we can piggy back on the mechanism for\n\t// comparing component positions\n\treturn sortByItemPosition( node, otherNode );\n}\n","import sortByDocumentPosition from './sortByDocumentPosition';\nimport sortByItemPosition from './sortByItemPosition';\n\nexport default function () {\n\tthis.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\tthis._dirty = false;\n}\n","import runloop from 'global/runloop';\n\nexport default function () {\n\tif ( !this._dirty ) {\n\t\tthis._dirty = true;\n\n\t\t// Once the DOM has been updated, ensure the query\n\t\t// is correctly ordered\n\t\trunloop.scheduleTask( () => {\n\t\t\tthis._sort();\n\t\t});\n\t}\n}\n","export default function ( nodeOrComponent ) {\n\tvar index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\n\tif ( index !== -1 ) {\n\t\tthis.splice( index, 1 );\n\t}\n}\n","export default function Ractive$findComponent ( selector ) {\n\treturn this.fragment.findComponent( selector );\n}\n","export default function Ractive$findParent ( selector ) {\n\n\tif ( this.parent ) {\n\t\tif ( this.parent.component && this.parent.component.name === selector ) {\n\t\t\treturn this.parent;\n\t\t} else {\n\t\t\treturn this.parent.findParent ( selector );\n\t\t}\n\t}\n\n\treturn null;\n}\n","var eventStack = {\n\tenqueue: function( ractive, event ) {\n\t\tif ( ractive.event ) {\n\t\t\tractive._eventQueue = ractive._eventQueue || [];\n\t\t\tractive._eventQueue.push( ractive.event );\n\t\t}\n\t\tractive.event = event;\n\t},\n\tdequeue: function( ractive ) {\n\t\tif ( ractive._eventQueue && ractive._eventQueue.length ) {\n\t\t\tractive.event = ractive._eventQueue.pop();\n\t\t} else {\n\t\t\tdelete ractive.event;\n\t\t}\n\t}\n};\n\nexport default eventStack;\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport resolveRef from 'shared/resolveRef';\n\nvar options = {\n\tcapture: true, // top-level calls should be intercepted\n\tnoUnwrap: true, // wrapped values should NOT be unwrapped\n\tfullRootGet: true // root get should return mappings\n};\n\nexport default function Ractive$get ( keypath ) {\n\tvar value;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\tvalue = this.viewmodel.get( keypath, options );\n\n\t// Create inter-component binding, if necessary\n\tif ( value === undefined && this.parent && !this.isolated ) {\n\t\tif ( resolveRef( this, keypath.str, this.component.parentFragment ) ) { // creates binding as side-effect, if appropriate\n\t\t\tvalue = this.viewmodel.get( keypath );\n\t\t}\n\t}\n\n\treturn value;\n}\n","import Hook from './shared/hooks/Hook';\nimport { getElement } from 'utils/dom';\n\nvar insertHook = new Hook( 'insert' );\n\nexport default function Ractive$insert ( target, anchor ) {\n\tif ( !this.fragment.rendered ) {\n\t\t// TODO create, and link to, documentation explaining this\n\t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t}\n\n\ttarget = getElement( target );\n\tanchor = getElement( anchor ) || null;\n\n\tif ( !target ) {\n\t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t}\n\n\ttarget.insertBefore( this.detach(), anchor );\n\tthis.el = target;\n\n\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\tthis.detached = null;\n\n\tfireInsertHook( this );\n}\n\nfunction fireInsertHook( ractive ) {\n\tinsertHook.fire( ractive );\n\n\tractive.findAllComponents('*').forEach( child => {\n\t\tfireInsertHook( child.instance );\n\t});\n}\n","import runloop from 'global/runloop';\nimport { isEqual } from 'utils/is';\n\nvar Observer = function ( ractive, keypath, callback, options ) {\n\tthis.root = ractive;\n\tthis.keypath = keypath;\n\tthis.callback = callback;\n\tthis.defer = options.defer;\n\n\t// default to root as context, but allow it to be overridden\n\tthis.context = ( options && options.context ? options.context : ractive );\n};\n\nObserver.prototype = {\n\tinit: function ( immediate ) {\n\t\tthis.value = this.root.get( this.keypath.str );\n\n\t\tif ( immediate !== false ) {\n\t\t\tthis.update();\n\t\t} else {\n\t\t\tthis.oldValue = this.value;\n\t\t}\n\t},\n\n\tsetValue: function ( value ) {\n\t\tif ( !isEqual( value, this.value ) ) {\n\t\t\tthis.value = value;\n\n\t\t\tif ( this.defer && this.ready ) {\n\t\t\t\trunloop.scheduleTask( () => this.update() );\n\t\t\t} else {\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t}\n\t},\n\n\tupdate: function () {\n\t\t// Prevent infinite loops\n\t\tif ( this.updating ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updating = true;\n\n\t\tthis.callback.call( this.context, this.value, this.oldValue, this.keypath.str );\n\t\tthis.oldValue = this.value;\n\n\t\tthis.updating = false;\n\t}\n};\n\nexport default Observer;\n","import runloop from 'global/runloop';\nimport { getKeypath } from 'shared/keypaths';\nimport { isEqual } from 'utils/is';\nimport getPattern from './getPattern';\n\nvar PatternObserver, slice = Array.prototype.slice;\n\nPatternObserver = function ( ractive, keypath, callback, options ) {\n\tthis.root = ractive;\n\n\tthis.callback = callback;\n\tthis.defer = options.defer;\n\n\tthis.keypath = keypath;\n\tthis.regex = new RegExp( '^' + keypath.str.replace( /\\./g, '\\\\.' ).replace( /\\*/g, '([^\\\\.]+)' ) + '$' );\n\tthis.values = {};\n\n\tif ( this.defer ) {\n\t\tthis.proxies = [];\n\t}\n\n\t// default to root as context, but allow it to be overridden\n\tthis.context = ( options && options.context ? options.context : ractive );\n};\n\nPatternObserver.prototype = {\n\tinit: function ( immediate ) {\n\t\tvar values, keypath;\n\n\t\tvalues = getPattern( this.root, this.keypath );\n\n\t\tif ( immediate !== false ) {\n\t\t\tfor ( keypath in values ) {\n\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\tthis.update( getKeypath( keypath ) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.values = values;\n\t\t}\n\t},\n\n\tupdate: function ( keypath ) {\n\t\tvar values;\n\n\t\tif ( keypath.isPattern ) {\n\t\t\tvalues = getPattern( this.root, keypath );\n\n\t\t\tfor ( keypath in values ) {\n\t\t\t\tif ( values.hasOwnProperty( keypath ) ) {\n\t\t\t\t\tthis.update( getKeypath( keypath ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// special case - array mutation should not trigger `array.*`\n\t\t// pattern observer with `array.length`\n\t\tif ( this.root.viewmodel.implicitChanges[ keypath.str ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.defer && this.ready ) {\n\t\t\trunloop.scheduleTask( () => this.getProxy( keypath ).update() );\n\t\t\treturn;\n\t\t}\n\n\t\tthis.reallyUpdate( keypath );\n\t},\n\n\treallyUpdate: function ( keypath ) {\n\t\tvar keypathStr, value, keys, args;\n\n\t\tkeypathStr = keypath.str;\n\t\tvalue = this.root.viewmodel.get( keypath );\n\n\t\t// Prevent infinite loops\n\t\tif ( this.updating ) {\n\t\t\tthis.values[ keypathStr ] = value;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updating = true;\n\n\t\tif ( !isEqual( value, this.values[ keypathStr ] ) || !this.ready ) {\n\t\t\tkeys = slice.call( this.regex.exec( keypathStr ), 1 );\n\t\t\targs = [ value, this.values[ keypathStr ], keypathStr ].concat( keys );\n\n\t\t\tthis.values[ keypathStr ] = value;\n\t\t\tthis.callback.apply( this.context, args );\n\t\t}\n\n\t\tthis.updating = false;\n\t},\n\n\tgetProxy: function ( keypath ) {\n\t\tif ( !this.proxies[ keypath.str ] ) {\n\t\t\tthis.proxies[ keypath.str ] = {\n\t\t\t\tupdate: () => this.reallyUpdate( keypath )\n\t\t\t};\n\t\t}\n\n\t\treturn this.proxies[ keypath.str ];\n\t}\n};\n\nexport default PatternObserver;\n","import { isClient } from 'config/environment';\nimport noop from 'utils/noop';\n\nvar css,\n\tupdate,\n\tstyleElement,\n\thead,\n\tstyleSheet,\n\tinDom,\n\tprefix = '/* Ractive.js component styles */\\n',\n\tstyles = [],\n\tdirty = false;\n\nif ( !isClient ) {\n\t// TODO handle encapsulated CSS in server-rendered HTML!\n\tcss = {\n\t\tadd: noop,\n\t\tapply: noop\n\t};\n} else {\n\tstyleElement = document.createElement( 'style' );\n\tstyleElement.type = 'text/css';\n\n\thead = document.getElementsByTagName( 'head' )[0];\n\n\tinDom = false;\n\n\t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n\t// use styleSheet.cssText instead\n\tstyleSheet = styleElement.styleSheet;\n\n\tupdate = function () {\n\t\tlet css = prefix + styles.map( s => `\\n/* {${s.id}} */\\n${s.styles}` ).join( '\\n' );\n\n\t\tif ( styleSheet ) {\n\t\t\tstyleSheet.cssText = css;\n\t\t} else {\n\t\t\tstyleElement.innerHTML = css;\n\t\t}\n\n\t\tif ( !inDom ) {\n\t\t\thead.appendChild( styleElement );\n\t\t\tinDom = true;\n\t\t}\n\t};\n\n\tcss = {\n\t\tadd ( s ) {\n\t\t\tstyles.push( s );\n\t\t\tdirty = true;\n\t\t},\n\n\t\tapply () {\n\t\t\tif ( dirty ) {\n\t\t\t\tupdate();\n\t\t\t\tdirty = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport default css;\n","import { getKeypath, normalise } from 'shared/keypaths';\nimport Observer from './Observer';\nimport PatternObserver from './PatternObserver';\n\nlet emptyObject = {};\n\nexport default function getObserverFacade ( ractive, keypath, callback, options ) {\n\tvar observer, isPatternObserver, cancelled;\n\n\tkeypath = getKeypath( normalise( keypath ) );\n\toptions = options || emptyObject;\n\n\t// pattern observers are treated differently\n\tif ( keypath.isPattern ) {\n\t\tobserver = new PatternObserver( ractive, keypath, callback, options );\n\t\tractive.viewmodel.patternObservers.push( observer );\n\t\tisPatternObserver = true;\n\t} else {\n\t\tobserver = new Observer( ractive, keypath, callback, options );\n\t}\n\n\tobserver.init( options.init );\n\tractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );\n\n\t// This flag allows observers to initialise even with undefined values\n\tobserver.ready = true;\n\n\tlet facade = {\n\t\tcancel () {\n\t\t\tvar index;\n\n\t\t\tif ( cancelled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isPatternObserver ) {\n\t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf( observer );\n\n\t\t\t\tractive.viewmodel.patternObservers.splice( index, 1 );\n\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'patternObservers' );\n\t\t\t} else {\n\t\t\t\tractive.viewmodel.unregister( keypath, observer, 'observers' );\n\t\t\t}\n\t\t\tcancelled = true;\n\t\t}\n\t};\n\n\tractive._observers.push( facade );\n\treturn facade;\n}\n","export default function Ractive$observeOnce ( property, callback, options ) {\n\n\tvar observer = this.observe( property, function () {\n\t\tcallback.apply( this, arguments );\n\t\tobserver.cancel();\n\t}, { init: false, defer: options && options.defer });\n\n\treturn observer;\n}\n","export default str => str.trim();\n","export default str => str !== '';\n","export default function Ractive$once ( eventName, handler ) {\n\n\tvar listener = this.on( eventName, function () {\n\t\thandler.apply( this, arguments );\n\t\tlistener.cancel();\n\t});\n\n\t// so we can still do listener.cancel() manually\n\treturn listener;\n}\n","import { isArray } from 'utils/is';\nimport { getKeypath, normalise } from 'shared/keypaths';\nimport runloop from 'global/runloop';\nimport getNewIndices from 'shared/getNewIndices';\n\nvar arrayProto = Array.prototype;\n\nexport default function ( methodName ) {\n\treturn function ( keypath, ...args ) {\n\t\tvar array, newIndices = [], len, promise, result;\n\n\t\tkeypath = getKeypath( normalise( keypath ) );\n\n\t\tarray = this.viewmodel.get( keypath );\n\t\tlen = array.length;\n\n\t\tif ( !isArray( array ) ) {\n\t\t\tthrow new Error( 'Called ractive.' + methodName + '(\\'' + keypath.str + '\\'), but \\'' + keypath.str + '\\' does not refer to an array' );\n\t\t}\n\n\t\tnewIndices = getNewIndices( array, methodName, args );\n\n\t\tresult = arrayProto[ methodName ].apply( array, args );\n\t\tpromise = runloop.start( this, true ).then( () => result );\n\n\t\tif ( !!newIndices ) {\n\t\t\tthis.viewmodel.smartUpdate( keypath, array, newIndices );\n\t\t} else {\n\t\t\tthis.viewmodel.mark( keypath );\n\t\t}\n\n\t\trunloop.end();\n\n\t\treturn promise;\n\t};\n}\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'pop' );\n","import makeArrayMethod from './shared/makeArrayMethod';\nexport default makeArrayMethod( 'push' );\n","import { create, hasOwn } from 'utils/object';\n\nvar Parser, ParseError, leadingWhitespace = /^\\s+/;\n\nParseError = function ( message ) {\n\tthis.name = 'ParseError';\n\tthis.message = message;\n\ttry {\n\t\tthrow new Error(message);\n\t} catch (e) {\n\t\tthis.stack = e.stack;\n\t}\n};\n\nParseError.prototype = Error.prototype;\n\nParser = function ( str, options ) {\n\tvar items, item, lineStart = 0;\n\n\tthis.str = str;\n\tthis.options = options || {};\n\tthis.pos = 0;\n\n\tthis.lines = this.str.split( '\\n' );\n\tthis.lineEnds = this.lines.map( line => {\n\t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n\t\tlineStart = lineEnd;\n\t\treturn lineEnd;\n\t}, 0 );\n\n\t// Custom init logic\n\tif ( this.init ) this.init( str, options );\n\n\titems = [];\n\n\twhile ( ( this.pos < this.str.length ) && ( item = this.read() ) ) {\n\t\titems.push( item );\n\t}\n\n\tthis.leftover = this.remaining();\n\tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n};\n\nParser.prototype = {\n\tread: function ( converters ) {\n\t\tvar pos, i, len, item;\n\n\t\tif ( !converters ) converters = this.converters;\n\n\t\tpos = this.pos;\n\n\t\tlen = converters.length;\n\t\tfor ( i = 0; i < len; i += 1 ) {\n\t\t\tthis.pos = pos; // reset for each attempt\n\n\t\t\tif ( item = converters[i]( this ) ) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tgetLinePos: function ( char ) {\n\t\tvar lineNum = 0, lineStart = 0, columnNum;\n\n\t\twhile ( char >= this.lineEnds[ lineNum ] ) {\n\t\t\tlineStart = this.lineEnds[ lineNum ];\n\t\t\tlineNum += 1;\n\t\t}\n\n\t\tcolumnNum = char - lineStart;\n\t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n\t},\n\n\terror: function ( message ) {\n\t\tlet pos = this.getLinePos( this.pos );\n\t\tlet lineNum = pos[0];\n\t\tlet columnNum = pos[1];\n\n\t\tlet line = this.lines[ pos[0] - 1 ];\n\t\tlet numTabs = 0;\n\t\tlet annotation = line.replace( /\\t/g, ( match, char ) => {\n\t\t\tif ( char < pos[1] ) {\n\t\t\t\tnumTabs += 1;\n\t\t\t}\n\n\t\t\treturn '  ';\n\t\t}) + '\\n' + new Array( pos[1] + numTabs ).join( ' ' ) + '^----';\n\n\t\tlet error = new ParseError( `${message} at line ${lineNum} character ${columnNum}:\\n${annotation}` );\n\n\t\terror.line = pos[0];\n\t\terror.character = pos[1];\n\t\terror.shortMessage = message;\n\n\t\tthrow error;\n\t},\n\n\tmatchString: function ( string ) {\n\t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t\t\tthis.pos += string.length;\n\t\t\treturn string;\n\t\t}\n\t},\n\n\tmatchPattern: function ( pattern ) {\n\t\tvar match;\n\n\t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t\t\tthis.pos += match[0].length;\n\t\t\treturn match[1] || match[0];\n\t\t}\n\t},\n\n\tallowWhitespace: function () {\n\t\tthis.matchPattern( leadingWhitespace );\n\t},\n\n\tremaining: function () {\n\t\treturn this.str.substring( this.pos );\n\t},\n\n\tnextChar: function () {\n\t\treturn this.str.charAt( this.pos );\n\t}\n};\n\nParser.extend = function ( proto ) {\n\tvar Parent = this, Child, key;\n\n\tChild = function ( str, options ) {\n\t\tParser.call( this, str, options );\n\t};\n\n\tChild.prototype = create( Parent.prototype );\n\n\tfor ( key in proto ) {\n\t\tif ( hasOwn.call( proto, key ) ) {\n\t\t\tChild.prototype[ key ] = proto[ key ];\n\t\t}\n\t}\n\n\tChild.extend = Parser.extend;\n\treturn Child;\n};\n\nexport default Parser;\n","import css from 'global/css';\nimport Hook from './shared/hooks/Hook';\nimport { getElement } from 'utils/dom';\nimport { teardown } from 'shared/methodCallers';\nimport runloop from 'global/runloop';\n\nvar renderHook = new Hook( 'render' ),\n\tcompleteHook = new Hook( 'complete' );\n\nexport default function Ractive$render ( target, anchor ) {\n\tvar promise, instances, transitionsEnabled;\n\n\t// if `noIntro` is `true`, temporarily disable transitions\n\ttransitionsEnabled = this.transitionsEnabled;\n\tif ( this.noIntro ) {\n\t\tthis.transitionsEnabled = false;\n\t}\n\n\tpromise = runloop.start( this, true );\n\trunloop.scheduleTask( () => renderHook.fire( this ), true );\n\n\tif ( this.fragment.rendered ) {\n\t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t}\n\n\ttarget = getElement( target ) || this.el;\n\tanchor = getElement( anchor ) || this.anchor;\n\n\tthis.el = target;\n\tthis.anchor = anchor;\n\n\tif ( !this.append && target ) {\n\t\t// Teardown any existing instances *before* trying to set up the new one -\n\t\t// avoi